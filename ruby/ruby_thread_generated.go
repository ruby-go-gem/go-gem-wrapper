// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated
// Code generated by ruby_h_to_go. DO NOT EDIT.

package ruby

/*
#include "ruby.h"
*/
import "C"

import (
	"unsafe"
)

// RbInternalThreadEventCallback is a type for passing `C.rb_internal_thread_event_callback` in and out of package
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/thread.h
type RbInternalThreadEventCallback C.rb_internal_thread_event_callback

// RbInternalThreadEventDataT is a type for passing `C.rb_internal_thread_event_data_t` in and out of package
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/thread.h
type RbInternalThreadEventDataT C.rb_internal_thread_event_data_t

// RbInternalThreadEventHookT is a type for passing `C.rb_internal_thread_event_hook_t` in and out of package
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/thread.h
type RbInternalThreadEventHookT C.rb_internal_thread_event_hook_t

// RbInternalThreadSpecificKeyT is a type for passing `C.rb_internal_thread_specific_key_t` in and out of package
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/thread.h
type RbInternalThreadSpecificKeyT C.rb_internal_thread_specific_key_t

// RbInternalThreadEventData is a type for passing `C.rb_internal_thread_event_data` in and out of package
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/thread.h
type RbInternalThreadEventData C.rb_internal_thread_event_data

// RbInternalThreadAddEventHook calls `rb_internal_thread_add_event_hook` in C
//
// Original definition is following
//
//	rb_internal_thread_event_hook_t *rb_internal_thread_add_event_hook(
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/thread.h
func RbInternalThreadAddEventHook(fun RbInternalThreadEventCallback, events RbEventFlagT, data unsafe.Pointer) *RbInternalThreadEventHookT {
	ret := *RbInternalThreadEventHookT(C.rb_internal_thread_add_event_hook(C.rb_internal_thread_event_callback(fun), C.rb_event_flag_t(events), toCPointer(data)))
	return ret
}

// RbInternalThreadRemoveEventHook calls `rb_internal_thread_remove_event_hook` in C
//
// Original definition is following
//
//	bool rb_internal_thread_remove_event_hook(
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/thread.h
func RbInternalThreadRemoveEventHook(hook *RbInternalThreadEventHookT) Bool {
	var cHook C.rb_internal_thread_event_hook_t
	ret := Bool(C.rb_internal_thread_remove_event_hook(&cHook))
	*hook = RbInternalThreadEventHookT(cHook)
	return ret
}

// RbInternalThreadSpecificGet calls `rb_internal_thread_specific_get` in C
//
// Original definition is following
//
//	void *rb_internal_thread_specific_get(VALUE thread_val, rb_internal_thread_specific_key_t key)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/thread.h
func RbInternalThreadSpecificGet(thread_val VALUE, key RbInternalThreadSpecificKeyT) unsafe.Pointer {
	ret := unsafe.Pointer(C.rb_internal_thread_specific_get(C.VALUE(thread_val), C.rb_internal_thread_specific_key_t(key)))
	return ret
}

// RbInternalThreadSpecificKeyCreate calls `rb_internal_thread_specific_key_create` in C
//
// Original definition is following
//
//	rb_internal_thread_specific_key_t rb_internal_thread_specific_key_create(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/thread.h
func RbInternalThreadSpecificKeyCreate() RbInternalThreadSpecificKeyT {
	ret := RbInternalThreadSpecificKeyT(C.rb_internal_thread_specific_key_create())
	return ret
}

// RbInternalThreadSpecificSet calls `rb_internal_thread_specific_set` in C
//
// Original definition is following
//
//	void rb_internal_thread_specific_set(VALUE thread_val, rb_internal_thread_specific_key_t key, void *data)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/thread.h
func RbInternalThreadSpecificSet(thread_val VALUE, key RbInternalThreadSpecificKeyT, data unsafe.Pointer) {
	C.rb_internal_thread_specific_set(C.VALUE(thread_val), C.rb_internal_thread_specific_key_t(key), toCPointer(data))
}

// RbNogvl calls `rb_nogvl` in C
//
// Original definition is following
//
//	void *rb_nogvl(void *(*func)(void *), void *data1,
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/thread.h
func RbNogvl(arg1 unsafe.Pointer, data1 unsafe.Pointer, ubf *RbUnblockFunctionT, data2 unsafe.Pointer, flags int) unsafe.Pointer {
	var cUbf C.rb_unblock_function_t
	ret := unsafe.Pointer(C.rb_nogvl(toCPointer(arg1), toCPointer(data1), &cUbf, toCPointer(data2), C.int(flags)))
	*ubf = RbUnblockFunctionT(cUbf)
	return ret
}

// RbThreadCallWithGvl calls `rb_thread_call_with_gvl` in C
//
// Original definition is following
//
//	void *rb_thread_call_with_gvl(void *(*func)(void *), void *data1)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/thread.h
func RbThreadCallWithGvl(arg1 unsafe.Pointer, data1 unsafe.Pointer) unsafe.Pointer {
	ret := unsafe.Pointer(C.rb_thread_call_with_gvl(toCPointer(arg1), toCPointer(data1)))
	return ret
}

// RbThreadCallWithoutGvl calls `rb_thread_call_without_gvl` in C
//
// Original definition is following
//
//	void *rb_thread_call_without_gvl(void *(*func)(void *), void *data1,
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/thread.h
func RbThreadCallWithoutGvl(arg1 unsafe.Pointer, data1 unsafe.Pointer, ubf *RbUnblockFunctionT, data2 unsafe.Pointer) unsafe.Pointer {
	var cUbf C.rb_unblock_function_t
	ret := unsafe.Pointer(C.rb_thread_call_without_gvl(toCPointer(arg1), toCPointer(data1), &cUbf, toCPointer(data2)))
	*ubf = RbUnblockFunctionT(cUbf)
	return ret
}

// RbThreadCallWithoutGvl2 calls `rb_thread_call_without_gvl2` in C
//
// Original definition is following
//
//	void *rb_thread_call_without_gvl2(void *(*func)(void *), void *data1,
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/thread.h
func RbThreadCallWithoutGvl2(arg1 unsafe.Pointer, data1 unsafe.Pointer, ubf *RbUnblockFunctionT, data2 unsafe.Pointer) unsafe.Pointer {
	var cUbf C.rb_unblock_function_t
	ret := unsafe.Pointer(C.rb_thread_call_without_gvl2(toCPointer(arg1), toCPointer(data1), &cUbf, toCPointer(data2)))
	*ubf = RbUnblockFunctionT(cUbf)
	return ret
}
