// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated
// Code generated by ruby_h_to_go. DO NOT EDIT.

package ruby

/*
#include "ruby.h"
*/
import "C"

import (
	"unsafe"
)

// RbFreeTmpBuffer calls `rb_free_tmp_buffer` in C
//
// Original definition is following
//
//	void rb_free_tmp_buffer(volatile VALUE *store)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/memory.h
func RbFreeTmpBuffer(store *VALUE) {
	var cStore C.VALUE
	C.rb_free_tmp_buffer(&cStore)
	*store = VALUE(cStore)
}

// RbAllocTmpBuffer2 calls `rb_alloc_tmp_buffer2` in C
//
// Original definition is following
//
//	rb_alloc_tmp_buffer2(volatile VALUE *store, long count, size_t elsize)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/memory.h
func RbAllocTmpBuffer2(store *VALUE, count Long, elsize SizeT) unsafe.Pointer {
	var cStore C.VALUE
	ret := unsafe.Pointer(C.rb_alloc_tmp_buffer2(&cStore, C.long(count), C.size_t(elsize)))
	*store = VALUE(cStore)
	return ret
}

// RbMulSizeOverflow calls `rb_mul_size_overflow` in C
//
// Original definition is following
//
//	rb_mul_size_overflow(size_t a, size_t b, size_t max, size_t *c)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/memory.h
func RbMulSizeOverflow(a SizeT, b SizeT, max SizeT, c *SizeT) int {
	var cC C.size_t
	ret := int(C.rb_mul_size_overflow(C.size_t(a), C.size_t(b), C.size_t(max), &cC))
	*c = SizeT(cC)
	return ret
}
