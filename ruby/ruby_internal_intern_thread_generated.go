// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated
// Code generated by ruby_h_to_go. DO NOT EDIT.

package ruby

/*
#include "ruby.h"
*/
import "C"

import (
	"unsafe"
)

// RbBlockingFunctionT is a type for passing `C.rb_blocking_function_t` in and out of package
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
type RbBlockingFunctionT C.rb_blocking_function_t

// RbUnblockFunctionT is a type for passing `C.rb_unblock_function_t` in and out of package
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
type RbUnblockFunctionT C.rb_unblock_function_t

// RbExecRecursive calls `rb_exec_recursive` in C
//
// Original definition is following
//
//	VALUE rb_exec_recursive(VALUE (*f)(VALUE g, VALUE h, int r), VALUE g, VALUE h)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbExecRecursive(arg1 unsafe.Pointer, g VALUE, h VALUE) VALUE {
	ret := VALUE(C.rb_exec_recursive(toCPointer(arg1), C.VALUE(g), C.VALUE(h)))
	return ret
}

// RbExecRecursiveOuter calls `rb_exec_recursive_outer` in C
//
// Original definition is following
//
//	VALUE rb_exec_recursive_outer(VALUE (*f)(VALUE g, VALUE h, int r), VALUE g, VALUE h)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbExecRecursiveOuter(arg1 unsafe.Pointer, g VALUE, h VALUE) VALUE {
	ret := VALUE(C.rb_exec_recursive_outer(toCPointer(arg1), C.VALUE(g), C.VALUE(h)))
	return ret
}

// RbExecRecursivePaired calls `rb_exec_recursive_paired` in C
//
// Original definition is following
//
//	VALUE rb_exec_recursive_paired(VALUE (*f)(VALUE g, VALUE h, int r), VALUE g, VALUE p, VALUE h)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbExecRecursivePaired(arg1 unsafe.Pointer, g VALUE, p VALUE, h VALUE) VALUE {
	ret := VALUE(C.rb_exec_recursive_paired(toCPointer(arg1), C.VALUE(g), C.VALUE(p), C.VALUE(h)))
	return ret
}

// RbExecRecursivePairedOuter calls `rb_exec_recursive_paired_outer` in C
//
// Original definition is following
//
//	VALUE rb_exec_recursive_paired_outer(VALUE (*f)(VALUE g, VALUE h, int r), VALUE g, VALUE p, VALUE h)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbExecRecursivePairedOuter(arg1 unsafe.Pointer, g VALUE, p VALUE, h VALUE) VALUE {
	ret := VALUE(C.rb_exec_recursive_paired_outer(toCPointer(arg1), C.VALUE(g), C.VALUE(p), C.VALUE(h)))
	return ret
}

// RbMutexLock calls `rb_mutex_lock` in C
//
// Original definition is following
//
//	VALUE rb_mutex_lock(VALUE mutex)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbMutexLock(mutex VALUE) VALUE {
	ret := VALUE(C.rb_mutex_lock(C.VALUE(mutex)))
	return ret
}

// RbMutexLockedP calls `rb_mutex_locked_p` in C
//
// Original definition is following
//
//	VALUE rb_mutex_locked_p(VALUE mutex)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbMutexLockedP(mutex VALUE) VALUE {
	ret := VALUE(C.rb_mutex_locked_p(C.VALUE(mutex)))
	return ret
}

// RbMutexNew calls `rb_mutex_new` in C
//
// Original definition is following
//
//	VALUE rb_mutex_new(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbMutexNew() VALUE {
	ret := VALUE(C.rb_mutex_new())
	return ret
}

// RbMutexSleep calls `rb_mutex_sleep` in C
//
// Original definition is following
//
//	VALUE rb_mutex_sleep(VALUE self, VALUE timeout)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbMutexSleep(self VALUE, timeout VALUE) VALUE {
	ret := VALUE(C.rb_mutex_sleep(C.VALUE(self), C.VALUE(timeout)))
	return ret
}

// RbMutexSynchronize calls `rb_mutex_synchronize` in C
//
// Original definition is following
//
//	VALUE rb_mutex_synchronize(VALUE mutex, VALUE (*func)(VALUE arg), VALUE arg)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbMutexSynchronize(mutex VALUE, arg2 unsafe.Pointer, arg VALUE) VALUE {
	ret := VALUE(C.rb_mutex_synchronize(C.VALUE(mutex), toCPointer(arg2), C.VALUE(arg)))
	return ret
}

// RbMutexTrylock calls `rb_mutex_trylock` in C
//
// Original definition is following
//
//	VALUE rb_mutex_trylock(VALUE mutex)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbMutexTrylock(mutex VALUE) VALUE {
	ret := VALUE(C.rb_mutex_trylock(C.VALUE(mutex)))
	return ret
}

// RbMutexUnlock calls `rb_mutex_unlock` in C
//
// Original definition is following
//
//	VALUE rb_mutex_unlock(VALUE mutex)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbMutexUnlock(mutex VALUE) VALUE {
	ret := VALUE(C.rb_mutex_unlock(C.VALUE(mutex)))
	return ret
}

// RbThreadAlone calls `rb_thread_alone` in C
//
// Original definition is following
//
//	int rb_thread_alone(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadAlone() int {
	ret := int(C.rb_thread_alone())
	return ret
}

// RbThreadAtfork calls `rb_thread_atfork` in C
//
// Original definition is following
//
//	void rb_thread_atfork(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadAtfork() {
	C.rb_thread_atfork()
}

// RbThreadAtforkBeforeExec calls `rb_thread_atfork_before_exec` in C
//
// Original definition is following
//
//	void rb_thread_atfork_before_exec(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadAtforkBeforeExec() {
	C.rb_thread_atfork_before_exec()
}

// RbThreadCheckInts calls `rb_thread_check_ints` in C
//
// Original definition is following
//
//	void rb_thread_check_ints(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadCheckInts() {
	C.rb_thread_check_ints()
}

// RbThreadCreate calls `rb_thread_create` in C
//
// Original definition is following
//
//	VALUE rb_thread_create(VALUE (*f)(void *g), void *g)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadCreate(arg1 unsafe.Pointer, g unsafe.Pointer) VALUE {
	ret := VALUE(C.rb_thread_create(toCPointer(arg1), toCPointer(g)))
	return ret
}

// RbThreadCurrent calls `rb_thread_current` in C
//
// Original definition is following
//
//	VALUE rb_thread_current(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadCurrent() VALUE {
	ret := VALUE(C.rb_thread_current())
	return ret
}

// RbThreadFdClose calls `rb_thread_fd_close` in C
//
// Original definition is following
//
//	void rb_thread_fd_close(int fd)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadFdClose(fd int) {
	C.rb_thread_fd_close(C.int(fd))
}

// RbThreadFdWritable calls `rb_thread_fd_writable` in C
//
// Original definition is following
//
//	int rb_thread_fd_writable(int fd)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadFdWritable(fd int) int {
	ret := int(C.rb_thread_fd_writable(C.int(fd)))
	return ret
}

// RbThreadInterrupted calls `rb_thread_interrupted` in C
//
// Original definition is following
//
//	int rb_thread_interrupted(VALUE thval)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadInterrupted(thval VALUE) int {
	ret := int(C.rb_thread_interrupted(C.VALUE(thval)))
	return ret
}

// RbThreadKill calls `rb_thread_kill` in C
//
// Original definition is following
//
//	VALUE rb_thread_kill(VALUE thread)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadKill(thread VALUE) VALUE {
	ret := VALUE(C.rb_thread_kill(C.VALUE(thread)))
	return ret
}

// RbThreadLocalAref calls `rb_thread_local_aref` in C
//
// Original definition is following
//
//	VALUE rb_thread_local_aref(VALUE thread, ID key)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadLocalAref(thread VALUE, key ID) VALUE {
	ret := VALUE(C.rb_thread_local_aref(C.VALUE(thread), C.ID(key)))
	return ret
}

// RbThreadLocalAset calls `rb_thread_local_aset` in C
//
// Original definition is following
//
//	VALUE rb_thread_local_aset(VALUE thread, ID key, VALUE val)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadLocalAset(thread VALUE, key ID, val VALUE) VALUE {
	ret := VALUE(C.rb_thread_local_aset(C.VALUE(thread), C.ID(key), C.VALUE(val)))
	return ret
}

// RbThreadMain calls `rb_thread_main` in C
//
// Original definition is following
//
//	VALUE rb_thread_main(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadMain() VALUE {
	ret := VALUE(C.rb_thread_main())
	return ret
}

// RbThreadRun calls `rb_thread_run` in C
//
// Original definition is following
//
//	VALUE rb_thread_run(VALUE thread)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadRun(thread VALUE) VALUE {
	ret := VALUE(C.rb_thread_run(C.VALUE(thread)))
	return ret
}

// RbThreadSchedule calls `rb_thread_schedule` in C
//
// Original definition is following
//
//	void rb_thread_schedule(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadSchedule() {
	C.rb_thread_schedule()
}

// RbThreadSleep calls `rb_thread_sleep` in C
//
// Original definition is following
//
//	void rb_thread_sleep(int sec)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadSleep(sec int) {
	C.rb_thread_sleep(C.int(sec))
}

// RbThreadSleepDeadly calls `rb_thread_sleep_deadly` in C
//
// Original definition is following
//
//	void rb_thread_sleep_deadly(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadSleepDeadly() {
	C.rb_thread_sleep_deadly()
}

// RbThreadSleepForever calls `rb_thread_sleep_forever` in C
//
// Original definition is following
//
//	void rb_thread_sleep_forever(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadSleepForever() {
	C.rb_thread_sleep_forever()
}

// RbThreadStop calls `rb_thread_stop` in C
//
// Original definition is following
//
//	VALUE rb_thread_stop(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadStop() VALUE {
	ret := VALUE(C.rb_thread_stop())
	return ret
}

// RbThreadWaitFd calls `rb_thread_wait_fd` in C
//
// Original definition is following
//
//	int rb_thread_wait_fd(int fd)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadWaitFd(fd int) int {
	ret := int(C.rb_thread_wait_fd(C.int(fd)))
	return ret
}

// RbThreadWakeup calls `rb_thread_wakeup` in C
//
// Original definition is following
//
//	VALUE rb_thread_wakeup(VALUE thread)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadWakeup(thread VALUE) VALUE {
	ret := VALUE(C.rb_thread_wakeup(C.VALUE(thread)))
	return ret
}

// RbThreadWakeupAlive calls `rb_thread_wakeup_alive` in C
//
// Original definition is following
//
//	VALUE rb_thread_wakeup_alive(VALUE thread)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/thread.h
func RbThreadWakeupAlive(thread VALUE) VALUE {
	ret := VALUE(C.rb_thread_wakeup_alive(C.VALUE(thread)))
	return ret
}
