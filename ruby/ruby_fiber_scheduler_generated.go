// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated
// Code generated by ruby_h_to_go. DO NOT EDIT.

package ruby

/*
#include "ruby.h"
*/
import "C"

import (
	"unsafe"
)

// RbFiberSchedulerAddressResolve calls `rb_fiber_scheduler_address_resolve` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_address_resolve(VALUE scheduler, VALUE hostname)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerAddressResolve(scheduler VALUE, hostname VALUE) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_address_resolve(C.VALUE(scheduler), C.VALUE(hostname)))
	return ret
}

// RbFiberSchedulerBlock calls `rb_fiber_scheduler_block` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_block(VALUE scheduler, VALUE blocker, VALUE timeout)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerBlock(scheduler VALUE, blocker VALUE, timeout VALUE) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_block(C.VALUE(scheduler), C.VALUE(blocker), C.VALUE(timeout)))
	return ret
}

// RbFiberSchedulerClose calls `rb_fiber_scheduler_close` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_close(VALUE scheduler)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerClose(scheduler VALUE) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_close(C.VALUE(scheduler)))
	return ret
}

// RbFiberSchedulerCurrent calls `rb_fiber_scheduler_current` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_current(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerCurrent() VALUE {
	ret := VALUE(C.rb_fiber_scheduler_current())
	return ret
}

// RbFiberSchedulerCurrentForThread calls `rb_fiber_scheduler_current_for_thread` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_current_for_thread(VALUE thread)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerCurrentForThread(thread VALUE) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_current_for_thread(C.VALUE(thread)))
	return ret
}

// RbFiberSchedulerFiber calls `rb_fiber_scheduler_fiber` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_fiber(VALUE scheduler, int argc, VALUE *argv, int kw_splat)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerFiber(scheduler VALUE, argc int, argv *VALUE, kw_splat int) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_fiber_scheduler_fiber(C.VALUE(scheduler), C.int(argc), &cArgv, C.int(kw_splat)))
	*argv = VALUE(cArgv)
	return ret
}

// RbFiberSchedulerGet calls `rb_fiber_scheduler_get` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_get(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerGet() VALUE {
	ret := VALUE(C.rb_fiber_scheduler_get())
	return ret
}

// RbFiberSchedulerIoClose calls `rb_fiber_scheduler_io_close` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_io_close(VALUE scheduler, VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerIoClose(scheduler VALUE, io VALUE) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_io_close(C.VALUE(scheduler), C.VALUE(io)))
	return ret
}

// RbFiberSchedulerIoPread calls `rb_fiber_scheduler_io_pread` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_io_pread(VALUE scheduler, VALUE io, rb_off_t from, VALUE buffer, size_t length, size_t offset)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerIoPread(scheduler VALUE, io VALUE, from RbOffT, buffer VALUE, length SizeT, offset SizeT) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_io_pread(C.VALUE(scheduler), C.VALUE(io), C.rb_off_t(from), C.VALUE(buffer), C.size_t(length), C.size_t(offset)))
	return ret
}

// RbFiberSchedulerIoPreadMemory calls `rb_fiber_scheduler_io_pread_memory` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_io_pread_memory(VALUE scheduler, VALUE io, rb_off_t from, void *base, size_t size, size_t length)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerIoPreadMemory(scheduler VALUE, io VALUE, from RbOffT, base unsafe.Pointer, size SizeT, length SizeT) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_io_pread_memory(C.VALUE(scheduler), C.VALUE(io), C.rb_off_t(from), toCPointer(base), C.size_t(size), C.size_t(length)))
	return ret
}

// RbFiberSchedulerIoPwrite calls `rb_fiber_scheduler_io_pwrite` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_io_pwrite(VALUE scheduler, VALUE io, rb_off_t from, VALUE buffer, size_t length, size_t offset)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerIoPwrite(scheduler VALUE, io VALUE, from RbOffT, buffer VALUE, length SizeT, offset SizeT) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_io_pwrite(C.VALUE(scheduler), C.VALUE(io), C.rb_off_t(from), C.VALUE(buffer), C.size_t(length), C.size_t(offset)))
	return ret
}

// RbFiberSchedulerIoPwriteMemory calls `rb_fiber_scheduler_io_pwrite_memory` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_io_pwrite_memory(VALUE scheduler, VALUE io, rb_off_t from, const void *base, size_t size, size_t length)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerIoPwriteMemory(scheduler VALUE, io VALUE, from RbOffT, base unsafe.Pointer, size SizeT, length SizeT) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_io_pwrite_memory(C.VALUE(scheduler), C.VALUE(io), C.rb_off_t(from), toCPointer(base), C.size_t(size), C.size_t(length)))
	return ret
}

// RbFiberSchedulerIoRead calls `rb_fiber_scheduler_io_read` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_io_read(VALUE scheduler, VALUE io, VALUE buffer, size_t length, size_t offset)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerIoRead(scheduler VALUE, io VALUE, buffer VALUE, length SizeT, offset SizeT) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_io_read(C.VALUE(scheduler), C.VALUE(io), C.VALUE(buffer), C.size_t(length), C.size_t(offset)))
	return ret
}

// RbFiberSchedulerIoReadMemory calls `rb_fiber_scheduler_io_read_memory` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_io_read_memory(VALUE scheduler, VALUE io, void *base, size_t size, size_t length)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerIoReadMemory(scheduler VALUE, io VALUE, base unsafe.Pointer, size SizeT, length SizeT) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_io_read_memory(C.VALUE(scheduler), C.VALUE(io), toCPointer(base), C.size_t(size), C.size_t(length)))
	return ret
}

// RbFiberSchedulerIoSelect calls `rb_fiber_scheduler_io_select` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_io_select(VALUE scheduler, VALUE readables, VALUE writables, VALUE exceptables, VALUE timeout)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerIoSelect(scheduler VALUE, readables VALUE, writables VALUE, exceptables VALUE, timeout VALUE) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_io_select(C.VALUE(scheduler), C.VALUE(readables), C.VALUE(writables), C.VALUE(exceptables), C.VALUE(timeout)))
	return ret
}

// RbFiberSchedulerIoSelectv calls `rb_fiber_scheduler_io_selectv` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_io_selectv(VALUE scheduler, int argc, VALUE *argv)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerIoSelectv(scheduler VALUE, argc int, argv *VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_fiber_scheduler_io_selectv(C.VALUE(scheduler), C.int(argc), &cArgv))
	*argv = VALUE(cArgv)
	return ret
}

// RbFiberSchedulerIoWait calls `rb_fiber_scheduler_io_wait` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_io_wait(VALUE scheduler, VALUE io, VALUE events, VALUE timeout)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerIoWait(scheduler VALUE, io VALUE, events VALUE, timeout VALUE) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_io_wait(C.VALUE(scheduler), C.VALUE(io), C.VALUE(events), C.VALUE(timeout)))
	return ret
}

// RbFiberSchedulerIoWaitReadable calls `rb_fiber_scheduler_io_wait_readable` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_io_wait_readable(VALUE scheduler, VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerIoWaitReadable(scheduler VALUE, io VALUE) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_io_wait_readable(C.VALUE(scheduler), C.VALUE(io)))
	return ret
}

// RbFiberSchedulerIoWaitWritable calls `rb_fiber_scheduler_io_wait_writable` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_io_wait_writable(VALUE scheduler, VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerIoWaitWritable(scheduler VALUE, io VALUE) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_io_wait_writable(C.VALUE(scheduler), C.VALUE(io)))
	return ret
}

// RbFiberSchedulerIoWrite calls `rb_fiber_scheduler_io_write` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_io_write(VALUE scheduler, VALUE io, VALUE buffer, size_t length, size_t offset)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerIoWrite(scheduler VALUE, io VALUE, buffer VALUE, length SizeT, offset SizeT) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_io_write(C.VALUE(scheduler), C.VALUE(io), C.VALUE(buffer), C.size_t(length), C.size_t(offset)))
	return ret
}

// RbFiberSchedulerIoWriteMemory calls `rb_fiber_scheduler_io_write_memory` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_io_write_memory(VALUE scheduler, VALUE io, const void *base, size_t size, size_t length)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerIoWriteMemory(scheduler VALUE, io VALUE, base unsafe.Pointer, size SizeT, length SizeT) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_io_write_memory(C.VALUE(scheduler), C.VALUE(io), toCPointer(base), C.size_t(size), C.size_t(length)))
	return ret
}

// RbFiberSchedulerKernelSleep calls `rb_fiber_scheduler_kernel_sleep` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_kernel_sleep(VALUE scheduler, VALUE duration)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerKernelSleep(scheduler VALUE, duration VALUE) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_kernel_sleep(C.VALUE(scheduler), C.VALUE(duration)))
	return ret
}

// RbFiberSchedulerKernelSleepv calls `rb_fiber_scheduler_kernel_sleepv` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_kernel_sleepv(VALUE scheduler, int argc, VALUE * argv)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerKernelSleepv(scheduler VALUE, argc int, argv *VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_fiber_scheduler_kernel_sleepv(C.VALUE(scheduler), C.int(argc), &cArgv))
	*argv = VALUE(cArgv)
	return ret
}

// RbFiberSchedulerMakeTimeout calls `rb_fiber_scheduler_make_timeout` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_make_timeout(struct timeval *timeout)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerMakeTimeout(timeout *Timeval) VALUE {
	var cTimeout C.timeval
	ret := VALUE(C.rb_fiber_scheduler_make_timeout(&cTimeout))
	*timeout = Timeval(cTimeout)
	return ret
}

// RbFiberSchedulerProcessWait calls `rb_fiber_scheduler_process_wait` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_process_wait(VALUE scheduler, rb_pid_t pid, int flags)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerProcessWait(scheduler VALUE, pid RbPidT, flags int) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_process_wait(C.VALUE(scheduler), C.rb_pid_t(pid), C.int(flags)))
	return ret
}

// RbFiberSchedulerSet calls `rb_fiber_scheduler_set` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_set(VALUE scheduler)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerSet(scheduler VALUE) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_set(C.VALUE(scheduler)))
	return ret
}

// RbFiberSchedulerUnblock calls `rb_fiber_scheduler_unblock` in C
//
// Original definition is following
//
//	VALUE rb_fiber_scheduler_unblock(VALUE scheduler, VALUE blocker, VALUE fiber)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerUnblock(scheduler VALUE, blocker VALUE, fiber VALUE) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_unblock(C.VALUE(scheduler), C.VALUE(blocker), C.VALUE(fiber)))
	return ret
}

// RbFiberSchedulerIoResult calls `rb_fiber_scheduler_io_result` in C
//
// Original definition is following
//
//	rb_fiber_scheduler_io_result(ssize_t result, int error)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerIoResult(result SsizeT, error int) VALUE {
	ret := VALUE(C.rb_fiber_scheduler_io_result(C.ssize_t(result), C.int(error)))
	return ret
}

// RbFiberSchedulerIoResultApply calls `rb_fiber_scheduler_io_result_apply` in C
//
// Original definition is following
//
//	rb_fiber_scheduler_io_result_apply(VALUE result)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/fiber/scheduler.h
func RbFiberSchedulerIoResultApply(result VALUE) SsizeT {
	ret := SsizeT(C.rb_fiber_scheduler_io_result_apply(C.VALUE(result)))
	return ret
}
