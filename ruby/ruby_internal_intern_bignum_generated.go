// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated
// Code generated by ruby_h_to_go. DO NOT EDIT.

package ruby

/*
#include "ruby.h"
*/
import "C"

import (
	"unsafe"
)

// RbAbsintNumwords calls `rb_absint_numwords` in C
//
// Original definition is following
//
//	size_t rb_absint_numwords(VALUE val, size_t word_numbits, size_t *nlz_bits_ret)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbAbsintNumwords(val VALUE, word_numbits SizeT, nlz_bits_ret *SizeT) SizeT {
	var cNlzBitsRet C.size_t
	ret := SizeT(C.rb_absint_numwords(C.VALUE(val), C.size_t(word_numbits), &cNlzBitsRet))
	*nlz_bits_ret = SizeT(cNlzBitsRet)
	return ret
}

// RbAbsintSinglebitP calls `rb_absint_singlebit_p` in C
//
// Original definition is following
//
//	int rb_absint_singlebit_p(VALUE val)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbAbsintSinglebitP(val VALUE) int {
	ret := int(C.rb_absint_singlebit_p(C.VALUE(val)))
	return ret
}

// RbAbsintSize calls `rb_absint_size` in C
//
// Original definition is following
//
//	size_t rb_absint_size(VALUE val, int *nlz_bits_ret)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbAbsintSize(val VALUE, nlz_bits_ret *int) SizeT {
	var cNlzBitsRet C.int
	ret := SizeT(C.rb_absint_size(C.VALUE(val), &cNlzBitsRet))
	*nlz_bits_ret = int(cNlzBitsRet)
	return ret
}

// RbBig2Dbl calls `rb_big2dbl` in C
//
// Original definition is following
//
//	double rb_big2dbl(VALUE x)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBig2Dbl(x VALUE) Double {
	ret := Double(C.rb_big2dbl(C.VALUE(x)))
	return ret
}

// RbBig2Ll calls `rb_big2ll` in C
//
// Original definition is following
//
//	LONG_LONG rb_big2ll(VALUE)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBig2Ll(arg1 VALUE) Longlong {
	ret := Longlong(C.rb_big2ll(C.VALUE(arg1)))
	return ret
}

// RbBig2Long calls `rb_big2long` in C
//
// Original definition is following
//
//	long rb_big2long(VALUE x)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBig2Long(x VALUE) Long {
	ret := Long(C.rb_big2long(C.VALUE(x)))
	return ret
}

// RbBig2Str calls `rb_big2str` in C
//
// Original definition is following
//
//	VALUE rb_big2str(VALUE x, int base)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBig2Str(x VALUE, base int) VALUE {
	ret := VALUE(C.rb_big2str(C.VALUE(x), C.int(base)))
	return ret
}

// RbBig2Ull calls `rb_big2ull` in C
//
// Original definition is following
//
//	unsigned LONG_LONG rb_big2ull(VALUE)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBig2Ull(arg1 VALUE) Ulonglong {
	ret := Ulonglong(C.rb_big2ull(C.VALUE(arg1)))
	return ret
}

// RbBig2Ulong calls `rb_big2ulong` in C
//
// Original definition is following
//
//	unsigned long rb_big2ulong(VALUE x)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBig2Ulong(x VALUE) uint {
	ret := uint(C.rb_big2ulong(C.VALUE(x)))
	return ret
}

// RbBig2Comp calls `rb_big_2comp` in C
//
// Original definition is following
//
//	void rb_big_2comp(VALUE num)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBig2Comp(num VALUE) {
	C.rb_big_2comp(C.VALUE(num))
}

// RbBigAnd calls `rb_big_and` in C
//
// Original definition is following
//
//	VALUE rb_big_and(VALUE x, VALUE y)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigAnd(x VALUE, y VALUE) VALUE {
	ret := VALUE(C.rb_big_and(C.VALUE(x), C.VALUE(y)))
	return ret
}

// RbBigClone calls `rb_big_clone` in C
//
// Original definition is following
//
//	VALUE rb_big_clone(VALUE num)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigClone(num VALUE) VALUE {
	ret := VALUE(C.rb_big_clone(C.VALUE(num)))
	return ret
}

// RbBigCmp calls `rb_big_cmp` in C
//
// Original definition is following
//
//	VALUE rb_big_cmp(VALUE lhs, VALUE rhs)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigCmp(lhs VALUE, rhs VALUE) VALUE {
	ret := VALUE(C.rb_big_cmp(C.VALUE(lhs), C.VALUE(rhs)))
	return ret
}

// RbBigDiv calls `rb_big_div` in C
//
// Original definition is following
//
//	VALUE rb_big_div(VALUE x, VALUE y)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigDiv(x VALUE, y VALUE) VALUE {
	ret := VALUE(C.rb_big_div(C.VALUE(x), C.VALUE(y)))
	return ret
}

// RbBigDivmod calls `rb_big_divmod` in C
//
// Original definition is following
//
//	VALUE rb_big_divmod(VALUE x, VALUE y)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigDivmod(x VALUE, y VALUE) VALUE {
	ret := VALUE(C.rb_big_divmod(C.VALUE(x), C.VALUE(y)))
	return ret
}

// RbBigEq calls `rb_big_eq` in C
//
// Original definition is following
//
//	VALUE rb_big_eq(VALUE lhs, VALUE rhs)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigEq(lhs VALUE, rhs VALUE) VALUE {
	ret := VALUE(C.rb_big_eq(C.VALUE(lhs), C.VALUE(rhs)))
	return ret
}

// RbBigEql calls `rb_big_eql` in C
//
// Original definition is following
//
//	VALUE rb_big_eql(VALUE lhs, VALUE rhs)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigEql(lhs VALUE, rhs VALUE) VALUE {
	ret := VALUE(C.rb_big_eql(C.VALUE(lhs), C.VALUE(rhs)))
	return ret
}

// RbBigIdiv calls `rb_big_idiv` in C
//
// Original definition is following
//
//	VALUE rb_big_idiv(VALUE x, VALUE y)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigIdiv(x VALUE, y VALUE) VALUE {
	ret := VALUE(C.rb_big_idiv(C.VALUE(x), C.VALUE(y)))
	return ret
}

// RbBigLshift calls `rb_big_lshift` in C
//
// Original definition is following
//
//	VALUE rb_big_lshift(VALUE x, VALUE y)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigLshift(x VALUE, y VALUE) VALUE {
	ret := VALUE(C.rb_big_lshift(C.VALUE(x), C.VALUE(y)))
	return ret
}

// RbBigMinus calls `rb_big_minus` in C
//
// Original definition is following
//
//	VALUE rb_big_minus(VALUE x, VALUE y)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigMinus(x VALUE, y VALUE) VALUE {
	ret := VALUE(C.rb_big_minus(C.VALUE(x), C.VALUE(y)))
	return ret
}

// RbBigModulo calls `rb_big_modulo` in C
//
// Original definition is following
//
//	VALUE rb_big_modulo(VALUE x, VALUE y)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigModulo(x VALUE, y VALUE) VALUE {
	ret := VALUE(C.rb_big_modulo(C.VALUE(x), C.VALUE(y)))
	return ret
}

// RbBigMul calls `rb_big_mul` in C
//
// Original definition is following
//
//	VALUE rb_big_mul(VALUE x, VALUE y)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigMul(x VALUE, y VALUE) VALUE {
	ret := VALUE(C.rb_big_mul(C.VALUE(x), C.VALUE(y)))
	return ret
}

// RbBigNorm calls `rb_big_norm` in C
//
// Original definition is following
//
//	VALUE rb_big_norm(VALUE x)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigNorm(x VALUE) VALUE {
	ret := VALUE(C.rb_big_norm(C.VALUE(x)))
	return ret
}

// RbBigOr calls `rb_big_or` in C
//
// Original definition is following
//
//	VALUE rb_big_or(VALUE x, VALUE y)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigOr(x VALUE, y VALUE) VALUE {
	ret := VALUE(C.rb_big_or(C.VALUE(x), C.VALUE(y)))
	return ret
}

// RbBigPack calls `rb_big_pack` in C
//
// Original definition is following
//
//	void rb_big_pack(VALUE val, unsigned long *buf, long num_longs)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigPack(val VALUE, buf *uint, num_longs Long) {
	var cBuf C.ulong
	C.rb_big_pack(C.VALUE(val), &cBuf, C.long(num_longs))
	*buf = uint(cBuf)
}

// RbBigPlus calls `rb_big_plus` in C
//
// Original definition is following
//
//	VALUE rb_big_plus(VALUE x, VALUE y)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigPlus(x VALUE, y VALUE) VALUE {
	ret := VALUE(C.rb_big_plus(C.VALUE(x), C.VALUE(y)))
	return ret
}

// RbBigPow calls `rb_big_pow` in C
//
// Original definition is following
//
//	VALUE rb_big_pow(VALUE x, VALUE y)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigPow(x VALUE, y VALUE) VALUE {
	ret := VALUE(C.rb_big_pow(C.VALUE(x), C.VALUE(y)))
	return ret
}

// RbBigResize calls `rb_big_resize` in C
//
// Original definition is following
//
//	void rb_big_resize(VALUE big, size_t len)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigResize(big VALUE, len SizeT) {
	C.rb_big_resize(C.VALUE(big), C.size_t(len))
}

// RbBigRshift calls `rb_big_rshift` in C
//
// Original definition is following
//
//	VALUE rb_big_rshift(VALUE x, VALUE y)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigRshift(x VALUE, y VALUE) VALUE {
	ret := VALUE(C.rb_big_rshift(C.VALUE(x), C.VALUE(y)))
	return ret
}

// RbBigUnpack calls `rb_big_unpack` in C
//
// Original definition is following
//
//	VALUE rb_big_unpack(unsigned long *buf, long num_longs)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigUnpack(buf *uint, num_longs Long) VALUE {
	var cBuf C.ulong
	ret := VALUE(C.rb_big_unpack(&cBuf, C.long(num_longs)))
	*buf = uint(cBuf)
	return ret
}

// RbBigXor calls `rb_big_xor` in C
//
// Original definition is following
//
//	VALUE rb_big_xor(VALUE x, VALUE y)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigXor(x VALUE, y VALUE) VALUE {
	ret := VALUE(C.rb_big_xor(C.VALUE(x), C.VALUE(y)))
	return ret
}

// RbBigzeroP calls `rb_bigzero_p` in C
//
// Original definition is following
//
//	int rb_bigzero_p(VALUE x)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbBigzeroP(x VALUE) int {
	ret := int(C.rb_bigzero_p(C.VALUE(x)))
	return ret
}

// RbCstr2Inum calls `rb_cstr2inum` in C
//
// Original definition is following
//
//	VALUE rb_cstr2inum(const char *str, int base)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbCstr2Inum(str string, base int) VALUE {
	char, clean := string2Char(str)
	defer clean()

	ret := VALUE(C.rb_cstr2inum(char, C.int(base)))
	return ret
}

// RbCstrToInum calls `rb_cstr_to_inum` in C
//
// Original definition is following
//
//	VALUE rb_cstr_to_inum(const char *str, int base, int badcheck)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbCstrToInum(str string, base int, badcheck int) VALUE {
	char, clean := string2Char(str)
	defer clean()

	ret := VALUE(C.rb_cstr_to_inum(char, C.int(base), C.int(badcheck)))
	return ret
}

// RbDbl2Big calls `rb_dbl2big` in C
//
// Original definition is following
//
//	VALUE rb_dbl2big(double d)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbDbl2Big(d Double) VALUE {
	ret := VALUE(C.rb_dbl2big(C.double(d)))
	return ret
}

// RbIntegerPack calls `rb_integer_pack` in C
//
// Original definition is following
//
//	int rb_integer_pack(VALUE val, void *words, size_t numwords, size_t wordsize, size_t nails, int flags)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbIntegerPack(val VALUE, words unsafe.Pointer, numwords SizeT, wordsize SizeT, nails SizeT, flags int) int {
	ret := int(C.rb_integer_pack(C.VALUE(val), toCPointer(words), C.size_t(numwords), C.size_t(wordsize), C.size_t(nails), C.int(flags)))
	return ret
}

// RbIntegerUnpack calls `rb_integer_unpack` in C
//
// Original definition is following
//
//	VALUE rb_integer_unpack(const void *words, size_t numwords, size_t wordsize, size_t nails, int flags)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbIntegerUnpack(words unsafe.Pointer, numwords SizeT, wordsize SizeT, nails SizeT, flags int) VALUE {
	ret := VALUE(C.rb_integer_unpack(toCPointer(words), C.size_t(numwords), C.size_t(wordsize), C.size_t(nails), C.int(flags)))
	return ret
}

// RbStr2Inum calls `rb_str2inum` in C
//
// Original definition is following
//
//	VALUE rb_str2inum(VALUE str, int base)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbStr2Inum(str VALUE, base int) VALUE {
	ret := VALUE(C.rb_str2inum(C.VALUE(str), C.int(base)))
	return ret
}

// RbStrToInum calls `rb_str_to_inum` in C
//
// Original definition is following
//
//	VALUE rb_str_to_inum(VALUE str, int base, int badcheck)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbStrToInum(str VALUE, base int, badcheck int) VALUE {
	ret := VALUE(C.rb_str_to_inum(C.VALUE(str), C.int(base), C.int(badcheck)))
	return ret
}

// RbUvToUtf8 calls `rb_uv_to_utf8` in C
//
// Original definition is following
//
//	int rb_uv_to_utf8(char buf[6], unsigned long uv)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/bignum.h
func RbUvToUtf8(buf []Char, uv uint) int {
	ret := int(C.rb_uv_to_utf8(toCArray[Char, C.char](buf), C.ulong(uv)))
	return ret
}
