// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated
// Code generated by ruby_h_to_go. DO NOT EDIT.

package ruby

/*
#include "ruby.h"
*/
import "C"

// RbDetachProcess calls `rb_detach_process` in C
//
// Original definition is following
//
//	VALUE rb_detach_process(rb_pid_t pid)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/process.h
func RbDetachProcess(pid RbPidT) VALUE {
	ret := VALUE(C.rb_detach_process(C.rb_pid_t(pid)))
	return ret
}

// RbLastStatusGet calls `rb_last_status_get` in C
//
// Original definition is following
//
//	VALUE rb_last_status_get(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/process.h
func RbLastStatusGet() VALUE {
	ret := VALUE(C.rb_last_status_get())
	return ret
}

// RbLastStatusSet calls `rb_last_status_set` in C
//
// Original definition is following
//
//	void rb_last_status_set(int status, rb_pid_t pid)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/process.h
func RbLastStatusSet(status int, pid RbPidT) {
	C.rb_last_status_set(C.int(status), C.rb_pid_t(pid))
}

// RbProcExec calls `rb_proc_exec` in C
//
// Original definition is following
//
//	int rb_proc_exec(const char *cmd)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/process.h
func RbProcExec(cmd string) int {
	char, clean := string2Char(cmd)
	defer clean()

	ret := int(C.rb_proc_exec(char))
	return ret
}

// RbProcTimes calls `rb_proc_times` in C
//
// Original definition is following
//
//	VALUE rb_proc_times(VALUE _)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/process.h
func RbProcTimes(arg VALUE) VALUE {
	ret := VALUE(C.rb_proc_times(C.VALUE(arg)))
	return ret
}

// RbSpawn calls `rb_spawn` in C
//
// Original definition is following
//
//	rb_pid_t rb_spawn(int argc, const VALUE *argv)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/process.h
func RbSpawn(argc int, argv *VALUE) RbPidT {
	var cArgv C.VALUE
	ret := RbPidT(C.rb_spawn(C.int(argc), &cArgv))
	*argv = VALUE(cArgv)
	return ret
}

// RbSpawnErr calls `rb_spawn_err` in C
//
// Original definition is following
//
//	rb_pid_t rb_spawn_err(int argc, const VALUE *argv, char *errbuf, size_t buflen)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/process.h
func RbSpawnErr(argc int, argv *VALUE, errbuf string, buflen SizeT) RbPidT {
	char, clean := string2Char(errbuf)
	defer clean()

	var cArgv C.VALUE
	ret := RbPidT(C.rb_spawn_err(C.int(argc), &cArgv, char, C.size_t(buflen)))
	*argv = VALUE(cArgv)
	return ret
}

// RbSyswait calls `rb_syswait` in C
//
// Original definition is following
//
//	void rb_syswait(rb_pid_t pid)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/process.h
func RbSyswait(pid RbPidT) {
	C.rb_syswait(C.rb_pid_t(pid))
}

// RbWaitpid calls `rb_waitpid` in C
//
// Original definition is following
//
//	rb_pid_t rb_waitpid(rb_pid_t pid, int *status, int flags)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/process.h
func RbWaitpid(pid RbPidT, status *int, flags int) RbPidT {
	var cStatus C.int
	ret := RbPidT(C.rb_waitpid(C.rb_pid_t(pid), &cStatus, C.int(flags)))
	*status = int(cStatus)
	return ret
}
