// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated
// Code generated by ruby_h_to_go. DO NOT EDIT.

package ruby

/*
#include "ruby.h"
*/
import "C"

import (
	"unsafe"
)

// RbIoBufferT is a type for passing `C.rb_io_buffer_t` in and out of package
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
type RbIoBufferT C.rb_io_buffer_t

// RbIoEncT is a type for passing `C.rb_io_enc_t` in and out of package
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
type RbIoEncT C.rb_io_enc_t

// RbIoEventT is a type for passing `C.rb_io_event_t` in and out of package
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
type RbIoEventT C.rb_io_event_t

// RbIoT is a type for passing `C.rb_io_t` in and out of package
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
type RbIoT C.rb_io_t

// RbIo is a type for passing `C.rb_io` in and out of package
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
type RbIo C.rb_io

// RbIoEncoding is a type for passing `C.rb_io_encoding` in and out of package
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
type RbIoEncoding C.rb_io_encoding

// RbIoInternalBuffer is a type for passing `C.rb_io_internal_buffer` in and out of package
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
type RbIoInternalBuffer C.rb_io_internal_buffer

// RbFdopen calls `rb_fdopen` in C
//
// Original definition is following
//
//	FILE *rb_fdopen(int fd, const char *modestr)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbFdopen(fd int, modestr string) *FILE {
	char, clean := string2Char(modestr)
	defer clean()

	ret := *FILE(C.rb_fdopen(C.int(fd), char))
	return ret
}

// RbIoBufwrite calls `rb_io_bufwrite` in C
//
// Original definition is following
//
//	ssize_t rb_io_bufwrite(VALUE io, const void *buf, size_t size)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoBufwrite(io VALUE, buf unsafe.Pointer, size SizeT) SsizeT {
	ret := SsizeT(C.rb_io_bufwrite(C.VALUE(io), toCPointer(buf), C.size_t(size)))
	return ret
}

// RbIoCheckByteReadable calls `rb_io_check_byte_readable` in C
//
// Original definition is following
//
//	void rb_io_check_byte_readable(rb_io_t *fptr)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoCheckByteReadable(fptr *RbIoT) {
	var cFptr C.rb_io_t
	C.rb_io_check_byte_readable(&cFptr)
	*fptr = RbIoT(cFptr)
}

// RbIoCheckCharReadable calls `rb_io_check_char_readable` in C
//
// Original definition is following
//
//	void rb_io_check_char_readable(rb_io_t *fptr)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoCheckCharReadable(fptr *RbIoT) {
	var cFptr C.rb_io_t
	C.rb_io_check_char_readable(&cFptr)
	*fptr = RbIoT(cFptr)
}

// RbIoCheckClosed calls `rb_io_check_closed` in C
//
// Original definition is following
//
//	void rb_io_check_closed(rb_io_t *fptr)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoCheckClosed(fptr *RbIoT) {
	var cFptr C.rb_io_t
	C.rb_io_check_closed(&cFptr)
	*fptr = RbIoT(cFptr)
}

// RbIoCheckInitialized calls `rb_io_check_initialized` in C
//
// Original definition is following
//
//	void rb_io_check_initialized(rb_io_t *fptr)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoCheckInitialized(fptr *RbIoT) {
	var cFptr C.rb_io_t
	C.rb_io_check_initialized(&cFptr)
	*fptr = RbIoT(cFptr)
}

// RbIoCheckIo calls `rb_io_check_io` in C
//
// Original definition is following
//
//	VALUE rb_io_check_io(VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoCheckIo(io VALUE) VALUE {
	ret := VALUE(C.rb_io_check_io(C.VALUE(io)))
	return ret
}

// RbIoCheckReadable calls `rb_io_check_readable` in C
//
// Original definition is following
//
//	void rb_io_check_readable(rb_io_t *fptr)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoCheckReadable(fptr *RbIoT) {
	var cFptr C.rb_io_t
	C.rb_io_check_readable(&cFptr)
	*fptr = RbIoT(cFptr)
}

// RbIoCheckWritable calls `rb_io_check_writable` in C
//
// Original definition is following
//
//	void rb_io_check_writable(rb_io_t *fptr)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoCheckWritable(fptr *RbIoT) {
	var cFptr C.rb_io_t
	C.rb_io_check_writable(&cFptr)
	*fptr = RbIoT(cFptr)
}

// RbIoClosedP calls `rb_io_closed_p` in C
//
// Original definition is following
//
//	VALUE rb_io_closed_p(VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoClosedP(io VALUE) VALUE {
	ret := VALUE(C.rb_io_closed_p(C.VALUE(io)))
	return ret
}

// RbIoDescriptor calls `rb_io_descriptor` in C
//
// Original definition is following
//
//	int rb_io_descriptor(VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoDescriptor(io VALUE) int {
	ret := int(C.rb_io_descriptor(C.VALUE(io)))
	return ret
}

// RbIoExtractEncodingOption calls `rb_io_extract_encoding_option` in C
//
// Original definition is following
//
//	int rb_io_extract_encoding_option(VALUE opt, rb_encoding **enc_p, rb_encoding **enc2_p, int *fmode_p)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoExtractEncodingOption(opt VALUE, enc_p *RbEncoding, enc2_p *RbEncoding, fmode_p *int) int {
	var cEncP C.rb_encoding
	var cEnc2P C.rb_encoding
	var cFmodeP C.int
	ret := int(C.rb_io_extract_encoding_option(C.VALUE(opt), &cEncP, &cEnc2P, &cFmodeP))
	*enc_p = RbEncoding(cEncP)
	*enc2_p = RbEncoding(cEnc2P)
	*fmode_p = int(cFmodeP)
	return ret
}

// RbIoExtractModeenc calls `rb_io_extract_modeenc` in C
//
// Original definition is following
//
//	void rb_io_extract_modeenc(VALUE *vmode_p, VALUE *vperm_p, VALUE opthash, int *oflags_p, int *fmode_p, rb_io_enc_t *convconfig_p)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoExtractModeenc(vmode_p *VALUE, vperm_p *VALUE, opthash VALUE, oflags_p *int, fmode_p *int, convconfig_p *RbIoEncT) {
	var cVmodeP C.VALUE
	var cVpermP C.VALUE
	var cOflagsP C.int
	var cFmodeP C.int
	var cConvconfigP C.rb_io_enc_t
	C.rb_io_extract_modeenc(&cVmodeP, &cVpermP, C.VALUE(opthash), &cOflagsP, &cFmodeP, &cConvconfigP)
	*vmode_p = VALUE(cVmodeP)
	*vperm_p = VALUE(cVpermP)
	*oflags_p = int(cOflagsP)
	*fmode_p = int(cFmodeP)
	*convconfig_p = RbIoEncT(cConvconfigP)
}

// RbIoFptrFinalize calls `rb_io_fptr_finalize` in C
//
// Original definition is following
//
//	int rb_io_fptr_finalize(rb_io_t *fptr)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoFptrFinalize(fptr *RbIoT) int {
	var cFptr C.rb_io_t
	ret := int(C.rb_io_fptr_finalize(&cFptr))
	*fptr = RbIoT(cFptr)
	return ret
}

// RbIoGetIo calls `rb_io_get_io` in C
//
// Original definition is following
//
//	VALUE rb_io_get_io(VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoGetIo(io VALUE) VALUE {
	ret := VALUE(C.rb_io_get_io(C.VALUE(io)))
	return ret
}

// RbIoGetWriteIo calls `rb_io_get_write_io` in C
//
// Original definition is following
//
//	VALUE rb_io_get_write_io(VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoGetWriteIo(io VALUE) VALUE {
	ret := VALUE(C.rb_io_get_write_io(C.VALUE(io)))
	return ret
}

// RbIoMakeOpenFile calls `rb_io_make_open_file` in C
//
// Original definition is following
//
//	rb_io_t *rb_io_make_open_file(VALUE obj)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoMakeOpenFile(obj VALUE) *RbIoT {
	ret := *RbIoT(C.rb_io_make_open_file(C.VALUE(obj)))
	return ret
}

// RbIoMaybeWait calls `rb_io_maybe_wait` in C
//
// Original definition is following
//
//	VALUE rb_io_maybe_wait(int error, VALUE io, VALUE events, VALUE timeout)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoMaybeWait(error int, io VALUE, events VALUE, timeout VALUE) VALUE {
	ret := VALUE(C.rb_io_maybe_wait(C.int(error), C.VALUE(io), C.VALUE(events), C.VALUE(timeout)))
	return ret
}

// RbIoMaybeWaitReadable calls `rb_io_maybe_wait_readable` in C
//
// Original definition is following
//
//	int rb_io_maybe_wait_readable(int error, VALUE io, VALUE timeout)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoMaybeWaitReadable(error int, io VALUE, timeout VALUE) int {
	ret := int(C.rb_io_maybe_wait_readable(C.int(error), C.VALUE(io), C.VALUE(timeout)))
	return ret
}

// RbIoMaybeWaitWritable calls `rb_io_maybe_wait_writable` in C
//
// Original definition is following
//
//	int rb_io_maybe_wait_writable(int error, VALUE io, VALUE timeout)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoMaybeWaitWritable(error int, io VALUE, timeout VALUE) int {
	ret := int(C.rb_io_maybe_wait_writable(C.int(error), C.VALUE(io), C.VALUE(timeout)))
	return ret
}

// RbIoMode calls `rb_io_mode` in C
//
// Original definition is following
//
//	int rb_io_mode(VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoMode(io VALUE) int {
	ret := int(C.rb_io_mode(C.VALUE(io)))
	return ret
}

// RbIoModestrFmode calls `rb_io_modestr_fmode` in C
//
// Original definition is following
//
//	int rb_io_modestr_fmode(const char *modestr)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoModestrFmode(modestr string) int {
	char, clean := string2Char(modestr)
	defer clean()

	ret := int(C.rb_io_modestr_fmode(char))
	return ret
}

// RbIoModestrOflags calls `rb_io_modestr_oflags` in C
//
// Original definition is following
//
//	int rb_io_modestr_oflags(const char *modestr)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoModestrOflags(modestr string) int {
	char, clean := string2Char(modestr)
	defer clean()

	ret := int(C.rb_io_modestr_oflags(char))
	return ret
}

// RbIoOpenDescriptor calls `rb_io_open_descriptor` in C
//
// Original definition is following
//
//	VALUE rb_io_open_descriptor(VALUE klass, int descriptor, int mode, VALUE path, VALUE timeout, struct rb_io_encoding *encoding)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoOpenDescriptor(klass VALUE, descriptor int, mode int, path VALUE, timeout VALUE, encoding *RbIoEncoding) VALUE {
	var cEncoding C.rb_io_encoding
	ret := VALUE(C.rb_io_open_descriptor(C.VALUE(klass), C.int(descriptor), C.int(mode), C.VALUE(path), C.VALUE(timeout), &cEncoding))
	*encoding = RbIoEncoding(cEncoding)
	return ret
}

// RbIoPath calls `rb_io_path` in C
//
// Original definition is following
//
//	VALUE rb_io_path(VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoPath(io VALUE) VALUE {
	ret := VALUE(C.rb_io_path(C.VALUE(io)))
	return ret
}

// RbIoReadCheck calls `rb_io_read_check` in C
//
// Original definition is following
//
//	void rb_io_read_check(rb_io_t *fptr)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoReadCheck(fptr *RbIoT) {
	var cFptr C.rb_io_t
	C.rb_io_read_check(&cFptr)
	*fptr = RbIoT(cFptr)
}

// RbIoSetNonblock calls `rb_io_set_nonblock` in C
//
// Original definition is following
//
//	void rb_io_set_nonblock(rb_io_t *fptr)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoSetNonblock(fptr *RbIoT) {
	var cFptr C.rb_io_t
	C.rb_io_set_nonblock(&cFptr)
	*fptr = RbIoT(cFptr)
}

// RbIoSetTimeout calls `rb_io_set_timeout` in C
//
// Original definition is following
//
//	VALUE rb_io_set_timeout(VALUE io, VALUE timeout)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoSetTimeout(io VALUE, timeout VALUE) VALUE {
	ret := VALUE(C.rb_io_set_timeout(C.VALUE(io), C.VALUE(timeout)))
	return ret
}

// RbIoSetWriteIo calls `rb_io_set_write_io` in C
//
// Original definition is following
//
//	VALUE rb_io_set_write_io(VALUE io, VALUE w)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoSetWriteIo(io VALUE, w VALUE) VALUE {
	ret := VALUE(C.rb_io_set_write_io(C.VALUE(io), C.VALUE(w)))
	return ret
}

// RbIoStdioFile calls `rb_io_stdio_file` in C
//
// Original definition is following
//
//	FILE *rb_io_stdio_file(rb_io_t *fptr)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoStdioFile(fptr *RbIoT) *FILE {
	var cFptr C.rb_io_t
	ret := *FILE(C.rb_io_stdio_file(&cFptr))
	*fptr = RbIoT(cFptr)
	return ret
}

// RbIoSynchronized calls `rb_io_synchronized` in C
//
// Original definition is following
//
//	void rb_io_synchronized(rb_io_t *fptr)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoSynchronized(fptr *RbIoT) {
	var cFptr C.rb_io_t
	C.rb_io_synchronized(&cFptr)
	*fptr = RbIoT(cFptr)
}

// RbIoTaintCheck calls `rb_io_taint_check` in C
//
// Original definition is following
//
//	VALUE rb_io_taint_check(VALUE obj)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoTaintCheck(obj VALUE) VALUE {
	ret := VALUE(C.rb_io_taint_check(C.VALUE(obj)))
	return ret
}

// RbIoTimeout calls `rb_io_timeout` in C
//
// Original definition is following
//
//	VALUE rb_io_timeout(VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoTimeout(io VALUE) VALUE {
	ret := VALUE(C.rb_io_timeout(C.VALUE(io)))
	return ret
}

// RbIoWait calls `rb_io_wait` in C
//
// Original definition is following
//
//	VALUE rb_io_wait(VALUE io, VALUE events, VALUE timeout)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoWait(io VALUE, events VALUE, timeout VALUE) VALUE {
	ret := VALUE(C.rb_io_wait(C.VALUE(io), C.VALUE(events), C.VALUE(timeout)))
	return ret
}

// RbIoWaitReadable calls `rb_io_wait_readable` in C
//
// Original definition is following
//
//	int rb_io_wait_readable(int fd)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoWaitReadable(fd int) int {
	ret := int(C.rb_io_wait_readable(C.int(fd)))
	return ret
}

// RbIoWaitWritable calls `rb_io_wait_writable` in C
//
// Original definition is following
//
//	int rb_io_wait_writable(int fd)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbIoWaitWritable(fd int) int {
	ret := int(C.rb_io_wait_writable(C.int(fd)))
	return ret
}

// RbStatNew calls `rb_stat_new` in C
//
// Original definition is following
//
//	VALUE rb_stat_new(const struct stat *st)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbStatNew(st *Stat) VALUE {
	var cSt C.stat
	ret := VALUE(C.rb_stat_new(&cSt))
	*st = Stat(cSt)
	return ret
}

// RbWaitForSingleFd calls `rb_wait_for_single_fd` in C
//
// Original definition is following
//
//	int rb_wait_for_single_fd(int fd, int events, struct timeval *tv)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/io.h
func RbWaitForSingleFd(fd int, events int, tv *Timeval) int {
	var cTv C.timeval
	ret := int(C.rb_wait_for_single_fd(C.int(fd), C.int(events), &cTv))
	*tv = Timeval(cTv)
	return ret
}
