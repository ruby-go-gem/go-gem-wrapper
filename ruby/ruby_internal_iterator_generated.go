// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated
// Code generated by ruby_h_to_go. DO NOT EDIT.

package ruby

/*
#include "ruby.h"
*/
import "C"

import (
	"unsafe"
)

// RbBlockCallFunc is a type for passing `C.rb_block_call_func` in and out of package
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
type RbBlockCallFunc C.rb_block_call_func

// RbBlockCallFuncT is a type for passing `C.rb_block_call_func_t` in and out of package
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
type RbBlockCallFuncT C.rb_block_call_func_t

// RbBlockCall calls `rb_block_call` in C
//
// Original definition is following
//
//	VALUE rb_block_call(VALUE obj, ID mid, int argc, const VALUE *argv, rb_block_call_func_t proc, VALUE data2)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbBlockCall(obj VALUE, mid ID, argc int, argv *VALUE, proc RbBlockCallFuncT, data2 VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_block_call(C.VALUE(obj), C.ID(mid), C.int(argc), &cArgv, C.rb_block_call_func_t(proc), C.VALUE(data2)))
	*argv = VALUE(cArgv)
	return ret
}

// RbBlockCallKw calls `rb_block_call_kw` in C
//
// Original definition is following
//
//	VALUE rb_block_call_kw(VALUE obj, ID mid, int argc, const VALUE *argv, rb_block_call_func_t proc, VALUE data2, int kw_splat)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbBlockCallKw(obj VALUE, mid ID, argc int, argv *VALUE, proc RbBlockCallFuncT, data2 VALUE, kw_splat int) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_block_call_kw(C.VALUE(obj), C.ID(mid), C.int(argc), &cArgv, C.rb_block_call_func_t(proc), C.VALUE(data2), C.int(kw_splat)))
	*argv = VALUE(cArgv)
	return ret
}

// RbBlockGivenP calls `rb_block_given_p` in C
//
// Original definition is following
//
//	int rb_block_given_p(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbBlockGivenP() int {
	ret := int(C.rb_block_given_p())
	return ret
}

// RbCatch calls `rb_catch` in C
//
// Original definition is following
//
//	VALUE rb_catch(const char *tag, rb_block_call_func_t func, VALUE data)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbCatch(tag string, fun RbBlockCallFuncT, data VALUE) VALUE {
	char, clean := string2Char(tag)
	defer clean()

	ret := VALUE(C.rb_catch(char, C.rb_block_call_func_t(fun), C.VALUE(data)))
	return ret
}

// RbCatchObj calls `rb_catch_obj` in C
//
// Original definition is following
//
//	VALUE rb_catch_obj(VALUE tag, rb_block_call_func_t func, VALUE data)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbCatchObj(tag VALUE, fun RbBlockCallFuncT, data VALUE) VALUE {
	ret := VALUE(C.rb_catch_obj(C.VALUE(tag), C.rb_block_call_func_t(fun), C.VALUE(data)))
	return ret
}

// RbEach calls `rb_each` in C
//
// Original definition is following
//
//	VALUE rb_each(VALUE obj)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbEach(obj VALUE) VALUE {
	ret := VALUE(C.rb_each(C.VALUE(obj)))
	return ret
}

// RbEnsure calls `rb_ensure` in C
//
// Original definition is following
//
//	VALUE rb_ensure(VALUE (*b_proc)(VALUE), VALUE data1, VALUE (*e_proc)(VALUE), VALUE data2)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbEnsure(arg1 unsafe.Pointer, data1 VALUE, arg3 unsafe.Pointer, data2 VALUE) VALUE {
	ret := VALUE(C.rb_ensure(toCPointer(arg1), C.VALUE(data1), toCPointer(arg3), C.VALUE(data2)))
	return ret
}

// RbKeywordGivenP calls `rb_keyword_given_p` in C
//
// Original definition is following
//
//	int rb_keyword_given_p(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbKeywordGivenP() int {
	ret := int(C.rb_keyword_given_p())
	return ret
}

// RbNeedBlock calls `rb_need_block` in C
//
// Original definition is following
//
//	void rb_need_block(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbNeedBlock() {
	C.rb_need_block()
}

// RbRescue calls `rb_rescue` in C
//
// Original definition is following
//
//	VALUE rb_rescue(VALUE (*b_proc)(VALUE), VALUE data1, VALUE (*r_proc)(VALUE, VALUE), VALUE data2)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbRescue(arg1 unsafe.Pointer, data1 VALUE, arg3 unsafe.Pointer, data2 VALUE) VALUE {
	ret := VALUE(C.rb_rescue(toCPointer(arg1), C.VALUE(data1), toCPointer(arg3), C.VALUE(data2)))
	return ret
}

// RbVrescue2 calls `rb_vrescue2` in C
//
// Original definition is following
//
//	VALUE rb_vrescue2(VALUE (*b_proc)(VALUE), VALUE data1, VALUE (*r_proc)(VALUE, VALUE), VALUE data2, va_list ap)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbVrescue2(arg1 unsafe.Pointer, data1 VALUE, arg3 unsafe.Pointer, data2 VALUE, ap VaList) VALUE {
	ret := VALUE(C.rb_vrescue2(toCPointer(arg1), C.VALUE(data1), toCPointer(arg3), C.VALUE(data2), C.va_list(ap)))
	return ret
}

// RbYield calls `rb_yield` in C
//
// Original definition is following
//
//	VALUE rb_yield(VALUE val)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbYield(val VALUE) VALUE {
	ret := VALUE(C.rb_yield(C.VALUE(val)))
	return ret
}

// RbYieldBlock calls `rb_yield_block` in C
//
// Original definition is following
//
//	VALUE rb_yield_block(RB_BLOCK_CALL_FUNC_ARGLIST(yielded_arg, callback_arg)); /* rb_block_call_func *//*** Determines if the current method is given a keyword argument.** @retval  false  No keyword argument is given.* @retval  true   Keyword argument(s) are given.* @ingroup defmethod*/int rb_keyword_given_p(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbYieldBlock(arg1 unsafe.Pointer) VALUE {
	ret := VALUE(C.rb_yield_block(toCPointer(arg1)))
	return ret
}

// RbYieldSplat calls `rb_yield_splat` in C
//
// Original definition is following
//
//	VALUE rb_yield_splat(VALUE ary)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbYieldSplat(ary VALUE) VALUE {
	ret := VALUE(C.rb_yield_splat(C.VALUE(ary)))
	return ret
}

// RbYieldSplatKw calls `rb_yield_splat_kw` in C
//
// Original definition is following
//
//	VALUE rb_yield_splat_kw(VALUE ary, int kw_splat)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbYieldSplatKw(ary VALUE, kw_splat int) VALUE {
	ret := VALUE(C.rb_yield_splat_kw(C.VALUE(ary), C.int(kw_splat)))
	return ret
}

// RbYieldValues2 calls `rb_yield_values2` in C
//
// Original definition is following
//
//	VALUE rb_yield_values2(int n, const VALUE *argv)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbYieldValues2(n int, argv *VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_yield_values2(C.int(n), &cArgv))
	*argv = VALUE(cArgv)
	return ret
}

// RbYieldValuesKw calls `rb_yield_values_kw` in C
//
// Original definition is following
//
//	VALUE rb_yield_values_kw(int n, const VALUE *argv, int kw_splat)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbYieldValuesKw(n int, argv *VALUE, kw_splat int) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_yield_values_kw(C.int(n), &cArgv, C.int(kw_splat)))
	*argv = VALUE(cArgv)
	return ret
}
