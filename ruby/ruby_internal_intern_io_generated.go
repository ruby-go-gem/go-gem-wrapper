// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated
// Code generated by ruby_h_to_go. DO NOT EDIT.

package ruby

/*
#include "ruby.h"
*/
import "C"

// RbCloexecDup calls `rb_cloexec_dup` in C
//
// Original definition is following
//
//	int rb_cloexec_dup(int oldfd)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbCloexecDup(oldfd int) int {
	ret := int(C.rb_cloexec_dup(C.int(oldfd)))
	return ret
}

// RbCloexecDup2 calls `rb_cloexec_dup2` in C
//
// Original definition is following
//
//	int rb_cloexec_dup2(int oldfd, int newfd)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbCloexecDup2(oldfd int, newfd int) int {
	ret := int(C.rb_cloexec_dup2(C.int(oldfd), C.int(newfd)))
	return ret
}

// RbCloexecFcntlDupfd calls `rb_cloexec_fcntl_dupfd` in C
//
// Original definition is following
//
//	int rb_cloexec_fcntl_dupfd(int fd, int minfd)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbCloexecFcntlDupfd(fd int, minfd int) int {
	ret := int(C.rb_cloexec_fcntl_dupfd(C.int(fd), C.int(minfd)))
	return ret
}

// RbCloexecOpen calls `rb_cloexec_open` in C
//
// Original definition is following
//
//	int rb_cloexec_open(const char *pathname, int flags, mode_t mode)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbCloexecOpen(pathname string, flags int, mode ModeT) int {
	char, clean := string2Char(pathname)
	defer clean()

	ret := int(C.rb_cloexec_open(char, C.int(flags), C.mode_t(mode)))
	return ret
}

// RbCloexecPipe calls `rb_cloexec_pipe` in C
//
// Original definition is following
//
//	int rb_cloexec_pipe(int fildes[2])
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbCloexecPipe(fildes []int) int {
	ret := int(C.rb_cloexec_pipe(toCArray[int, C.int](fildes)))
	return ret
}

// RbCloseBeforeExec calls `rb_close_before_exec` in C
//
// Original definition is following
//
//	void rb_close_before_exec(int lowfd, int maxhint, VALUE noclose_fds)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbCloseBeforeExec(lowfd int, maxhint int, noclose_fds VALUE) {
	C.rb_close_before_exec(C.int(lowfd), C.int(maxhint), C.VALUE(noclose_fds))
}

// RbFdFixCloexec calls `rb_fd_fix_cloexec` in C
//
// Original definition is following
//
//	void rb_fd_fix_cloexec(int fd)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbFdFixCloexec(fd int) {
	C.rb_fd_fix_cloexec(C.int(fd))
}

// RbFileOpen calls `rb_file_open` in C
//
// Original definition is following
//
//	VALUE rb_file_open(const char *fname, const char *fmode)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbFileOpen(fname string, fmode string) VALUE {
	charFname, cleanCharfname := string2Char(fname)
	defer cleanCharfname()

	charFmode, cleanCharfmode := string2Char(fmode)
	defer cleanCharfmode()

	ret := VALUE(C.rb_file_open(charFname, charFmode))
	return ret
}

// RbFileOpenStr calls `rb_file_open_str` in C
//
// Original definition is following
//
//	VALUE rb_file_open_str(VALUE fname, const char *fmode)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbFileOpenStr(fname VALUE, fmode string) VALUE {
	char, clean := string2Char(fmode)
	defer clean()

	ret := VALUE(C.rb_file_open_str(C.VALUE(fname), char))
	return ret
}

// RbGets calls `rb_gets` in C
//
// Original definition is following
//
//	VALUE rb_gets(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbGets() VALUE {
	ret := VALUE(C.rb_gets())
	return ret
}

// RbIoAddstr calls `rb_io_addstr` in C
//
// Original definition is following
//
//	VALUE rb_io_addstr(VALUE io, VALUE str)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbIoAddstr(io VALUE, str VALUE) VALUE {
	ret := VALUE(C.rb_io_addstr(C.VALUE(io), C.VALUE(str)))
	return ret
}

// RbIoAscii8BitBinmode calls `rb_io_ascii8bit_binmode` in C
//
// Original definition is following
//
//	VALUE rb_io_ascii8bit_binmode(VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbIoAscii8BitBinmode(io VALUE) VALUE {
	ret := VALUE(C.rb_io_ascii8bit_binmode(C.VALUE(io)))
	return ret
}

// RbIoBinmode calls `rb_io_binmode` in C
//
// Original definition is following
//
//	VALUE rb_io_binmode(VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbIoBinmode(io VALUE) VALUE {
	ret := VALUE(C.rb_io_binmode(C.VALUE(io)))
	return ret
}

// RbIoClose calls `rb_io_close` in C
//
// Original definition is following
//
//	VALUE rb_io_close(VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbIoClose(io VALUE) VALUE {
	ret := VALUE(C.rb_io_close(C.VALUE(io)))
	return ret
}

// RbIoEof calls `rb_io_eof` in C
//
// Original definition is following
//
//	VALUE rb_io_eof(VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbIoEof(io VALUE) VALUE {
	ret := VALUE(C.rb_io_eof(C.VALUE(io)))
	return ret
}

// RbIoFdopen calls `rb_io_fdopen` in C
//
// Original definition is following
//
//	VALUE rb_io_fdopen(int fd, int flags, const char *path)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbIoFdopen(fd int, flags int, path string) VALUE {
	char, clean := string2Char(path)
	defer clean()

	ret := VALUE(C.rb_io_fdopen(C.int(fd), C.int(flags), char))
	return ret
}

// RbIoFlush calls `rb_io_flush` in C
//
// Original definition is following
//
//	VALUE rb_io_flush(VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbIoFlush(io VALUE) VALUE {
	ret := VALUE(C.rb_io_flush(C.VALUE(io)))
	return ret
}

// RbIoGetbyte calls `rb_io_getbyte` in C
//
// Original definition is following
//
//	VALUE rb_io_getbyte(VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbIoGetbyte(io VALUE) VALUE {
	ret := VALUE(C.rb_io_getbyte(C.VALUE(io)))
	return ret
}

// RbIoGets calls `rb_io_gets` in C
//
// Original definition is following
//
//	VALUE rb_io_gets(VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbIoGets(io VALUE) VALUE {
	ret := VALUE(C.rb_io_gets(C.VALUE(io)))
	return ret
}

// RbIoPrint calls `rb_io_print` in C
//
// Original definition is following
//
//	VALUE rb_io_print(int argc, const VALUE *argv, VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbIoPrint(argc int, argv *VALUE, io VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_io_print(C.int(argc), &cArgv, C.VALUE(io)))
	*argv = VALUE(cArgv)
	return ret
}

// RbIoPrintf calls `rb_io_printf` in C
//
// Original definition is following
//
//	VALUE rb_io_printf(int argc, const VALUE *argv, VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbIoPrintf(argc int, argv *VALUE, io VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_io_printf(C.int(argc), &cArgv, C.VALUE(io)))
	*argv = VALUE(cArgv)
	return ret
}

// RbIoPuts calls `rb_io_puts` in C
//
// Original definition is following
//
//	VALUE rb_io_puts(int argc, const VALUE *argv, VALUE io)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbIoPuts(argc int, argv *VALUE, io VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_io_puts(C.int(argc), &cArgv, C.VALUE(io)))
	*argv = VALUE(cArgv)
	return ret
}

// RbIoUngetbyte calls `rb_io_ungetbyte` in C
//
// Original definition is following
//
//	VALUE rb_io_ungetbyte(VALUE io, VALUE b)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbIoUngetbyte(io VALUE, b VALUE) VALUE {
	ret := VALUE(C.rb_io_ungetbyte(C.VALUE(io), C.VALUE(b)))
	return ret
}

// RbIoUngetc calls `rb_io_ungetc` in C
//
// Original definition is following
//
//	VALUE rb_io_ungetc(VALUE io, VALUE c)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbIoUngetc(io VALUE, c VALUE) VALUE {
	ret := VALUE(C.rb_io_ungetc(C.VALUE(io), C.VALUE(c)))
	return ret
}

// RbIoWrite calls `rb_io_write` in C
//
// Original definition is following
//
//	VALUE rb_io_write(VALUE io, VALUE str)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbIoWrite(io VALUE, str VALUE) VALUE {
	ret := VALUE(C.rb_io_write(C.VALUE(io), C.VALUE(str)))
	return ret
}

// RbPipe calls `rb_pipe` in C
//
// Original definition is following
//
//	int rb_pipe(int *pipes)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbPipe(pipes *int) int {
	var cPipes C.int
	ret := int(C.rb_pipe(&cPipes))
	*pipes = int(cPipes)
	return ret
}

// RbReservedFdP calls `rb_reserved_fd_p` in C
//
// Original definition is following
//
//	int rb_reserved_fd_p(int fd)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbReservedFdP(fd int) int {
	ret := int(C.rb_reserved_fd_p(C.int(fd)))
	return ret
}

// RbUpdateMaxFd calls `rb_update_max_fd` in C
//
// Original definition is following
//
//	void rb_update_max_fd(int fd)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbUpdateMaxFd(fd int) {
	C.rb_update_max_fd(C.int(fd))
}

// RbWriteError calls `rb_write_error` in C
//
// Original definition is following
//
//	void rb_write_error(const char *str)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbWriteError(str string) {
	char, clean := string2Char(str)
	defer clean()

	C.rb_write_error(char)
}

// RbWriteError2 calls `rb_write_error2` in C
//
// Original definition is following
//
//	void rb_write_error2(const char *str, long len)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/io.h
func RbWriteError2(str string, len Long) {
	char, clean := string2Char(str)
	defer clean()

	C.rb_write_error2(char, C.long(len))
}
