// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated
// Code generated by ruby_h_to_go. DO NOT EDIT.

package ruby

/*
#include "ruby.h"
*/
import "C"

// RbCallSuper calls `rb_call_super` in C
//
// Original definition is following
//
//	VALUE rb_call_super(int argc, const VALUE *argv)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbCallSuper(argc int, argv *VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_call_super(C.int(argc), &cArgv))
	*argv = VALUE(cArgv)
	return ret
}

// RbCallSuperKw calls `rb_call_super_kw` in C
//
// Original definition is following
//
//	VALUE rb_call_super_kw(int argc, const VALUE *argv, int kw_splat)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbCallSuperKw(argc int, argv *VALUE, kw_splat int) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_call_super_kw(C.int(argc), &cArgv, C.int(kw_splat)))
	*argv = VALUE(cArgv)
	return ret
}

// RbCurrentReceiver calls `rb_current_receiver` in C
//
// Original definition is following
//
//	VALUE rb_current_receiver(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbCurrentReceiver() VALUE {
	ret := VALUE(C.rb_current_receiver())
	return ret
}

// RbEvalString calls `rb_eval_string` in C
//
// Original definition is following
//
//	VALUE rb_eval_string(const char *str)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbEvalString(str string) VALUE {
	char, clean := string2Char(str)
	defer clean()

	ret := VALUE(C.rb_eval_string(char))
	return ret
}

// RbEvalStringProtect calls `rb_eval_string_protect` in C
//
// Original definition is following
//
//	VALUE rb_eval_string_protect(const char *str, int *state)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbEvalStringProtect(str string, state *int) VALUE {
	char, clean := string2Char(str)
	defer clean()

	var cState C.int
	ret := VALUE(C.rb_eval_string_protect(char, &cState))
	*state = int(cState)
	return ret
}

// RbEvalStringWrap calls `rb_eval_string_wrap` in C
//
// Original definition is following
//
//	VALUE rb_eval_string_wrap(const char *str, int *state)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbEvalStringWrap(str string, state *int) VALUE {
	char, clean := string2Char(str)
	defer clean()

	var cState C.int
	ret := VALUE(C.rb_eval_string_wrap(char, &cState))
	*state = int(cState)
	return ret
}

// RbExtractKeywords calls `rb_extract_keywords` in C
//
// Original definition is following
//
//	VALUE rb_extract_keywords(VALUE *orighash)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbExtractKeywords(orighash *VALUE) VALUE {
	var cOrighash C.VALUE
	ret := VALUE(C.rb_extract_keywords(&cOrighash))
	*orighash = VALUE(cOrighash)
	return ret
}

// RbFuncallPassingBlock calls `rb_funcall_passing_block` in C
//
// Original definition is following
//
//	VALUE rb_funcall_passing_block(VALUE recv, ID mid, int argc, const VALUE *argv)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbFuncallPassingBlock(recv VALUE, mid ID, argc int, argv *VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_funcall_passing_block(C.VALUE(recv), C.ID(mid), C.int(argc), &cArgv))
	*argv = VALUE(cArgv)
	return ret
}

// RbFuncallPassingBlockKw calls `rb_funcall_passing_block_kw` in C
//
// Original definition is following
//
//	VALUE rb_funcall_passing_block_kw(VALUE recv, ID mid, int argc, const VALUE *argv, int kw_splat)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbFuncallPassingBlockKw(recv VALUE, mid ID, argc int, argv *VALUE, kw_splat int) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_funcall_passing_block_kw(C.VALUE(recv), C.ID(mid), C.int(argc), &cArgv, C.int(kw_splat)))
	*argv = VALUE(cArgv)
	return ret
}

// RbFuncallWithBlock calls `rb_funcall_with_block` in C
//
// Original definition is following
//
//	VALUE rb_funcall_with_block(VALUE recv, ID mid, int argc, const VALUE *argv, VALUE procval)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbFuncallWithBlock(recv VALUE, mid ID, argc int, argv *VALUE, procval VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_funcall_with_block(C.VALUE(recv), C.ID(mid), C.int(argc), &cArgv, C.VALUE(procval)))
	*argv = VALUE(cArgv)
	return ret
}

// RbFuncallWithBlockKw calls `rb_funcall_with_block_kw` in C
//
// Original definition is following
//
//	VALUE rb_funcall_with_block_kw(VALUE recv, ID mid, int argc, const VALUE *argv, VALUE procval, int kw_splat)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbFuncallWithBlockKw(recv VALUE, mid ID, argc int, argv *VALUE, procval VALUE, kw_splat int) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_funcall_with_block_kw(C.VALUE(recv), C.ID(mid), C.int(argc), &cArgv, C.VALUE(procval), C.int(kw_splat)))
	*argv = VALUE(cArgv)
	return ret
}

// RbFuncallv calls `rb_funcallv` in C
//
// Original definition is following
//
//	VALUE rb_funcallv(VALUE recv, ID mid, int argc, const VALUE *argv)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbFuncallv(recv VALUE, mid ID, argc int, argv []VALUE) VALUE {
	ret := VALUE(C.rb_funcallv(C.VALUE(recv), C.ID(mid), C.int(argc), toCArray[VALUE, C.VALUE](argv)))
	return ret
}

// RbFuncallvKw calls `rb_funcallv_kw` in C
//
// Original definition is following
//
//	VALUE rb_funcallv_kw(VALUE recv, ID mid, int argc, const VALUE *argv, int kw_splat)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbFuncallvKw(recv VALUE, mid ID, argc int, argv *VALUE, kw_splat int) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_funcallv_kw(C.VALUE(recv), C.ID(mid), C.int(argc), &cArgv, C.int(kw_splat)))
	*argv = VALUE(cArgv)
	return ret
}

// RbFuncallvPublic calls `rb_funcallv_public` in C
//
// Original definition is following
//
//	VALUE rb_funcallv_public(VALUE recv, ID mid, int argc, const VALUE *argv)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbFuncallvPublic(recv VALUE, mid ID, argc int, argv []VALUE) VALUE {
	ret := VALUE(C.rb_funcallv_public(C.VALUE(recv), C.ID(mid), C.int(argc), toCArray[VALUE, C.VALUE](argv)))
	return ret
}

// RbFuncallvPublicKw calls `rb_funcallv_public_kw` in C
//
// Original definition is following
//
//	VALUE rb_funcallv_public_kw(VALUE recv, ID mid, int argc, const VALUE *argv, int kw_splat)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbFuncallvPublicKw(recv VALUE, mid ID, argc int, argv *VALUE, kw_splat int) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_funcallv_public_kw(C.VALUE(recv), C.ID(mid), C.int(argc), &cArgv, C.int(kw_splat)))
	*argv = VALUE(cArgv)
	return ret
}

// RbGetKwargs calls `rb_get_kwargs` in C
//
// Original definition is following
//
//	int rb_get_kwargs(VALUE keyword_hash, const ID *table, int required, int optional, VALUE *values)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbGetKwargs(keyword_hash VALUE, table *ID, required int, optional int, values *VALUE) int {
	var cTable C.ID
	var cValues C.VALUE
	ret := int(C.rb_get_kwargs(C.VALUE(keyword_hash), &cTable, C.int(required), C.int(optional), &cValues))
	*table = ID(cTable)
	*values = VALUE(cValues)
	return ret
}
