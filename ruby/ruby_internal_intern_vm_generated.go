// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated
// Code generated by ruby_h_to_go. DO NOT EDIT.

package ruby

/*
#include "ruby.h"
*/
import "C"

// RbAllocFuncT is a type for passing `C.rb_alloc_func_t` in and out of package
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
type RbAllocFuncT C.rb_alloc_func_t

// RbAlias calls `rb_alias` in C
//
// Original definition is following
//
//	void rb_alias(VALUE klass, ID dst, ID src)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbAlias(klass VALUE, dst ID, src ID) {
	C.rb_alias(C.VALUE(klass), C.ID(dst), C.ID(src))
}

// RbApply calls `rb_apply` in C
//
// Original definition is following
//
//	VALUE rb_apply(VALUE recv, ID mid, VALUE args)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbApply(recv VALUE, mid ID, args VALUE) VALUE {
	ret := VALUE(C.rb_apply(C.VALUE(recv), C.ID(mid), C.VALUE(args)))
	return ret
}

// RbAttr calls `rb_attr` in C
//
// Original definition is following
//
//	void rb_attr(VALUE klass, ID name, int need_reader, int need_writer, int honour_visibility)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbAttr(klass VALUE, name ID, need_reader int, need_writer int, honour_visibility int) {
	C.rb_attr(C.VALUE(klass), C.ID(name), C.int(need_reader), C.int(need_writer), C.int(honour_visibility))
}

// RbBacktrace calls `rb_backtrace` in C
//
// Original definition is following
//
//	void rb_backtrace(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbBacktrace() {
	C.rb_backtrace()
}

// RbCheckFuncall calls `rb_check_funcall` in C
//
// Original definition is following
//
//	VALUE rb_check_funcall(VALUE recv, ID mid, int argc, const VALUE *argv)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbCheckFuncall(recv VALUE, mid ID, argc int, argv *VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_check_funcall(C.VALUE(recv), C.ID(mid), C.int(argc), &cArgv))
	*argv = VALUE(cArgv)
	return ret
}

// RbCheckFuncallKw calls `rb_check_funcall_kw` in C
//
// Original definition is following
//
//	VALUE rb_check_funcall_kw(VALUE recv, ID mid, int argc, const VALUE *argv, int kw_splat)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbCheckFuncallKw(recv VALUE, mid ID, argc int, argv *VALUE, kw_splat int) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_check_funcall_kw(C.VALUE(recv), C.ID(mid), C.int(argc), &cArgv, C.int(kw_splat)))
	*argv = VALUE(cArgv)
	return ret
}

// RbClearConstantCacheForId calls `rb_clear_constant_cache_for_id` in C
//
// Original definition is following
//
//	void rb_clear_constant_cache_for_id(ID id)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbClearConstantCacheForId(id ID) {
	C.rb_clear_constant_cache_for_id(C.ID(id))
}

// RbDefineAllocFunc calls `rb_define_alloc_func` in C
//
// Original definition is following
//
//	void rb_define_alloc_func(VALUE klass, rb_alloc_func_t func)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbDefineAllocFunc(klass VALUE, fun RbAllocFuncT) {
	C.rb_define_alloc_func(C.VALUE(klass), C.rb_alloc_func_t(fun))
}

// RbEvalCmdKw calls `rb_eval_cmd_kw` in C
//
// Original definition is following
//
//	VALUE rb_eval_cmd_kw(VALUE cmd, VALUE arg, int kw_splat)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbEvalCmdKw(cmd VALUE, arg VALUE, kw_splat int) VALUE {
	ret := VALUE(C.rb_eval_cmd_kw(C.VALUE(cmd), C.VALUE(arg), C.int(kw_splat)))
	return ret
}

// RbFrameMethodIdAndClass calls `rb_frame_method_id_and_class` in C
//
// Original definition is following
//
//	int rb_frame_method_id_and_class(ID *idp, VALUE *klassp)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbFrameMethodIdAndClass(idp *ID, klassp *VALUE) int {
	var cIdp C.ID
	var cKlassp C.VALUE
	ret := int(C.rb_frame_method_id_and_class(&cIdp, &cKlassp))
	*idp = ID(cIdp)
	*klassp = VALUE(cKlassp)
	return ret
}

// RbGetAllocFunc calls `rb_get_alloc_func` in C
//
// Original definition is following
//
//	rb_alloc_func_t rb_get_alloc_func(VALUE klass)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbGetAllocFunc(klass VALUE) RbAllocFuncT {
	ret := RbAllocFuncT(C.rb_get_alloc_func(C.VALUE(klass)))
	return ret
}

// RbMakeBacktrace calls `rb_make_backtrace` in C
//
// Original definition is following
//
//	VALUE rb_make_backtrace(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbMakeBacktrace() VALUE {
	ret := VALUE(C.rb_make_backtrace())
	return ret
}

// RbMethodBasicDefinitionP calls `rb_method_basic_definition_p` in C
//
// Original definition is following
//
//	int rb_method_basic_definition_p(VALUE klass, ID mid)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbMethodBasicDefinitionP(klass VALUE, mid ID) int {
	ret := int(C.rb_method_basic_definition_p(C.VALUE(klass), C.ID(mid)))
	return ret
}

// RbMethodBoundp calls `rb_method_boundp` in C
//
// Original definition is following
//
//	int rb_method_boundp(VALUE klass, ID id, int ex)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbMethodBoundp(klass VALUE, id ID, ex int) int {
	ret := int(C.rb_method_boundp(C.VALUE(klass), C.ID(id), C.int(ex)))
	return ret
}

// RbModModuleEval calls `rb_mod_module_eval` in C
//
// Original definition is following
//
//	VALUE rb_mod_module_eval(int argc, const VALUE *argv, VALUE mod)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbModModuleEval(argc int, argv *VALUE, mod VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_mod_module_eval(C.int(argc), &cArgv, C.VALUE(mod)))
	*argv = VALUE(cArgv)
	return ret
}

// RbModModuleExec calls `rb_mod_module_exec` in C
//
// Original definition is following
//
//	VALUE rb_mod_module_exec(int argc, const VALUE *argv, VALUE mod)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbModModuleExec(argc int, argv *VALUE, mod VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_mod_module_exec(C.int(argc), &cArgv, C.VALUE(mod)))
	*argv = VALUE(cArgv)
	return ret
}

// RbObjInstanceEval calls `rb_obj_instance_eval` in C
//
// Original definition is following
//
//	VALUE rb_obj_instance_eval(int argc, const VALUE *argv, VALUE recv)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbObjInstanceEval(argc int, argv *VALUE, recv VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_obj_instance_eval(C.int(argc), &cArgv, C.VALUE(recv)))
	*argv = VALUE(cArgv)
	return ret
}

// RbObjInstanceExec calls `rb_obj_instance_exec` in C
//
// Original definition is following
//
//	VALUE rb_obj_instance_exec(int argc, const VALUE *argv, VALUE recv)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbObjInstanceExec(argc int, argv *VALUE, recv VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_obj_instance_exec(C.int(argc), &cArgv, C.VALUE(recv)))
	*argv = VALUE(cArgv)
	return ret
}

// RbObjRespondTo calls `rb_obj_respond_to` in C
//
// Original definition is following
//
//	int rb_obj_respond_to(VALUE obj, ID mid, int private_p)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbObjRespondTo(obj VALUE, mid ID, private_p int) int {
	ret := int(C.rb_obj_respond_to(C.VALUE(obj), C.ID(mid), C.int(private_p)))
	return ret
}

// RbRemoveMethod calls `rb_remove_method` in C
//
// Original definition is following
//
//	void rb_remove_method(VALUE klass, const char *name)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbRemoveMethod(klass VALUE, name string) {
	char, clean := string2Char(name)
	defer clean()

	C.rb_remove_method(C.VALUE(klass), char)
}

// RbRemoveMethodId calls `rb_remove_method_id` in C
//
// Original definition is following
//
//	void rb_remove_method_id(VALUE klass, ID mid)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbRemoveMethodId(klass VALUE, mid ID) {
	C.rb_remove_method_id(C.VALUE(klass), C.ID(mid))
}

// RbRespondTo calls `rb_respond_to` in C
//
// Original definition is following
//
//	int rb_respond_to(VALUE obj, ID mid)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbRespondTo(obj VALUE, mid ID) int {
	ret := int(C.rb_respond_to(C.VALUE(obj), C.ID(mid)))
	return ret
}

// RbSourcefile calls `rb_sourcefile` in C
//
// Original definition is following
//
//	const char *rb_sourcefile(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbSourcefile() string {
	ret := string(C.rb_sourcefile())
	return ret
}

// RbUndefAllocFunc calls `rb_undef_alloc_func` in C
//
// Original definition is following
//
//	void rb_undef_alloc_func(VALUE klass)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/vm.h
func RbUndefAllocFunc(klass VALUE) {
	C.rb_undef_alloc_func(C.VALUE(klass))
}
