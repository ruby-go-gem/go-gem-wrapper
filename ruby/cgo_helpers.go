// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package ruby

/*
#include "ruby.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocFdSetMemory allocates memory for type C.fd_set in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFdSetMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFdSetValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfFdSetValue = unsafe.Sizeof([1]C.fd_set{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FdSet) Ref() *C.fd_set {
	if x == nil {
		return nil
	}
	return x.ref89e67f53
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FdSet) Free() {
	if x != nil && x.allocs89e67f53 != nil {
		x.allocs89e67f53.(*cgoAllocMap).Free()
		x.ref89e67f53 = nil
	}
}

// NewFdSetRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFdSetRef(ref unsafe.Pointer) *FdSet {
	if ref == nil {
		return nil
	}
	obj := new(FdSet)
	obj.ref89e67f53 = (*C.fd_set)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FdSet) PassRef() (*C.fd_set, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref89e67f53 != nil {
		return x.ref89e67f53, nil
	}
	mem89e67f53 := allocFdSetMemory(1)
	ref89e67f53 := (*C.fd_set)(mem89e67f53)
	allocs89e67f53 := new(cgoAllocMap)
	allocs89e67f53.Add(mem89e67f53)

	var cfds_bits_allocs *cgoAllocMap
	ref89e67f53.fds_bits, cfds_bits_allocs = *(*[32]C.__int32_t)(unsafe.Pointer(&x.FdsBits)), cgoAllocsUnknown
	allocs89e67f53.Borrow(cfds_bits_allocs)

	x.ref89e67f53 = ref89e67f53
	x.allocs89e67f53 = allocs89e67f53
	return ref89e67f53, allocs89e67f53

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FdSet) PassValue() (C.fd_set, *cgoAllocMap) {
	if x.ref89e67f53 != nil {
		return *x.ref89e67f53, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FdSet) Deref() {
	if x.ref89e67f53 == nil {
		return
	}
	x.FdsBits = *(*[32]int32)(unsafe.Pointer(&x.ref89e67f53.fds_bits))
}

func (x RUBYDATAFUNC) PassRef() (ref *C.RUBY_DATA_FUNC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rUBYDATAFUNCE7CA08AFunc == nil {
		rUBYDATAFUNCE7CA08AFunc = x
	}
	return (*C.RUBY_DATA_FUNC)(C.RUBY_DATA_FUNC_e7ca08a), nil
}

func (x RUBYDATAFUNC) PassValue() (ref C.RUBY_DATA_FUNC, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rUBYDATAFUNCE7CA08AFunc == nil {
		rUBYDATAFUNCE7CA08AFunc = x
	}
	return (C.RUBY_DATA_FUNC)(C.RUBY_DATA_FUNC_e7ca08a), nil
}

func NewRUBYDATAFUNCRef(ref unsafe.Pointer) *RUBYDATAFUNC {
	return (*RUBYDATAFUNC)(ref)
}

//export rUBYDATAFUNCE7CA08A
func rUBYDATAFUNCE7CA08A(carg0 unsafe.Pointer) {
	if rUBYDATAFUNCE7CA08AFunc != nil {
		arg0e7ca08a := (unsafe.Pointer)(unsafe.Pointer(carg0))
		rUBYDATAFUNCE7CA08AFunc(arg0e7ca08a)
		return
	}
	panic("callback func has not been set (race?)")
}

var rUBYDATAFUNCE7CA08AFunc RUBYDATAFUNC

// allocRbDataTypeTMemory allocates memory for type C.rb_data_type_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRbDataTypeTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRbDataTypeTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRbDataTypeTValue = unsafe.Sizeof([1]C.rb_data_type_t{})

// copyPCharBytes copies the data from Go slice as *C.char.
func copyPCharBytes(slice *sliceHeader) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfCharValue) * slice.Len,
		Cap:  int(sizeOfCharValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.char)(mem0), allocs
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocCharMemory allocates memory for type C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCharValue = unsafe.Sizeof([1]C.char{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSRbDataTypeT transforms a sliced Go data structure into plain C format.
func unpackSRbDataTypeT(x []RbDataTypeT) (unpacked *C.rb_data_type_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocRbDataTypeTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.rb_data_type_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.rb_data_type_t)(h.Data)
	return
}

// packSRbDataTypeT reads sliced Go data structure out from plain C format.
func packSRbDataTypeT(v []RbDataTypeT, ptr0 *C.rb_data_type_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRbDataTypeTValue]C.rb_data_type_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRbDataTypeTRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RbDataTypeT) Ref() *C.rb_data_type_t {
	if x == nil {
		return nil
	}
	return x.ref6b581591
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RbDataTypeT) Free() {
	if x != nil && x.allocs6b581591 != nil {
		x.allocs6b581591.(*cgoAllocMap).Free()
		x.ref6b581591 = nil
	}
}

// NewRbDataTypeTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRbDataTypeTRef(ref unsafe.Pointer) *RbDataTypeT {
	if ref == nil {
		return nil
	}
	obj := new(RbDataTypeT)
	obj.ref6b581591 = (*C.rb_data_type_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RbDataTypeT) PassRef() (*C.rb_data_type_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6b581591 != nil {
		return x.ref6b581591, nil
	}
	mem6b581591 := allocRbDataTypeTMemory(1)
	ref6b581591 := (*C.rb_data_type_t)(mem6b581591)
	allocs6b581591 := new(cgoAllocMap)
	allocs6b581591.Add(mem6b581591)

	var cwrap_struct_name_allocs *cgoAllocMap
	ref6b581591.wrap_struct_name, cwrap_struct_name_allocs = copyPCharBytes((*sliceHeader)(unsafe.Pointer(&x.WrapStructName)))
	allocs6b581591.Borrow(cwrap_struct_name_allocs)

	var cparent_allocs *cgoAllocMap
	ref6b581591.parent, cparent_allocs = unpackSRbDataTypeT(x.Parent)
	allocs6b581591.Borrow(cparent_allocs)

	var cdata_allocs *cgoAllocMap
	ref6b581591.data, cdata_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocs6b581591.Borrow(cdata_allocs)

	var cflags_allocs *cgoAllocMap
	ref6b581591.flags, cflags_allocs = (C.VALUE)(x.Flags), cgoAllocsUnknown
	allocs6b581591.Borrow(cflags_allocs)

	x.ref6b581591 = ref6b581591
	x.allocs6b581591 = allocs6b581591
	return ref6b581591, allocs6b581591

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RbDataTypeT) PassValue() (C.rb_data_type_t, *cgoAllocMap) {
	if x.ref6b581591 != nil {
		return *x.ref6b581591, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RbDataTypeT) Deref() {
	if x.ref6b581591 == nil {
		return
	}
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.WrapStructName))
	hxfc4425b.Data = unsafe.Pointer(x.ref6b581591.wrap_struct_name)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ? x.WrapStructName x.ref6b581591.wrap_struct_name

	packSRbDataTypeT(x.Parent, x.ref6b581591.parent)
	x.Data = (unsafe.Pointer)(unsafe.Pointer(x.ref6b581591.data))
	x.Flags = (VALUE)(x.ref6b581591.flags)
}

func (x RbEventHookFuncT) PassRef() (ref *C.rb_event_hook_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rbEventHookFuncT7BD0F07CFunc == nil {
		rbEventHookFuncT7BD0F07CFunc = x
	}
	return (*C.rb_event_hook_func_t)(C.rb_event_hook_func_t_7bd0f07c), nil
}

func (x RbEventHookFuncT) PassValue() (ref C.rb_event_hook_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rbEventHookFuncT7BD0F07CFunc == nil {
		rbEventHookFuncT7BD0F07CFunc = x
	}
	return (C.rb_event_hook_func_t)(C.rb_event_hook_func_t_7bd0f07c), nil
}

func NewRbEventHookFuncTRef(ref unsafe.Pointer) *RbEventHookFuncT {
	return (*RbEventHookFuncT)(ref)
}

//export rbEventHookFuncT7BD0F07C
func rbEventHookFuncT7BD0F07C(cevflag C.rb_event_flag_t, cdata C.VALUE, cself C.VALUE, cmid C.ID, cklass C.VALUE) {
	if rbEventHookFuncT7BD0F07CFunc != nil {
		evflag7bd0f07c := (RbEventFlagT)(cevflag)
		data7bd0f07c := (VALUE)(cdata)
		self7bd0f07c := (VALUE)(cself)
		mid7bd0f07c := (ID)(cmid)
		klass7bd0f07c := (VALUE)(cklass)
		rbEventHookFuncT7BD0F07CFunc(evflag7bd0f07c, data7bd0f07c, self7bd0f07c, mid7bd0f07c, klass7bd0f07c)
		return
	}
	panic("callback func has not been set (race?)")
}

var rbEventHookFuncT7BD0F07CFunc RbEventHookFuncT

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

func (x RubyGlobFunc) PassRef() (ref *C.ruby_glob_func, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rubyGlobFunc2A0D65EDFunc == nil {
		rubyGlobFunc2A0D65EDFunc = x
	}
	return (*C.ruby_glob_func)(C.ruby_glob_func_2a0d65ed), nil
}

func NewRubyGlobFuncRef(ref unsafe.Pointer) *RubyGlobFunc {
	return (*RubyGlobFunc)(ref)
}

//export rubyGlobFunc2A0D65ED
func rubyGlobFunc2A0D65ED(cpath *C.char, carg C.VALUE, cenc unsafe.Pointer) C.int {
	if rubyGlobFunc2A0D65EDFunc != nil {
		path2a0d65ed := packPCharString(cpath)
		arg2a0d65ed := (VALUE)(carg)
		enc2a0d65ed := (unsafe.Pointer)(unsafe.Pointer(cenc))
		ret2a0d65ed := rubyGlobFunc2A0D65EDFunc(path2a0d65ed, arg2a0d65ed, enc2a0d65ed)
		ret, _ := (C.int)(ret2a0d65ed), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var rubyGlobFunc2A0D65EDFunc RubyGlobFunc

func (x RbEnumeratorSizeFunc) PassRef() (ref *C.rb_enumerator_size_func, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rbEnumeratorSizeFunc4CDC9E33Func == nil {
		rbEnumeratorSizeFunc4CDC9E33Func = x
	}
	return (*C.rb_enumerator_size_func)(C.rb_enumerator_size_func_4cdc9e33), nil
}

func NewRbEnumeratorSizeFuncRef(ref unsafe.Pointer) *RbEnumeratorSizeFunc {
	return (*RbEnumeratorSizeFunc)(ref)
}

//export rbEnumeratorSizeFunc4CDC9E33
func rbEnumeratorSizeFunc4CDC9E33(crecv C.VALUE, cargv C.VALUE, ceobj C.VALUE) C.ulong {
	if rbEnumeratorSizeFunc4CDC9E33Func != nil {
		recv4cdc9e33 := (VALUE)(crecv)
		argv4cdc9e33 := (VALUE)(cargv)
		eobj4cdc9e33 := (VALUE)(ceobj)
		ret4cdc9e33 := rbEnumeratorSizeFunc4CDC9E33Func(recv4cdc9e33, argv4cdc9e33, eobj4cdc9e33)
		ret, _ := (C.ulong)(ret4cdc9e33), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var rbEnumeratorSizeFunc4CDC9E33Func RbEnumeratorSizeFunc

// allocRbArithmeticSequenceComponentsTMemory allocates memory for type C.rb_arithmetic_sequence_components_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRbArithmeticSequenceComponentsTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRbArithmeticSequenceComponentsTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRbArithmeticSequenceComponentsTValue = unsafe.Sizeof([1]C.rb_arithmetic_sequence_components_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RbArithmeticSequenceComponentsT) Ref() *C.rb_arithmetic_sequence_components_t {
	if x == nil {
		return nil
	}
	return x.ref2cde3a4a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RbArithmeticSequenceComponentsT) Free() {
	if x != nil && x.allocs2cde3a4a != nil {
		x.allocs2cde3a4a.(*cgoAllocMap).Free()
		x.ref2cde3a4a = nil
	}
}

// NewRbArithmeticSequenceComponentsTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRbArithmeticSequenceComponentsTRef(ref unsafe.Pointer) *RbArithmeticSequenceComponentsT {
	if ref == nil {
		return nil
	}
	obj := new(RbArithmeticSequenceComponentsT)
	obj.ref2cde3a4a = (*C.rb_arithmetic_sequence_components_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RbArithmeticSequenceComponentsT) PassRef() (*C.rb_arithmetic_sequence_components_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2cde3a4a != nil {
		return x.ref2cde3a4a, nil
	}
	mem2cde3a4a := allocRbArithmeticSequenceComponentsTMemory(1)
	ref2cde3a4a := (*C.rb_arithmetic_sequence_components_t)(mem2cde3a4a)
	allocs2cde3a4a := new(cgoAllocMap)
	allocs2cde3a4a.Add(mem2cde3a4a)

	var cbegin_allocs *cgoAllocMap
	ref2cde3a4a.begin, cbegin_allocs = (C.VALUE)(x.Begin), cgoAllocsUnknown
	allocs2cde3a4a.Borrow(cbegin_allocs)

	var cend_allocs *cgoAllocMap
	ref2cde3a4a.end, cend_allocs = (C.VALUE)(x.End), cgoAllocsUnknown
	allocs2cde3a4a.Borrow(cend_allocs)

	var cstep_allocs *cgoAllocMap
	ref2cde3a4a.step, cstep_allocs = (C.VALUE)(x.Step), cgoAllocsUnknown
	allocs2cde3a4a.Borrow(cstep_allocs)

	var cexclude_end_allocs *cgoAllocMap
	ref2cde3a4a.exclude_end, cexclude_end_allocs = (C.int)(x.ExcludeEnd), cgoAllocsUnknown
	allocs2cde3a4a.Borrow(cexclude_end_allocs)

	x.ref2cde3a4a = ref2cde3a4a
	x.allocs2cde3a4a = allocs2cde3a4a
	return ref2cde3a4a, allocs2cde3a4a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RbArithmeticSequenceComponentsT) PassValue() (C.rb_arithmetic_sequence_components_t, *cgoAllocMap) {
	if x.ref2cde3a4a != nil {
		return *x.ref2cde3a4a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RbArithmeticSequenceComponentsT) Deref() {
	if x.ref2cde3a4a == nil {
		return
	}
	x.Begin = (VALUE)(x.ref2cde3a4a.begin)
	x.End = (VALUE)(x.ref2cde3a4a.end)
	x.Step = (VALUE)(x.ref2cde3a4a.step)
	x.ExcludeEnd = (int32)(x.ref2cde3a4a.exclude_end)
}

func (x RbHashUpdateFunc) PassRef() (ref *C.rb_hash_update_func, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rbHashUpdateFunc786399F4Func == nil {
		rbHashUpdateFunc786399F4Func = x
	}
	return (*C.rb_hash_update_func)(C.rb_hash_update_func_786399f4), nil
}

func NewRbHashUpdateFuncRef(ref unsafe.Pointer) *RbHashUpdateFunc {
	return (*RbHashUpdateFunc)(ref)
}

//export rbHashUpdateFunc786399F4
func rbHashUpdateFunc786399F4(cnewkey C.VALUE, coldkey C.VALUE, cvalue C.VALUE) C.ulong {
	if rbHashUpdateFunc786399F4Func != nil {
		newkey786399f4 := (VALUE)(cnewkey)
		oldkey786399f4 := (VALUE)(coldkey)
		value786399f4 := (VALUE)(cvalue)
		ret786399f4 := rbHashUpdateFunc786399F4Func(newkey786399f4, oldkey786399f4, value786399f4)
		ret, _ := (C.ulong)(ret786399f4), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var rbHashUpdateFunc786399F4Func RbHashUpdateFunc

// allocRbFdsetTMemory allocates memory for type C.rb_fdset_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRbFdsetTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRbFdsetTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfRbFdsetTValue = unsafe.Sizeof([1]C.rb_fdset_t{})

// unpackSFdSet transforms a sliced Go data structure into plain C format.
func unpackSFdSet(x []FdSet) (unpacked *C.fd_set, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocFdSetMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fd_set)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fd_set)(h.Data)
	return
}

// packSFdSet reads sliced Go data structure out from plain C format.
func packSFdSet(v []FdSet, ptr0 *C.fd_set) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFdSetValue]C.fd_set)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFdSetRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RbFdsetT) Ref() *C.rb_fdset_t {
	if x == nil {
		return nil
	}
	return x.ref1f9fe814
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RbFdsetT) Free() {
	if x != nil && x.allocs1f9fe814 != nil {
		x.allocs1f9fe814.(*cgoAllocMap).Free()
		x.ref1f9fe814 = nil
	}
}

// NewRbFdsetTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRbFdsetTRef(ref unsafe.Pointer) *RbFdsetT {
	if ref == nil {
		return nil
	}
	obj := new(RbFdsetT)
	obj.ref1f9fe814 = (*C.rb_fdset_t)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RbFdsetT) PassRef() (*C.rb_fdset_t, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1f9fe814 != nil {
		return x.ref1f9fe814, nil
	}
	mem1f9fe814 := allocRbFdsetTMemory(1)
	ref1f9fe814 := (*C.rb_fdset_t)(mem1f9fe814)
	allocs1f9fe814 := new(cgoAllocMap)
	allocs1f9fe814.Add(mem1f9fe814)

	var cmaxfd_allocs *cgoAllocMap
	ref1f9fe814.maxfd, cmaxfd_allocs = (C.int)(x.Maxfd), cgoAllocsUnknown
	allocs1f9fe814.Borrow(cmaxfd_allocs)

	var cfdset_allocs *cgoAllocMap
	ref1f9fe814.fdset, cfdset_allocs = unpackSFdSet(x.Fdset)
	allocs1f9fe814.Borrow(cfdset_allocs)

	x.ref1f9fe814 = ref1f9fe814
	x.allocs1f9fe814 = allocs1f9fe814
	return ref1f9fe814, allocs1f9fe814

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RbFdsetT) PassValue() (C.rb_fdset_t, *cgoAllocMap) {
	if x.ref1f9fe814 != nil {
		return *x.ref1f9fe814, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RbFdsetT) Deref() {
	if x.ref1f9fe814 == nil {
		return
	}
	x.Maxfd = (int32)(x.ref1f9fe814.maxfd)
	packSFdSet(x.Fdset, x.ref1f9fe814.fdset)
}

func (x RbUnblockFunctionT) PassRef() (ref *C.rb_unblock_function_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rbUnblockFunctionT5EB9B247Func == nil {
		rbUnblockFunctionT5EB9B247Func = x
	}
	return (*C.rb_unblock_function_t)(C.rb_unblock_function_t_5eb9b247), nil
}

func NewRbUnblockFunctionTRef(ref unsafe.Pointer) *RbUnblockFunctionT {
	return (*RbUnblockFunctionT)(ref)
}

//export rbUnblockFunctionT5EB9B247
func rbUnblockFunctionT5EB9B247(carg0 unsafe.Pointer) {
	if rbUnblockFunctionT5EB9B247Func != nil {
		arg05eb9b247 := (unsafe.Pointer)(unsafe.Pointer(carg0))
		rbUnblockFunctionT5EB9B247Func(arg05eb9b247)
		return
	}
	panic("callback func has not been set (race?)")
}

var rbUnblockFunctionT5EB9B247Func RbUnblockFunctionT

func (x RbBlockingFunctionT) PassRef() (ref *C.rb_blocking_function_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rbBlockingFunctionTA90BB1D3Func == nil {
		rbBlockingFunctionTA90BB1D3Func = x
	}
	return (*C.rb_blocking_function_t)(C.rb_blocking_function_t_a90bb1d3), nil
}

func NewRbBlockingFunctionTRef(ref unsafe.Pointer) *RbBlockingFunctionT {
	return (*RbBlockingFunctionT)(ref)
}

//export rbBlockingFunctionTA90BB1D3
func rbBlockingFunctionTA90BB1D3(carg0 unsafe.Pointer) C.ulong {
	if rbBlockingFunctionTA90BB1D3Func != nil {
		arg0a90bb1d3 := (unsafe.Pointer)(unsafe.Pointer(carg0))
		reta90bb1d3 := rbBlockingFunctionTA90BB1D3Func(arg0a90bb1d3)
		ret, _ := (C.ulong)(reta90bb1d3), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var rbBlockingFunctionTA90BB1D3Func RbBlockingFunctionT

func (x RbAllocFuncT) PassRef() (ref *C.rb_alloc_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rbAllocFuncT43DF300Func == nil {
		rbAllocFuncT43DF300Func = x
	}
	return (*C.rb_alloc_func_t)(C.rb_alloc_func_t_43df300), nil
}

func (x RbAllocFuncT) PassValue() (ref C.rb_alloc_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rbAllocFuncT43DF300Func == nil {
		rbAllocFuncT43DF300Func = x
	}
	return (C.rb_alloc_func_t)(C.rb_alloc_func_t_43df300), nil
}

func NewRbAllocFuncTRef(ref unsafe.Pointer) *RbAllocFuncT {
	return (*RbAllocFuncT)(ref)
}

//export rbAllocFuncT43DF300
func rbAllocFuncT43DF300(cklass C.VALUE) C.VALUE {
	if rbAllocFuncT43DF300Func != nil {
		klass43df300 := (VALUE)(cklass)
		ret43df300 := rbAllocFuncT43DF300Func(klass43df300)
		ret, _ := (C.VALUE)(ret43df300), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var rbAllocFuncT43DF300Func RbAllocFuncT

func (x RbBlockCallFunc) PassRef() (ref *C.rb_block_call_func, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rbBlockCallFuncD886170CFunc == nil {
		rbBlockCallFuncD886170CFunc = x
	}
	return (*C.rb_block_call_func)(C.rb_block_call_func_d886170c), nil
}

func NewRbBlockCallFuncRef(ref unsafe.Pointer) *RbBlockCallFunc {
	return (*RbBlockCallFunc)(ref)
}

//export rbBlockCallFuncD886170C
func rbBlockCallFuncD886170C(cyieldedArg C.VALUE, ccallbackArg C.VALUE, cargc C.int, cargv *C.VALUE, cblockarg C.VALUE) C.ulong {
	if rbBlockCallFuncD886170CFunc != nil {
		yieldedArgd886170c := (VALUE)(cyieldedArg)
		callbackArgd886170c := (VALUE)(ccallbackArg)
		argcd886170c := (int32)(cargc)
		var argvd886170c []VALUE
		hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&argvd886170c))
		hxf95e7c8.Data = unsafe.Pointer(cargv)
		hxf95e7c8.Cap = 0x7fffffff
		// hxf95e7c8.Len = ?

		blockargd886170c := (VALUE)(cblockarg)
		retd886170c := rbBlockCallFuncD886170CFunc(yieldedArgd886170c, callbackArgd886170c, argcd886170c, argvd886170c, blockargd886170c)
		ret, _ := (C.ulong)(retd886170c), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var rbBlockCallFuncD886170CFunc RbBlockCallFunc

func (x RbBlockCallFuncT) PassRef() (ref *C.rb_block_call_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rbBlockCallFuncT4F4F40CFunc == nil {
		rbBlockCallFuncT4F4F40CFunc = x
	}
	return (*C.rb_block_call_func_t)(C.rb_block_call_func_t_4f4f40c), nil
}

func (x RbBlockCallFuncT) PassValue() (ref C.rb_block_call_func_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rbBlockCallFuncT4F4F40CFunc == nil {
		rbBlockCallFuncT4F4F40CFunc = x
	}
	return (C.rb_block_call_func_t)(C.rb_block_call_func_t_4f4f40c), nil
}

func NewRbBlockCallFuncTRef(ref unsafe.Pointer) *RbBlockCallFuncT {
	return (*RbBlockCallFuncT)(ref)
}

//export rbBlockCallFuncT4F4F40C
func rbBlockCallFuncT4F4F40C(cyieldedArg C.VALUE, ccallbackArg C.VALUE, cargc C.int, cargv *C.VALUE, cblockarg C.VALUE) C.ulong {
	if rbBlockCallFuncT4F4F40CFunc != nil {
		yieldedArg4f4f40c := (VALUE)(cyieldedArg)
		callbackArg4f4f40c := (VALUE)(ccallbackArg)
		argc4f4f40c := (int32)(cargc)
		var argv4f4f40c []VALUE
		hxff2234b := (*sliceHeader)(unsafe.Pointer(&argv4f4f40c))
		hxff2234b.Data = unsafe.Pointer(cargv)
		hxff2234b.Cap = 0x7fffffff
		// hxff2234b.Len = ?

		blockarg4f4f40c := (VALUE)(cblockarg)
		ret4f4f40c := rbBlockCallFuncT4F4F40CFunc(yieldedArg4f4f40c, callbackArg4f4f40c, argc4f4f40c, argv4f4f40c, blockarg4f4f40c)
		ret, _ := (C.ulong)(ret4f4f40c), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var rbBlockCallFuncT4F4F40CFunc RbBlockCallFuncT

func (x RbGvarGetterT) PassRef() (ref *C.rb_gvar_getter_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rbGvarGetterTF727B057Func == nil {
		rbGvarGetterTF727B057Func = x
	}
	return (*C.rb_gvar_getter_t)(C.rb_gvar_getter_t_f727b057), nil
}

func NewRbGvarGetterTRef(ref unsafe.Pointer) *RbGvarGetterT {
	return (*RbGvarGetterT)(ref)
}

//export rbGvarGetterTF727B057
func rbGvarGetterTF727B057(cid C.ID, cdata *C.VALUE) C.ulong {
	if rbGvarGetterTF727B057Func != nil {
		idf727b057 := (ID)(cid)
		var dataf727b057 []VALUE
		hxff73280 := (*sliceHeader)(unsafe.Pointer(&dataf727b057))
		hxff73280.Data = unsafe.Pointer(cdata)
		hxff73280.Cap = 0x7fffffff
		// hxff73280.Len = ?

		retf727b057 := rbGvarGetterTF727B057Func(idf727b057, dataf727b057)
		ret, _ := (C.ulong)(retf727b057), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var rbGvarGetterTF727B057Func RbGvarGetterT

func (x RbGvarSetterT) PassRef() (ref *C.rb_gvar_setter_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rbGvarSetterTFD68F86Func == nil {
		rbGvarSetterTFD68F86Func = x
	}
	return (*C.rb_gvar_setter_t)(C.rb_gvar_setter_t_fd68f86), nil
}

func NewRbGvarSetterTRef(ref unsafe.Pointer) *RbGvarSetterT {
	return (*RbGvarSetterT)(ref)
}

//export rbGvarSetterTFD68F86
func rbGvarSetterTFD68F86(cval C.VALUE, cid C.ID, cdata *C.VALUE) {
	if rbGvarSetterTFD68F86Func != nil {
		valfd68f86 := (VALUE)(cval)
		idfd68f86 := (ID)(cid)
		var datafd68f86 []VALUE
		hxfa9955c := (*sliceHeader)(unsafe.Pointer(&datafd68f86))
		hxfa9955c.Data = unsafe.Pointer(cdata)
		hxfa9955c.Cap = 0x7fffffff
		// hxfa9955c.Len = ?

		rbGvarSetterTFD68F86Func(valfd68f86, idfd68f86, datafd68f86)
		return
	}
	panic("callback func has not been set (race?)")
}

var rbGvarSetterTFD68F86Func RbGvarSetterT

func (x RbGvarMarkerT) PassRef() (ref *C.rb_gvar_marker_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if rbGvarMarkerTA6416BC2Func == nil {
		rbGvarMarkerTA6416BC2Func = x
	}
	return (*C.rb_gvar_marker_t)(C.rb_gvar_marker_t_a6416bc2), nil
}

func NewRbGvarMarkerTRef(ref unsafe.Pointer) *RbGvarMarkerT {
	return (*RbGvarMarkerT)(ref)
}

//export rbGvarMarkerTA6416BC2
func rbGvarMarkerTA6416BC2(c_var *C.VALUE) {
	if rbGvarMarkerTA6416BC2Func != nil {
		var _vara6416bc2 []VALUE
		hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&_vara6416bc2))
		hxfa3f05c.Data = unsafe.Pointer(c_var)
		hxfa3f05c.Cap = 0x7fffffff
		// hxfa3f05c.Len = ?

		rbGvarMarkerTA6416BC2Func(_vara6416bc2)
		return
	}
	panic("callback func has not been set (race?)")
}

var rbGvarMarkerTA6416BC2Func RbGvarMarkerT

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	str = safeString(str)
	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

// copyPPointerBytes copies the data from Go slice as *unsafe.Pointer.
func copyPPointerBytes(slice *sliceHeader) (*unsafe.Pointer, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfPointerValue) * slice.Len,
		Cap:  int(sizeOfPointerValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*unsafe.Pointer)(mem0), allocs
}

// allocPointerMemory allocates memory for type unsafe.Pointer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPointerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPointerValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPointerValue = unsafe.Sizeof([1]unsafe.Pointer{})

// copyPVALUEBytes copies the data from Go slice as *C.VALUE.
func copyPVALUEBytes(slice *sliceHeader) (*C.VALUE, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfVALUEValue) * slice.Len,
		Cap:  int(sizeOfVALUEValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.VALUE)(mem0), allocs
}

// allocVALUEMemory allocates memory for type C.VALUE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVALUEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVALUEValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfVALUEValue = unsafe.Sizeof([1]C.VALUE{})

// unpackArgSRbDataTypeT transforms a sliced Go data structure into plain C format.
func unpackArgSRbDataTypeT(x []RbDataTypeT) (unpacked *C.rb_data_type_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocRbDataTypeTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.rb_data_type_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.rb_data_type_t)(h.Data)
	return
}

// copyPIDBytes copies the data from Go slice as *C.ID.
func copyPIDBytes(slice *sliceHeader) (*C.ID, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfIDValue) * slice.Len,
		Cap:  int(sizeOfIDValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.ID)(mem0), allocs
}

// allocIDMemory allocates memory for type C.ID in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIDMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIDValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfIDValue = unsafe.Sizeof([1]C.ID{})

// copyPUlongBytes copies the data from Go slice as *C.ulong.
func copyPUlongBytes(slice *sliceHeader) (*C.ulong, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUlongValue) * slice.Len,
		Cap:  int(sizeOfUlongValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.ulong)(mem0), allocs
}

// allocUlongMemory allocates memory for type C.ulong in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUlongMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUlongValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUlongValue = unsafe.Sizeof([1]C.ulong{})

// copyPIntBytes copies the data from Go slice as *C.int.
func copyPIntBytes(slice *sliceHeader) (*C.int, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfIntValue) * slice.Len,
		Cap:  int(sizeOfIntValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.int)(mem0), allocs
}

// allocIntMemory allocates memory for type C.int in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIntMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIntValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfIntValue = unsafe.Sizeof([1]C.int{})

// copyPSizeTBytes copies the data from Go slice as *C.size_t.
func copyPSizeTBytes(slice *sliceHeader) (*C.size_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSizeTValue) * slice.Len,
		Cap:  int(sizeOfSizeTValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.size_t)(mem0), allocs
}

// allocSizeTMemory allocates memory for type C.size_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSizeTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSizeTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSizeTValue = unsafe.Sizeof([1]C.size_t{})

// unpackArgSRbArithmeticSequenceComponentsT transforms a sliced Go data structure into plain C format.
func unpackArgSRbArithmeticSequenceComponentsT(x []RbArithmeticSequenceComponentsT) (unpacked *C.rb_arithmetic_sequence_components_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocRbArithmeticSequenceComponentsTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.rb_arithmetic_sequence_components_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.rb_arithmetic_sequence_components_t)(h.Data)
	return
}

// packSRbArithmeticSequenceComponentsT reads sliced Go data structure out from plain C format.
func packSRbArithmeticSequenceComponentsT(v []RbArithmeticSequenceComponentsT, ptr0 *C.rb_arithmetic_sequence_components_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRbArithmeticSequenceComponentsTValue]C.rb_arithmetic_sequence_components_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRbArithmeticSequenceComponentsTRef(unsafe.Pointer(&ptr1))
	}
}

// copyPLongBytes copies the data from Go slice as *C.long.
func copyPLongBytes(slice *sliceHeader) (*C.long, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfLongValue) * slice.Len,
		Cap:  int(sizeOfLongValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.long)(mem0), allocs
}

// allocLongMemory allocates memory for type C.long in C.
// The caller is responsible for freeing the this memory via C.free.
func allocLongMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfLongValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfLongValue = unsafe.Sizeof([1]C.long{})

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackArgSString transforms a sliced Go data structure into plain C format.
func unpackArgSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// unpackArgSRbFdsetT transforms a sliced Go data structure into plain C format.
func unpackArgSRbFdsetT(x []RbFdsetT) (unpacked *C.rb_fdset_t, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocRbFdsetTMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.rb_fdset_t)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.rb_fdset_t)(h.Data)
	return
}

// packSRbFdsetT reads sliced Go data structure out from plain C format.
func packSRbFdsetT(v []RbFdsetT, ptr0 *C.rb_fdset_t) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfRbFdsetTValue]C.rb_fdset_t)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewRbFdsetTRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSFdSet transforms a sliced Go data structure into plain C format.
func unpackArgSFdSet(x []FdSet) (unpacked *C.fd_set, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocFdSetMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fd_set)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fd_set)(h.Data)
	return
}

// allocPVALUEMemory allocates memory for type *C.VALUE in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPVALUEMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPVALUEValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPVALUEValue = unsafe.Sizeof([1]*C.VALUE{})

// unpackArgSSUVALUE transforms a sliced Go data structure into plain C format.
func unpackArgSSUVALUE(x [][]VALUE) (unpacked **C.VALUE, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPVALUEMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.VALUE)(unsafe.Pointer(h0))
	for i0 := range x {
		h := (*sliceHeader)(unsafe.Pointer(&x[i0]))
		v0[i0] = (*C.VALUE)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.VALUE)(h.Data)
	return
}

// packSSUVALUE reads sliced Go data structure out from plain C format.
func packSSUVALUE(v [][]VALUE, ptr0 **C.VALUE) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.VALUE)(unsafe.Pointer(ptr0)))[i0]
		hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxf0d18b7.Data = unsafe.Pointer(ptr1)
		hxf0d18b7.Cap = 0x7fffffff
		// hxf0d18b7.Len = ?
	}
}
