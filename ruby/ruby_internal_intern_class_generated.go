// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated
// Code generated by ruby_h_to_go. DO NOT EDIT.

package ruby

/*
#include "ruby.h"
*/
import "C"

import (
	"unsafe"
)

// RbCheckInheritable calls `rb_check_inheritable` in C
//
// Original definition is following
//
//	void rb_check_inheritable(VALUE super)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbCheckInheritable(super VALUE) {
	C.rb_check_inheritable(C.VALUE(super))
}

// RbClassAttachedObject calls `rb_class_attached_object` in C
//
// Original definition is following
//
//	VALUE rb_class_attached_object(VALUE klass)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbClassAttachedObject(klass VALUE) VALUE {
	ret := VALUE(C.rb_class_attached_object(C.VALUE(klass)))
	return ret
}

// RbClassDescendants calls `rb_class_descendants` in C
//
// Original definition is following
//
//	VALUE rb_class_descendants(VALUE klass)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbClassDescendants(klass VALUE) VALUE {
	ret := VALUE(C.rb_class_descendants(C.VALUE(klass)))
	return ret
}

// RbClassInstanceMethods calls `rb_class_instance_methods` in C
//
// Original definition is following
//
//	VALUE rb_class_instance_methods(int argc, const VALUE *argv, VALUE mod)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbClassInstanceMethods(argc int, argv *VALUE, mod VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_class_instance_methods(C.int(argc), &cArgv, C.VALUE(mod)))
	*argv = VALUE(cArgv)
	return ret
}

// RbClassPrivateInstanceMethods calls `rb_class_private_instance_methods` in C
//
// Original definition is following
//
//	VALUE rb_class_private_instance_methods(int argc, const VALUE *argv, VALUE mod)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbClassPrivateInstanceMethods(argc int, argv *VALUE, mod VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_class_private_instance_methods(C.int(argc), &cArgv, C.VALUE(mod)))
	*argv = VALUE(cArgv)
	return ret
}

// RbClassProtectedInstanceMethods calls `rb_class_protected_instance_methods` in C
//
// Original definition is following
//
//	VALUE rb_class_protected_instance_methods(int argc, const VALUE *argv, VALUE mod)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbClassProtectedInstanceMethods(argc int, argv *VALUE, mod VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_class_protected_instance_methods(C.int(argc), &cArgv, C.VALUE(mod)))
	*argv = VALUE(cArgv)
	return ret
}

// RbClassPublicInstanceMethods calls `rb_class_public_instance_methods` in C
//
// Original definition is following
//
//	VALUE rb_class_public_instance_methods(int argc, const VALUE *argv, VALUE mod)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbClassPublicInstanceMethods(argc int, argv *VALUE, mod VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_class_public_instance_methods(C.int(argc), &cArgv, C.VALUE(mod)))
	*argv = VALUE(cArgv)
	return ret
}

// RbClassSubclasses calls `rb_class_subclasses` in C
//
// Original definition is following
//
//	VALUE rb_class_subclasses(VALUE klass)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbClassSubclasses(klass VALUE) VALUE {
	ret := VALUE(C.rb_class_subclasses(C.VALUE(klass)))
	return ret
}

// RbDefineClassId calls `rb_define_class_id` in C
//
// Original definition is following
//
//	VALUE rb_define_class_id(ID id, VALUE super)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbDefineClassId(id ID, super VALUE) VALUE {
	ret := VALUE(C.rb_define_class_id(C.ID(id), C.VALUE(super)))
	return ret
}

// RbDefineClassIdUnder calls `rb_define_class_id_under` in C
//
// Original definition is following
//
//	VALUE rb_define_class_id_under(VALUE outer, ID id, VALUE super)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbDefineClassIdUnder(outer VALUE, id ID, super VALUE) VALUE {
	ret := VALUE(C.rb_define_class_id_under(C.VALUE(outer), C.ID(id), C.VALUE(super)))
	return ret
}

// RbDefineMethodId calls `rb_define_method_id` in C
//
// Original definition is following
//
//	void rb_define_method_id(VALUE klass, ID mid, VALUE (*func)(ANYARGS), int arity)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbDefineMethodId(klass VALUE, mid ID, arg3 unsafe.Pointer, arity int) {
	C.rb_define_method_id(C.VALUE(klass), C.ID(mid), toCPointer(arg3), C.int(arity))
}

// RbDefineModuleId calls `rb_define_module_id` in C
//
// Original definition is following
//
//	VALUE rb_define_module_id(ID id)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbDefineModuleId(id ID) VALUE {
	ret := VALUE(C.rb_define_module_id(C.ID(id)))
	return ret
}

// RbDefineModuleIdUnder calls `rb_define_module_id_under` in C
//
// Original definition is following
//
//	VALUE rb_define_module_id_under(VALUE outer, ID id)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbDefineModuleIdUnder(outer VALUE, id ID) VALUE {
	ret := VALUE(C.rb_define_module_id_under(C.VALUE(outer), C.ID(id)))
	return ret
}

// RbDefinePrivateMethod calls `rb_define_private_method` in C
//
// Original definition is following
//
//	void rb_define_private_method(VALUE klass, const char *mid, VALUE (*func)(ANYARGS), int arity)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbDefinePrivateMethod(klass VALUE, mid string, arg3 unsafe.Pointer, arity int) {
	char, clean := string2Char(mid)
	defer clean()

	C.rb_define_private_method(C.VALUE(klass), char, toCPointer(arg3), C.int(arity))
}

// RbDefineProtectedMethod calls `rb_define_protected_method` in C
//
// Original definition is following
//
//	void rb_define_protected_method(VALUE klass, const char *mid, VALUE (*func)(ANYARGS), int arity)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbDefineProtectedMethod(klass VALUE, mid string, arg3 unsafe.Pointer, arity int) {
	char, clean := string2Char(mid)
	defer clean()

	C.rb_define_protected_method(C.VALUE(klass), char, toCPointer(arg3), C.int(arity))
}

// RbDefineSingletonMethod calls `rb_define_singleton_method` in C
//
// Original definition is following
//
//	void rb_define_singleton_method(VALUE obj, const char *mid, VALUE(*func)(ANYARGS), int arity)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbDefineSingletonMethod(obj VALUE, mid string, arg3 unsafe.Pointer, arity int) {
	char, clean := string2Char(mid)
	defer clean()

	C.rb_define_singleton_method(C.VALUE(obj), char, toCPointer(arg3), C.int(arity))
}

// RbModAncestors calls `rb_mod_ancestors` in C
//
// Original definition is following
//
//	VALUE rb_mod_ancestors(VALUE mod)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbModAncestors(mod VALUE) VALUE {
	ret := VALUE(C.rb_mod_ancestors(C.VALUE(mod)))
	return ret
}

// RbModIncludeP calls `rb_mod_include_p` in C
//
// Original definition is following
//
//	VALUE rb_mod_include_p(VALUE child, VALUE parent)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbModIncludeP(child VALUE, parent VALUE) VALUE {
	ret := VALUE(C.rb_mod_include_p(C.VALUE(child), C.VALUE(parent)))
	return ret
}

// RbModIncludedModules calls `rb_mod_included_modules` in C
//
// Original definition is following
//
//	VALUE rb_mod_included_modules(VALUE mod)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbModIncludedModules(mod VALUE) VALUE {
	ret := VALUE(C.rb_mod_included_modules(C.VALUE(mod)))
	return ret
}

// RbModInitCopy calls `rb_mod_init_copy` in C
//
// Original definition is following
//
//	VALUE rb_mod_init_copy(VALUE clone, VALUE orig)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbModInitCopy(clone VALUE, orig VALUE) VALUE {
	ret := VALUE(C.rb_mod_init_copy(C.VALUE(clone), C.VALUE(orig)))
	return ret
}

// RbModuleNew calls `rb_module_new` in C
//
// Original definition is following
//
//	VALUE rb_module_new(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbModuleNew() VALUE {
	ret := VALUE(C.rb_module_new())
	return ret
}

// RbObjSingletonMethods calls `rb_obj_singleton_methods` in C
//
// Original definition is following
//
//	VALUE rb_obj_singleton_methods(int argc, const VALUE *argv, VALUE obj)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbObjSingletonMethods(argc int, argv *VALUE, obj VALUE) VALUE {
	var cArgv C.VALUE
	ret := VALUE(C.rb_obj_singleton_methods(C.int(argc), &cArgv, C.VALUE(obj)))
	*argv = VALUE(cArgv)
	return ret
}

// RbRefinementNew calls `rb_refinement_new` in C
//
// Original definition is following
//
//	VALUE rb_refinement_new(void)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbRefinementNew() VALUE {
	ret := VALUE(C.rb_refinement_new())
	return ret
}

// RbSingletonClass calls `rb_singleton_class` in C
//
// Original definition is following
//
//	VALUE rb_singleton_class(VALUE obj)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbSingletonClass(obj VALUE) VALUE {
	ret := VALUE(C.rb_singleton_class(C.VALUE(obj)))
	return ret
}

// RbUndef calls `rb_undef` in C
//
// Original definition is following
//
//	void rb_undef(VALUE mod, ID mid)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/class.h
func RbUndef(mod VALUE, mid ID) {
	C.rb_undef(C.VALUE(mod), C.ID(mid))
}
