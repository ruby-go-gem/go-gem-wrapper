// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package ruby

/*
#include "ruby.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"unsafe"
)

// RbAssertFailure function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/ruby/assert.h
func RbAssertFailure(file string, line int32, name string, expr string) {
	file = safeString(file)
	cfile, cfileAllocMap := unpackPCharString(file)
	cline, clineAllocMap := (C.int)(line), cgoAllocsUnknown
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	expr = safeString(expr)
	cexpr, cexprAllocMap := unpackPCharString(expr)
	C.rb_assert_failure(cfile, cline, cname, cexpr)
	runtime.KeepAlive(expr)
	runtime.KeepAlive(cexprAllocMap)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(clineAllocMap)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cfileAllocMap)
}

// RbClearConstantCache function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/ruby/backward.h
func RbClearConstantCache() {
	C.rb_clear_constant_cache()
}

// RB_CHR2FIX function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/char.h
func RB_CHR2FIX(c byte) VALUE {
	cc, ccAllocMap := (C.uchar)(c), cgoAllocsUnknown
	__ret := C.RB_CHR2FIX(cc)
	runtime.KeepAlive(ccAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbNum2charInline function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/char.h
func RbNum2charInline(x VALUE) byte {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	__ret := C.rb_num2char_inline(cx)
	runtime.KeepAlive(cxAllocMap)
	__v := (byte)(__ret)
	return __v
}

// RbNum2dbl function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/double.h
func RbNum2dbl(num VALUE) float64 {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	__ret := C.rb_num2dbl(cnum)
	runtime.KeepAlive(cnumAllocMap)
	__v := (float64)(__ret)
	return __v
}

// RbFloatValue function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/double.h
func RbFloatValue(num VALUE) float64 {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	__ret := C.rb_float_value(cnum)
	runtime.KeepAlive(cnumAllocMap)
	__v := (float64)(__ret)
	return __v
}

// RbFloatNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/double.h
func RbFloatNew(d float64) VALUE {
	cd, cdAllocMap := (C.double)(d), cgoAllocsUnknown
	__ret := C.rb_float_new(cd)
	runtime.KeepAlive(cdAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFloatNewInHeap function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/double.h
func RbFloatNewInHeap(d float64) VALUE {
	cd, cdAllocMap := (C.double)(d), cgoAllocsUnknown
	__ret := C.rb_float_new_in_heap(cd)
	runtime.KeepAlive(cdAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbNum2int function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/int.h
func RbNum2int(num VALUE) int64 {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	__ret := C.rb_num2int(cnum)
	runtime.KeepAlive(cnumAllocMap)
	__v := (int64)(__ret)
	return __v
}

// RbFix2int function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/int.h
func RbFix2int(num VALUE) int64 {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	__ret := C.rb_fix2int(cnum)
	runtime.KeepAlive(cnumAllocMap)
	__v := (int64)(__ret)
	return __v
}

// RbNum2uint function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/int.h
func RbNum2uint(num VALUE) uint64 {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	__ret := C.rb_num2uint(cnum)
	runtime.KeepAlive(cnumAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbFix2uint function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/int.h
func RbFix2uint(num VALUE) uint64 {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	__ret := C.rb_fix2uint(cnum)
	runtime.KeepAlive(cnumAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RB_FIX2INT function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/int.h
func RB_FIX2INT(x VALUE) int32 {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	__ret := C.RB_FIX2INT(cx)
	runtime.KeepAlive(cxAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbNum2intInline function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/int.h
func RbNum2intInline(x VALUE) int32 {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	__ret := C.rb_num2int_inline(cx)
	runtime.KeepAlive(cxAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RB_NUM2UINT function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/int.h
func RB_NUM2UINT(x VALUE) uint32 {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	__ret := C.RB_NUM2UINT(cx)
	runtime.KeepAlive(cxAllocMap)
	__v := (uint32)(__ret)
	return __v
}

// RB_FIX2UINT function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/int.h
func RB_FIX2UINT(x VALUE) uint32 {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	__ret := C.RB_FIX2UINT(cx)
	runtime.KeepAlive(cxAllocMap)
	__v := (uint32)(__ret)
	return __v
}

// RbInt2numInline function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/int.h
func RbInt2numInline(v int32) VALUE {
	cv, cvAllocMap := (C.int)(v), cgoAllocsUnknown
	__ret := C.rb_int2num_inline(cv)
	runtime.KeepAlive(cvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbUint2numInline function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/int.h
func RbUint2numInline(v uint32) VALUE {
	cv, cvAllocMap := (C.uint)(v), cgoAllocsUnknown
	__ret := C.rb_uint2num_inline(cv)
	runtime.KeepAlive(cvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbInt2big function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/intptr_t.h
func RbInt2big(i int64) VALUE {
	ci, ciAllocMap := (C.intptr_t)(i), cgoAllocsUnknown
	__ret := C.rb_int2big(ci)
	runtime.KeepAlive(ciAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbInt2inum function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/intptr_t.h
func RbInt2inum(i int64) VALUE {
	ci, ciAllocMap := (C.intptr_t)(i), cgoAllocsUnknown
	__ret := C.rb_int2inum(ci)
	runtime.KeepAlive(ciAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbUint2big function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/intptr_t.h
func RbUint2big(i uint64) VALUE {
	ci, ciAllocMap := (C.uintptr_t)(i), cgoAllocsUnknown
	__ret := C.rb_uint2big(ci)
	runtime.KeepAlive(ciAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbUint2inum function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/intptr_t.h
func RbUint2inum(i uint64) VALUE {
	ci, ciAllocMap := (C.uintptr_t)(i), cgoAllocsUnknown
	__ret := C.rb_uint2inum(ci)
	runtime.KeepAlive(ciAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbOutOfInt function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/long.h
func RbOutOfInt(num int64) {
	cnum, cnumAllocMap := (C.long)(num), cgoAllocsUnknown
	C.rb_out_of_int(cnum)
	runtime.KeepAlive(cnumAllocMap)
}

// RbNum2long function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/long.h
func RbNum2long(num VALUE) int64 {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	__ret := C.rb_num2long(cnum)
	runtime.KeepAlive(cnumAllocMap)
	__v := (int64)(__ret)
	return __v
}

// RbNum2ulong function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/long.h
func RbNum2ulong(num VALUE) uint64 {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	__ret := C.rb_num2ulong(cnum)
	runtime.KeepAlive(cnumAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RB_INT2FIX function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/long.h
func RB_INT2FIX(i int64) VALUE {
	ci, ciAllocMap := (C.long)(i), cgoAllocsUnknown
	__ret := C.RB_INT2FIX(ci)
	runtime.KeepAlive(ciAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbLong2intInline function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/long.h
func RbLong2intInline(n int64) int32 {
	cn, cnAllocMap := (C.long)(n), cgoAllocsUnknown
	__ret := C.rb_long2int_inline(cn)
	runtime.KeepAlive(cnAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbFix2long function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/long.h
func RbFix2long(x VALUE) int64 {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	__ret := C.rb_fix2long(cx)
	runtime.KeepAlive(cxAllocMap)
	__v := (int64)(__ret)
	return __v
}

// RbFix2ulong function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/long.h
func RbFix2ulong(x VALUE) uint64 {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	__ret := C.rb_fix2ulong(cx)
	runtime.KeepAlive(cxAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbNum2longInline function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/long.h
func RbNum2longInline(x VALUE) int64 {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	__ret := C.rb_num2long_inline(cx)
	runtime.KeepAlive(cxAllocMap)
	__v := (int64)(__ret)
	return __v
}

// RbNum2ulongInline function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/long.h
func RbNum2ulongInline(x VALUE) uint64 {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	__ret := C.rb_num2ulong_inline(cx)
	runtime.KeepAlive(cxAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbLong2numInline function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/long.h
func RbLong2numInline(v int64) VALUE {
	cv, cvAllocMap := (C.long)(v), cgoAllocsUnknown
	__ret := C.rb_long2num_inline(cv)
	runtime.KeepAlive(cvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbUlong2numInline function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/long.h
func RbUlong2numInline(v uint64) VALUE {
	cv, cvAllocMap := (C.ulong)(v), cgoAllocsUnknown
	__ret := C.rb_ulong2num_inline(cv)
	runtime.KeepAlive(cvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbLl2inum function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/long_long.h
func RbLl2inum(num int64) VALUE {
	cnum, cnumAllocMap := (C.longlong)(num), cgoAllocsUnknown
	__ret := C.rb_ll2inum(cnum)
	runtime.KeepAlive(cnumAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbUll2inum function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/long_long.h
func RbUll2inum(num uint64) VALUE {
	cnum, cnumAllocMap := (C.ulonglong)(num), cgoAllocsUnknown
	__ret := C.rb_ull2inum(cnum)
	runtime.KeepAlive(cnumAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbNum2ll function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/long_long.h
func RbNum2ll(num VALUE) int64 {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	__ret := C.rb_num2ll(cnum)
	runtime.KeepAlive(cnumAllocMap)
	__v := (int64)(__ret)
	return __v
}

// RbNum2ull function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/long_long.h
func RbNum2ull(num VALUE) uint64 {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	__ret := C.rb_num2ull(cnum)
	runtime.KeepAlive(cnumAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbLl2numInline function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/long_long.h
func RbLl2numInline(n int64) VALUE {
	cn, cnAllocMap := (C.longlong)(n), cgoAllocsUnknown
	__ret := C.rb_ll2num_inline(cn)
	runtime.KeepAlive(cnAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbUll2numInline function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/long_long.h
func RbUll2numInline(n uint64) VALUE {
	cn, cnAllocMap := (C.ulonglong)(n), cgoAllocsUnknown
	__ret := C.rb_ull2num_inline(cn)
	runtime.KeepAlive(cnAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbNum2llInline function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/long_long.h
func RbNum2llInline(x VALUE) int64 {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	__ret := C.rb_num2ll_inline(cx)
	runtime.KeepAlive(cxAllocMap)
	__v := (int64)(__ret)
	return __v
}

// RbNum2ullInline function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/long_long.h
func RbNum2ullInline(x VALUE) uint64 {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	__ret := C.rb_num2ull_inline(cx)
	runtime.KeepAlive(cxAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbNum2short function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/short.h
func RbNum2short(num VALUE) int16 {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	__ret := C.rb_num2short(cnum)
	runtime.KeepAlive(cnumAllocMap)
	__v := (int16)(__ret)
	return __v
}

// RbNum2ushort function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/short.h
func RbNum2ushort(num VALUE) uint16 {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	__ret := C.rb_num2ushort(cnum)
	runtime.KeepAlive(cnumAllocMap)
	__v := (uint16)(__ret)
	return __v
}

// RbFix2short function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/short.h
func RbFix2short(num VALUE) int16 {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	__ret := C.rb_fix2short(cnum)
	runtime.KeepAlive(cnumAllocMap)
	__v := (int16)(__ret)
	return __v
}

// RbFix2ushort function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/short.h
func RbFix2ushort(num VALUE) uint16 {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	__ret := C.rb_fix2ushort(cnum)
	runtime.KeepAlive(cnumAllocMap)
	__v := (uint16)(__ret)
	return __v
}

// RbNum2shortInline function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/short.h
func RbNum2shortInline(x VALUE) int16 {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	__ret := C.rb_num2short_inline(cx)
	runtime.KeepAlive(cxAllocMap)
	__v := (int16)(__ret)
	return __v
}

// RB_ST2FIX function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/arithmetic/st_data_t.h
func RB_ST2FIX(i uint64) VALUE {
	ci, ciAllocMap := (C.st_data_t)(i), cgoAllocsUnknown
	__ret := C.RB_ST2FIX(ci)
	runtime.KeepAlive(ciAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryPtrUseStart function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rarray.h
func RbAryPtrUseStart(ary VALUE) *VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	__ret := C.rb_ary_ptr_use_start(cary)
	runtime.KeepAlive(caryAllocMap)
	__v := *(**VALUE)(unsafe.Pointer(&__ret))
	return __v
}

// RbAryPtrUseEnd function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rarray.h
func RbAryPtrUseEnd(a VALUE) {
	ca, caAllocMap := (C.VALUE)(a), cgoAllocsUnknown
	C.rb_ary_ptr_use_end(ca)
	runtime.KeepAlive(caAllocMap)
}

// RbArrayLen function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rarray.h
func RbArrayLen(a VALUE) int64 {
	ca, caAllocMap := (C.VALUE)(a), cgoAllocsUnknown
	__ret := C.rb_array_len(ca)
	runtime.KeepAlive(caAllocMap)
	__v := (int64)(__ret)
	return __v
}

// RbArrayConstPtr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rarray.h
func RbArrayConstPtr(a VALUE) *VALUE {
	ca, caAllocMap := (C.VALUE)(a), cgoAllocsUnknown
	__ret := C.rb_array_const_ptr(ca)
	runtime.KeepAlive(caAllocMap)
	__v := *(**VALUE)(unsafe.Pointer(&__ret))
	return __v
}

// RbObjHide function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rbasic.h
func RbObjHide(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_obj_hide(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjReveal function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rbasic.h
func RbObjReveal(obj VALUE, klass VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	__ret := C.rb_obj_reveal(cobj, cklass)
	runtime.KeepAlive(cklassAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBigSign function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rbignum.h
func RbBigSign(num VALUE) int32 {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	__ret := C.rb_big_sign(cnum)
	runtime.KeepAlive(cnumAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbClassGetSuperclass function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rclass.h
func RbClassGetSuperclass(klass VALUE) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	__ret := C.rb_class_get_superclass(cklass)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDataObjectWrap function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rdata.h
func RbDataObjectWrap(klass VALUE, datap unsafe.Pointer, dmark RUBYDATAFUNC, dfree RUBYDATAFUNC) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cdatap, cdatapAllocMap := datap, cgoAllocsUnknown
	cdmark, cdmarkAllocMap := dmark.PassValue()
	cdfree, cdfreeAllocMap := dfree.PassValue()
	__ret := C.rb_data_object_wrap(cklass, cdatap, cdmark, cdfree)
	runtime.KeepAlive(cdfreeAllocMap)
	runtime.KeepAlive(cdmarkAllocMap)
	runtime.KeepAlive(cdatapAllocMap)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDataObjectZalloc function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rdata.h
func RbDataObjectZalloc(klass VALUE, size uint64, dmark RUBYDATAFUNC, dfree RUBYDATAFUNC) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	csize, csizeAllocMap := (C.size_t)(size), cgoAllocsUnknown
	cdmark, cdmarkAllocMap := dmark.PassValue()
	cdfree, cdfreeAllocMap := dfree.PassValue()
	__ret := C.rb_data_object_zalloc(cklass, csize, cdmark, cdfree)
	runtime.KeepAlive(cdfreeAllocMap)
	runtime.KeepAlive(cdmarkAllocMap)
	runtime.KeepAlive(csizeAllocMap)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDataObjectWrapWarning function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rdata.h
func RbDataObjectWrapWarning(klass VALUE, ptr unsafe.Pointer, mark RUBYDATAFUNC, free RUBYDATAFUNC) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cptr, cptrAllocMap := ptr, cgoAllocsUnknown
	cmark, cmarkAllocMap := mark.PassValue()
	cfree, cfreeAllocMap := free.PassValue()
	__ret := C.rb_data_object_wrap_warning(cklass, cptr, cmark, cfree)
	runtime.KeepAlive(cfreeAllocMap)
	runtime.KeepAlive(cmarkAllocMap)
	runtime.KeepAlive(cptrAllocMap)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDataObjectGet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rdata.h
func RbDataObjectGet(obj VALUE) unsafe.Pointer {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_data_object_get(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// RbDataObjectGetWarning function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rdata.h
func RbDataObjectGetWarning(obj VALUE) unsafe.Pointer {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_data_object_get_warning(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// RbDataObjectMake function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rdata.h
func RbDataObjectMake(klass VALUE, markFunc RUBYDATAFUNC, freeFunc RUBYDATAFUNC, datap []unsafe.Pointer, size uint64) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cmarkFunc, cmarkFuncAllocMap := markFunc.PassValue()
	cfreeFunc, cfreeFuncAllocMap := freeFunc.PassValue()
	cdatap, cdatapAllocMap := (*unsafe.Pointer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&datap)).Data)), cgoAllocsUnknown
	csize, csizeAllocMap := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.rb_data_object_make(cklass, cmarkFunc, cfreeFunc, cdatap, csize)
	runtime.KeepAlive(csizeAllocMap)
	runtime.KeepAlive(cdatapAllocMap)
	runtime.KeepAlive(cfreeFuncAllocMap)
	runtime.KeepAlive(cmarkFuncAllocMap)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDataObjectAlloc function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rdata.h
func RbDataObjectAlloc(klass VALUE, data unsafe.Pointer, dmark RUBYDATAFUNC, dfree RUBYDATAFUNC) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cdata, cdataAllocMap := data, cgoAllocsUnknown
	cdmark, cdmarkAllocMap := dmark.PassValue()
	cdfree, cdfreeAllocMap := dfree.PassValue()
	__ret := C.rb_data_object_alloc(cklass, cdata, cdmark, cdfree)
	runtime.KeepAlive(cdfreeAllocMap)
	runtime.KeepAlive(cdmarkAllocMap)
	runtime.KeepAlive(cdataAllocMap)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbHashSizeNum function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/core/rhash.h
func RbHashSizeNum(hash VALUE) uint64 {
	chash, chashAllocMap := (C.VALUE)(hash), cgoAllocsUnknown
	__ret := C.rb_hash_size_num(chash)
	runtime.KeepAlive(chashAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbHashSetIfnone function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/core/rhash.h
func RbHashSetIfnone(hash VALUE, ifnone VALUE) VALUE {
	chash, chashAllocMap := (C.VALUE)(hash), cgoAllocsUnknown
	cifnone, cifnoneAllocMap := (C.VALUE)(ifnone), cgoAllocsUnknown
	__ret := C.rb_hash_set_ifnone(chash, cifnone)
	runtime.KeepAlive(cifnoneAllocMap)
	runtime.KeepAlive(chashAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrToStr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rstring.h
func RbStrToStr(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_str_to_str(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStringValue function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rstring.h
func RbStringValue(ptr []VALUE) VALUE {
	cptr, cptrAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ptr)).Data)), cgoAllocsUnknown
	__ret := C.rb_string_value(cptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStringValuePtr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rstring.h
func RbStringValuePtr(ptr []VALUE) *byte {
	cptr, cptrAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ptr)).Data)), cgoAllocsUnknown
	__ret := C.rb_string_value_ptr(cptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// RbStringValueCstr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rstring.h
func RbStringValueCstr(ptr []VALUE) *byte {
	cptr, cptrAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&ptr)).Data)), cgoAllocsUnknown
	__ret := C.rb_string_value_cstr(cptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// RbStrExport function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rstring.h
func RbStrExport(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_str_export(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrExportLocale function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rstring.h
func RbStrExportLocale(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_str_export_locale(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCheckSafeStr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rstring.h
func RbCheckSafeStr(arg0 VALUE) {
	carg0, carg0AllocMap := (C.VALUE)(arg0), cgoAllocsUnknown
	C.rb_check_safe_str(carg0)
	runtime.KeepAlive(carg0AllocMap)
}

// RbDebugRstringNullPtr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rstring.h
func RbDebugRstringNullPtr(_func string) {
	_func = safeString(_func)
	c_func, c_funcAllocMap := unpackPCharString(_func)
	C.rb_debug_rstring_null_ptr(c_func)
	runtime.KeepAlive(_func)
	runtime.KeepAlive(c_funcAllocMap)
}

// RSTRING_LEN function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rstring.h
func RSTRING_LEN(str VALUE) int64 {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.RSTRING_LEN(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := (int64)(__ret)
	return __v
}

// RSTRING_PTR function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rstring.h
func RSTRING_PTR(str VALUE) *byte {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.RSTRING_PTR(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// RSTRING_END function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rstring.h
func RSTRING_END(str VALUE) *byte {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.RSTRING_END(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// RSTRING_LENINT function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rstring.h
func RSTRING_LENINT(str VALUE) int32 {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.RSTRING_LENINT(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbStructSize function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rstruct.h
func RbStructSize(st VALUE) VALUE {
	cst, cstAllocMap := (C.VALUE)(st), cgoAllocsUnknown
	__ret := C.rb_struct_size(cst)
	runtime.KeepAlive(cstAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStructAref function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rstruct.h
func RbStructAref(st VALUE, k VALUE) VALUE {
	cst, cstAllocMap := (C.VALUE)(st), cgoAllocsUnknown
	ck, ckAllocMap := (C.VALUE)(k), cgoAllocsUnknown
	__ret := C.rb_struct_aref(cst, ck)
	runtime.KeepAlive(ckAllocMap)
	runtime.KeepAlive(cstAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStructAset function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rstruct.h
func RbStructAset(st VALUE, k VALUE, v VALUE) VALUE {
	cst, cstAllocMap := (C.VALUE)(st), cgoAllocsUnknown
	ck, ckAllocMap := (C.VALUE)(k), cgoAllocsUnknown
	cv, cvAllocMap := (C.VALUE)(v), cgoAllocsUnknown
	__ret := C.rb_struct_aset(cst, ck, cv)
	runtime.KeepAlive(cvAllocMap)
	runtime.KeepAlive(ckAllocMap)
	runtime.KeepAlive(cstAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDataTypedObjectWrap function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rtypeddata.h
func RbDataTypedObjectWrap(klass VALUE, datap unsafe.Pointer, kind []RbDataTypeT) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cdatap, cdatapAllocMap := datap, cgoAllocsUnknown
	ckind, ckindAllocMap := unpackArgSRbDataTypeT(kind)
	__ret := C.rb_data_typed_object_wrap(cklass, cdatap, ckind)
	packSRbDataTypeT(kind, ckind)
	runtime.KeepAlive(ckindAllocMap)
	runtime.KeepAlive(cdatapAllocMap)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDataTypedObjectZalloc function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rtypeddata.h
func RbDataTypedObjectZalloc(klass VALUE, size uint64, kind []RbDataTypeT) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	csize, csizeAllocMap := (C.size_t)(size), cgoAllocsUnknown
	ckind, ckindAllocMap := unpackArgSRbDataTypeT(kind)
	__ret := C.rb_data_typed_object_zalloc(cklass, csize, ckind)
	packSRbDataTypeT(kind, ckind)
	runtime.KeepAlive(ckindAllocMap)
	runtime.KeepAlive(csizeAllocMap)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbTypeddataInheritedP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rtypeddata.h
func RbTypeddataInheritedP(child []RbDataTypeT, parent []RbDataTypeT) int32 {
	cchild, cchildAllocMap := unpackArgSRbDataTypeT(child)
	cparent, cparentAllocMap := unpackArgSRbDataTypeT(parent)
	__ret := C.rb_typeddata_inherited_p(cchild, cparent)
	packSRbDataTypeT(parent, cparent)
	runtime.KeepAlive(cparentAllocMap)
	packSRbDataTypeT(child, cchild)
	runtime.KeepAlive(cchildAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbTypeddataIsKindOf function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rtypeddata.h
func RbTypeddataIsKindOf(obj VALUE, dataType []RbDataTypeT) int32 {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cdataType, cdataTypeAllocMap := unpackArgSRbDataTypeT(dataType)
	__ret := C.rb_typeddata_is_kind_of(cobj, cdataType)
	packSRbDataTypeT(dataType, cdataType)
	runtime.KeepAlive(cdataTypeAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbCheckTypeddata function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rtypeddata.h
func RbCheckTypeddata(obj VALUE, dataType []RbDataTypeT) unsafe.Pointer {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cdataType, cdataTypeAllocMap := unpackArgSRbDataTypeT(dataType)
	__ret := C.rb_check_typeddata(cobj, cdataType)
	packSRbDataTypeT(dataType, cdataType)
	runtime.KeepAlive(cdataTypeAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// RbDataTypedObjectMake function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rtypeddata.h
func RbDataTypedObjectMake(klass VALUE, kind []RbDataTypeT, datap []unsafe.Pointer, size uint64) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	ckind, ckindAllocMap := unpackArgSRbDataTypeT(kind)
	cdatap, cdatapAllocMap := (*unsafe.Pointer)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&datap)).Data)), cgoAllocsUnknown
	csize, csizeAllocMap := (C.size_t)(size), cgoAllocsUnknown
	__ret := C.rb_data_typed_object_make(cklass, ckind, cdatap, csize)
	runtime.KeepAlive(csizeAllocMap)
	runtime.KeepAlive(cdatapAllocMap)
	packSRbDataTypeT(kind, ckind)
	runtime.KeepAlive(ckindAllocMap)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDataTypedObjectAlloc function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/core/rtypeddata.h
func RbDataTypedObjectAlloc(klass VALUE, datap unsafe.Pointer, kind []RbDataTypeT) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cdatap, cdatapAllocMap := datap, cgoAllocsUnknown
	ckind, ckindAllocMap := unpackArgSRbDataTypeT(kind)
	__ret := C.rb_data_typed_object_alloc(cklass, cdatap, ckind)
	packSRbDataTypeT(kind, ckind)
	runtime.KeepAlive(ckindAllocMap)
	runtime.KeepAlive(cdatapAllocMap)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIsascii function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/ctype.h
func RbIsascii(c int32) int32 {
	cc, ccAllocMap := (C.int)(c), cgoAllocsUnknown
	__ret := C.rb_isascii(cc)
	runtime.KeepAlive(ccAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbIsupper function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/ctype.h
func RbIsupper(c int32) int32 {
	cc, ccAllocMap := (C.int)(c), cgoAllocsUnknown
	__ret := C.rb_isupper(cc)
	runtime.KeepAlive(ccAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbIslower function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/ctype.h
func RbIslower(c int32) int32 {
	cc, ccAllocMap := (C.int)(c), cgoAllocsUnknown
	__ret := C.rb_islower(cc)
	runtime.KeepAlive(ccAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbIsalpha function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/ctype.h
func RbIsalpha(c int32) int32 {
	cc, ccAllocMap := (C.int)(c), cgoAllocsUnknown
	__ret := C.rb_isalpha(cc)
	runtime.KeepAlive(ccAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbIsdigit function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/ctype.h
func RbIsdigit(c int32) int32 {
	cc, ccAllocMap := (C.int)(c), cgoAllocsUnknown
	__ret := C.rb_isdigit(cc)
	runtime.KeepAlive(ccAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbIsalnum function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/ctype.h
func RbIsalnum(c int32) int32 {
	cc, ccAllocMap := (C.int)(c), cgoAllocsUnknown
	__ret := C.rb_isalnum(cc)
	runtime.KeepAlive(ccAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbIsxdigit function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/ctype.h
func RbIsxdigit(c int32) int32 {
	cc, ccAllocMap := (C.int)(c), cgoAllocsUnknown
	__ret := C.rb_isxdigit(cc)
	runtime.KeepAlive(ccAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbIsblank function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/ctype.h
func RbIsblank(c int32) int32 {
	cc, ccAllocMap := (C.int)(c), cgoAllocsUnknown
	__ret := C.rb_isblank(cc)
	runtime.KeepAlive(ccAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbIsspace function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/ctype.h
func RbIsspace(c int32) int32 {
	cc, ccAllocMap := (C.int)(c), cgoAllocsUnknown
	__ret := C.rb_isspace(cc)
	runtime.KeepAlive(ccAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbIscntrl function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/ctype.h
func RbIscntrl(c int32) int32 {
	cc, ccAllocMap := (C.int)(c), cgoAllocsUnknown
	__ret := C.rb_iscntrl(cc)
	runtime.KeepAlive(ccAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbIsprint function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/ctype.h
func RbIsprint(c int32) int32 {
	cc, ccAllocMap := (C.int)(c), cgoAllocsUnknown
	__ret := C.rb_isprint(cc)
	runtime.KeepAlive(ccAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbIspunct function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/ctype.h
func RbIspunct(c int32) int32 {
	cc, ccAllocMap := (C.int)(c), cgoAllocsUnknown
	__ret := C.rb_ispunct(cc)
	runtime.KeepAlive(ccAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbIsgraph function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/ctype.h
func RbIsgraph(c int32) int32 {
	cc, ccAllocMap := (C.int)(c), cgoAllocsUnknown
	__ret := C.rb_isgraph(cc)
	runtime.KeepAlive(ccAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbTolower function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/ctype.h
func RbTolower(c int32) int32 {
	cc, ccAllocMap := (C.int)(c), cgoAllocsUnknown
	__ret := C.rb_tolower(cc)
	runtime.KeepAlive(ccAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbToupper function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/ctype.h
func RbToupper(c int32) int32 {
	cc, ccAllocMap := (C.int)(c), cgoAllocsUnknown
	__ret := C.rb_toupper(cc)
	runtime.KeepAlive(ccAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbErrinfo function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbErrinfo() VALUE {
	__ret := C.rb_errinfo()
	__v := (VALUE)(__ret)
	return __v
}

// RbSetErrinfo function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbSetErrinfo(err VALUE) {
	cerr, cerrAllocMap := (C.VALUE)(err), cgoAllocsUnknown
	C.rb_set_errinfo(cerr)
	runtime.KeepAlive(cerrAllocMap)
}

// RbRaise function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbRaise(exc VALUE, fmt string) {
	cexc, cexcAllocMap := (C.VALUE)(exc), cgoAllocsUnknown
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	C.rb_raise(cexc, cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	runtime.KeepAlive(cexcAllocMap)
}

// RbFatal function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbFatal(fmt string) {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	C.rb_fatal(cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
}

// RbBug function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbBug(fmt string) {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	C.rb_bug(cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
}

// RbBugErrno function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbBugErrno(msg string, err int32) {
	msg = safeString(msg)
	cmsg, cmsgAllocMap := unpackPCharString(msg)
	cerr, cerrAllocMap := (C.int)(err), cgoAllocsUnknown
	C.rb_bug_errno(cmsg, cerr)
	runtime.KeepAlive(cerrAllocMap)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(cmsgAllocMap)
}

// RbSysFail function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbSysFail(msg string) {
	msg = safeString(msg)
	cmsg, cmsgAllocMap := unpackPCharString(msg)
	C.rb_sys_fail(cmsg)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(cmsgAllocMap)
}

// RbSysFailStr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbSysFailStr(msg VALUE) {
	cmsg, cmsgAllocMap := (C.VALUE)(msg), cgoAllocsUnknown
	C.rb_sys_fail_str(cmsg)
	runtime.KeepAlive(cmsgAllocMap)
}

// RbModSysFail function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbModSysFail(mod VALUE, msg string) {
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	msg = safeString(msg)
	cmsg, cmsgAllocMap := unpackPCharString(msg)
	C.rb_mod_sys_fail(cmod, cmsg)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(cmsgAllocMap)
	runtime.KeepAlive(cmodAllocMap)
}

// RbModSysFailStr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbModSysFailStr(mod VALUE, msg VALUE) {
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	cmsg, cmsgAllocMap := (C.VALUE)(msg), cgoAllocsUnknown
	C.rb_mod_sys_fail_str(cmod, cmsg)
	runtime.KeepAlive(cmsgAllocMap)
	runtime.KeepAlive(cmodAllocMap)
}

// RbIterBreak function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbIterBreak() {
	C.rb_iter_break()
}

// RbIterBreakValue function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbIterBreakValue(val VALUE) {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	C.rb_iter_break_value(cval)
	runtime.KeepAlive(cvalAllocMap)
}

// RbExit function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbExit(status int32) {
	cstatus, cstatusAllocMap := (C.int)(status), cgoAllocsUnknown
	C.rb_exit(cstatus)
	runtime.KeepAlive(cstatusAllocMap)
}

// RbNotimplement function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbNotimplement() {
	C.rb_notimplement()
}

// RbSyserrNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbSyserrNew(err int32, msg string) VALUE {
	cerr, cerrAllocMap := (C.int)(err), cgoAllocsUnknown
	msg = safeString(msg)
	cmsg, cmsgAllocMap := unpackPCharString(msg)
	__ret := C.rb_syserr_new(cerr, cmsg)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(cmsgAllocMap)
	runtime.KeepAlive(cerrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbSyserrNewStr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbSyserrNewStr(n int32, arg VALUE) VALUE {
	cn, cnAllocMap := (C.int)(n), cgoAllocsUnknown
	carg, cargAllocMap := (C.VALUE)(arg), cgoAllocsUnknown
	__ret := C.rb_syserr_new_str(cn, carg)
	runtime.KeepAlive(cargAllocMap)
	runtime.KeepAlive(cnAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbSyserrFail function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbSyserrFail(err int32, msg string) {
	cerr, cerrAllocMap := (C.int)(err), cgoAllocsUnknown
	msg = safeString(msg)
	cmsg, cmsgAllocMap := unpackPCharString(msg)
	C.rb_syserr_fail(cerr, cmsg)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(cmsgAllocMap)
	runtime.KeepAlive(cerrAllocMap)
}

// RbSyserrFailStr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbSyserrFailStr(err int32, msg VALUE) {
	cerr, cerrAllocMap := (C.int)(err), cgoAllocsUnknown
	cmsg, cmsgAllocMap := (C.VALUE)(msg), cgoAllocsUnknown
	C.rb_syserr_fail_str(cerr, cmsg)
	runtime.KeepAlive(cmsgAllocMap)
	runtime.KeepAlive(cerrAllocMap)
}

// RbModSyserrFail function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbModSyserrFail(mod VALUE, err int32, msg string) {
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	cerr, cerrAllocMap := (C.int)(err), cgoAllocsUnknown
	msg = safeString(msg)
	cmsg, cmsgAllocMap := unpackPCharString(msg)
	C.rb_mod_syserr_fail(cmod, cerr, cmsg)
	runtime.KeepAlive(msg)
	runtime.KeepAlive(cmsgAllocMap)
	runtime.KeepAlive(cerrAllocMap)
	runtime.KeepAlive(cmodAllocMap)
}

// RbModSyserrFailStr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbModSyserrFailStr(mod VALUE, err int32, msg VALUE) {
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	cerr, cerrAllocMap := (C.int)(err), cgoAllocsUnknown
	cmsg, cmsgAllocMap := (C.VALUE)(msg), cgoAllocsUnknown
	C.rb_mod_syserr_fail_str(cmod, cerr, cmsg)
	runtime.KeepAlive(cmsgAllocMap)
	runtime.KeepAlive(cerrAllocMap)
	runtime.KeepAlive(cmodAllocMap)
}

// RbUnexpectedType function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbUnexpectedType(self VALUE, t int32) {
	cself, cselfAllocMap := (C.VALUE)(self), cgoAllocsUnknown
	ct, ctAllocMap := (C.int)(t), cgoAllocsUnknown
	C.rb_unexpected_type(cself, ct)
	runtime.KeepAlive(ctAllocMap)
	runtime.KeepAlive(cselfAllocMap)
}

// RbRubyVerbosePtr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbRubyVerbosePtr() *VALUE {
	__ret := C.rb_ruby_verbose_ptr()
	__v := *(**VALUE)(unsafe.Pointer(&__ret))
	return __v
}

// RbRubyDebugPtr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbRubyDebugPtr() *VALUE {
	__ret := C.rb_ruby_debug_ptr()
	__v := *(**VALUE)(unsafe.Pointer(&__ret))
	return __v
}

// RbWarning function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbWarning(fmt string) {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	C.rb_warning(cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
}

// RbCategoryWarning function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbCategoryWarning(cat RbWarningCategoryT, fmt string) {
	ccat, ccatAllocMap := (C.rb_warning_category_t)(cat), cgoAllocsUnknown
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	C.rb_category_warning(ccat, cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	runtime.KeepAlive(ccatAllocMap)
}

// RbCompileWarning function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbCompileWarning(file string, line int32, fmt string) {
	file = safeString(file)
	cfile, cfileAllocMap := unpackPCharString(file)
	cline, clineAllocMap := (C.int)(line), cgoAllocsUnknown
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	C.rb_compile_warning(cfile, cline, cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	runtime.KeepAlive(clineAllocMap)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cfileAllocMap)
}

// RbSysWarning function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbSysWarning(fmt string) {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	C.rb_sys_warning(cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
}

// RbWarn function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbWarn(fmt string) {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	C.rb_warn(cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
}

// RbCategoryWarn function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbCategoryWarn(cat RbWarningCategoryT, fmt string) {
	ccat, ccatAllocMap := (C.rb_warning_category_t)(cat), cgoAllocsUnknown
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	C.rb_category_warn(ccat, cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	runtime.KeepAlive(ccatAllocMap)
}

// RbCompileWarn function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbCompileWarn(file string, line int32, fmt string) {
	file = safeString(file)
	cfile, cfileAllocMap := unpackPCharString(file)
	cline, clineAllocMap := (C.int)(line), cgoAllocsUnknown
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	C.rb_compile_warn(cfile, cline, cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	runtime.KeepAlive(clineAllocMap)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cfileAllocMap)
}

// RbCategoryCompileWarn function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/error.h
func RbCategoryCompileWarn(cat RbWarningCategoryT, file string, line int32, fmt string) {
	ccat, ccatAllocMap := (C.rb_warning_category_t)(cat), cgoAllocsUnknown
	file = safeString(file)
	cfile, cfileAllocMap := unpackPCharString(file)
	cline, clineAllocMap := (C.int)(line), cgoAllocsUnknown
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	C.rb_category_compile_warn(ccat, cfile, cline, cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	runtime.KeepAlive(clineAllocMap)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cfileAllocMap)
	runtime.KeepAlive(ccatAllocMap)
}

// RbEvalString function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbEvalString(str string) VALUE {
	str = safeString(str)
	cstr, cstrAllocMap := unpackPCharString(str)
	__ret := C.rb_eval_string(cstr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbEvalStringProtect function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbEvalStringProtect(str string, state *int32) VALUE {
	str = safeString(str)
	cstr, cstrAllocMap := unpackPCharString(str)
	cstate, cstateAllocMap := (*C.int)(unsafe.Pointer(state)), cgoAllocsUnknown
	__ret := C.rb_eval_string_protect(cstr, cstate)
	runtime.KeepAlive(cstateAllocMap)
	runtime.KeepAlive(str)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbEvalStringWrap function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbEvalStringWrap(str string, state *int32) VALUE {
	str = safeString(str)
	cstr, cstrAllocMap := unpackPCharString(str)
	cstate, cstateAllocMap := (*C.int)(unsafe.Pointer(state)), cgoAllocsUnknown
	__ret := C.rb_eval_string_wrap(cstr, cstate)
	runtime.KeepAlive(cstateAllocMap)
	runtime.KeepAlive(str)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFuncall function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbFuncall(recv VALUE, mid ID, n int32) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	cn, cnAllocMap := (C.int)(n), cgoAllocsUnknown
	__ret := C.rb_funcall(crecv, cmid, cn)
	runtime.KeepAlive(cnAllocMap)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFuncallv function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbFuncallv(recv VALUE, mid ID, argc int32, argv []VALUE) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_funcallv(crecv, cmid, cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFuncallvKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbFuncallvKw(recv VALUE, mid ID, argc int32, argv []VALUE, kwSplat int32) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	__ret := C.rb_funcallv_kw(crecv, cmid, cargc, cargv, ckwSplat)
	runtime.KeepAlive(ckwSplatAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFuncallvPublic function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbFuncallvPublic(recv VALUE, mid ID, argc int32, argv []VALUE) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_funcallv_public(crecv, cmid, cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFuncallvPublicKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbFuncallvPublicKw(recv VALUE, mid ID, argc int32, argv []VALUE, kwSplat int32) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	__ret := C.rb_funcallv_public_kw(crecv, cmid, cargc, cargv, ckwSplat)
	runtime.KeepAlive(ckwSplatAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFuncallPassingBlock function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbFuncallPassingBlock(recv VALUE, mid ID, argc int32, argv []VALUE) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_funcall_passing_block(crecv, cmid, cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFuncallPassingBlockKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbFuncallPassingBlockKw(recv VALUE, mid ID, argc int32, argv []VALUE, kwSplat int32) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	__ret := C.rb_funcall_passing_block_kw(crecv, cmid, cargc, cargv, ckwSplat)
	runtime.KeepAlive(ckwSplatAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFuncallWithBlock function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbFuncallWithBlock(recv VALUE, mid ID, argc int32, argv []VALUE, procval VALUE) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cprocval, cprocvalAllocMap := (C.VALUE)(procval), cgoAllocsUnknown
	__ret := C.rb_funcall_with_block(crecv, cmid, cargc, cargv, cprocval)
	runtime.KeepAlive(cprocvalAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFuncallWithBlockKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbFuncallWithBlockKw(recv VALUE, mid ID, argc int32, argv []VALUE, procval VALUE, kwSplat int32) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cprocval, cprocvalAllocMap := (C.VALUE)(procval), cgoAllocsUnknown
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	__ret := C.rb_funcall_with_block_kw(crecv, cmid, cargc, cargv, cprocval, ckwSplat)
	runtime.KeepAlive(ckwSplatAllocMap)
	runtime.KeepAlive(cprocvalAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCallSuper function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbCallSuper(argc int32, argv []VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_call_super(cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCallSuperKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbCallSuperKw(argc int32, argv []VALUE, kwSplat int32) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	__ret := C.rb_call_super_kw(cargc, cargv, ckwSplat)
	runtime.KeepAlive(ckwSplatAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCurrentReceiver function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbCurrentReceiver() VALUE {
	__ret := C.rb_current_receiver()
	__v := (VALUE)(__ret)
	return __v
}

// RbGetKwargs function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbGetKwargs(keywordHash VALUE, table []ID, required int32, optional int32, values []VALUE) int32 {
	ckeywordHash, ckeywordHashAllocMap := (C.VALUE)(keywordHash), cgoAllocsUnknown
	ctable, ctableAllocMap := (*C.ID)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&table)).Data)), cgoAllocsUnknown
	crequired, crequiredAllocMap := (C.int)(required), cgoAllocsUnknown
	coptional, coptionalAllocMap := (C.int)(optional), cgoAllocsUnknown
	cvalues, cvaluesAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&values)).Data)), cgoAllocsUnknown
	__ret := C.rb_get_kwargs(ckeywordHash, ctable, crequired, coptional, cvalues)
	runtime.KeepAlive(cvaluesAllocMap)
	runtime.KeepAlive(coptionalAllocMap)
	runtime.KeepAlive(crequiredAllocMap)
	runtime.KeepAlive(ctableAllocMap)
	runtime.KeepAlive(ckeywordHashAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbExtractKeywords function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/eval.h
func RbExtractKeywords(orighash []VALUE) VALUE {
	corighash, corighashAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&orighash)).Data)), cgoAllocsUnknown
	__ret := C.rb_extract_keywords(corighash)
	runtime.KeepAlive(corighashAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAddEventHook function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/event.h
func RbAddEventHook(_func RbEventHookFuncT, events RbEventFlagT, data VALUE) {
	c_func, c_funcAllocMap := _func.PassValue()
	cevents, ceventsAllocMap := (C.rb_event_flag_t)(events), cgoAllocsUnknown
	cdata, cdataAllocMap := (C.VALUE)(data), cgoAllocsUnknown
	C.rb_add_event_hook(c_func, cevents, cdata)
	runtime.KeepAlive(cdataAllocMap)
	runtime.KeepAlive(ceventsAllocMap)
	runtime.KeepAlive(c_funcAllocMap)
}

// RbRemoveEventHook function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/event.h
func RbRemoveEventHook(_func RbEventHookFuncT) int32 {
	c_func, c_funcAllocMap := _func.PassValue()
	__ret := C.rb_remove_event_hook(c_func)
	runtime.KeepAlive(c_funcAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbFreezeSingletonClass function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RbFreezeSingletonClass(klass VALUE) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	C.rb_freeze_singleton_class(cklass)
	runtime.KeepAlive(cklassAllocMap)
}

// RB_FL_ABLE function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_FL_ABLE(obj VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_FL_ABLE(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_FL_TEST_RAW function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_FL_TEST_RAW(obj VALUE, flags VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cflags, cflagsAllocMap := (C.VALUE)(flags), cgoAllocsUnknown
	__ret := C.RB_FL_TEST_RAW(cobj, cflags)
	runtime.KeepAlive(cflagsAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RB_FL_TEST function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_FL_TEST(obj VALUE, flags VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cflags, cflagsAllocMap := (C.VALUE)(flags), cgoAllocsUnknown
	__ret := C.RB_FL_TEST(cobj, cflags)
	runtime.KeepAlive(cflagsAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RB_FL_ANY_RAW function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_FL_ANY_RAW(obj VALUE, flags VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cflags, cflagsAllocMap := (C.VALUE)(flags), cgoAllocsUnknown
	__ret := C.RB_FL_ANY_RAW(cobj, cflags)
	runtime.KeepAlive(cflagsAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_FL_ANY function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_FL_ANY(obj VALUE, flags VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cflags, cflagsAllocMap := (C.VALUE)(flags), cgoAllocsUnknown
	__ret := C.RB_FL_ANY(cobj, cflags)
	runtime.KeepAlive(cflagsAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_FL_ALL_RAW function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_FL_ALL_RAW(obj VALUE, flags VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cflags, cflagsAllocMap := (C.VALUE)(flags), cgoAllocsUnknown
	__ret := C.RB_FL_ALL_RAW(cobj, cflags)
	runtime.KeepAlive(cflagsAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_FL_ALL function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_FL_ALL(obj VALUE, flags VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cflags, cflagsAllocMap := (C.VALUE)(flags), cgoAllocsUnknown
	__ret := C.RB_FL_ALL(cobj, cflags)
	runtime.KeepAlive(cflagsAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_FL_SET_RAW function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_FL_SET_RAW(obj VALUE, flags VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cflags, cflagsAllocMap := (C.VALUE)(flags), cgoAllocsUnknown
	C.RB_FL_SET_RAW(cobj, cflags)
	runtime.KeepAlive(cflagsAllocMap)
	runtime.KeepAlive(cobjAllocMap)
}

// RB_FL_SET function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_FL_SET(obj VALUE, flags VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cflags, cflagsAllocMap := (C.VALUE)(flags), cgoAllocsUnknown
	C.RB_FL_SET(cobj, cflags)
	runtime.KeepAlive(cflagsAllocMap)
	runtime.KeepAlive(cobjAllocMap)
}

// RB_FL_UNSET_RAW function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_FL_UNSET_RAW(obj VALUE, flags VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cflags, cflagsAllocMap := (C.VALUE)(flags), cgoAllocsUnknown
	C.RB_FL_UNSET_RAW(cobj, cflags)
	runtime.KeepAlive(cflagsAllocMap)
	runtime.KeepAlive(cobjAllocMap)
}

// RB_FL_UNSET function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_FL_UNSET(obj VALUE, flags VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cflags, cflagsAllocMap := (C.VALUE)(flags), cgoAllocsUnknown
	C.RB_FL_UNSET(cobj, cflags)
	runtime.KeepAlive(cflagsAllocMap)
	runtime.KeepAlive(cobjAllocMap)
}

// RB_FL_REVERSE_RAW function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_FL_REVERSE_RAW(obj VALUE, flags VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cflags, cflagsAllocMap := (C.VALUE)(flags), cgoAllocsUnknown
	C.RB_FL_REVERSE_RAW(cobj, cflags)
	runtime.KeepAlive(cflagsAllocMap)
	runtime.KeepAlive(cobjAllocMap)
}

// RB_FL_REVERSE function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_FL_REVERSE(obj VALUE, flags VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cflags, cflagsAllocMap := (C.VALUE)(flags), cgoAllocsUnknown
	C.RB_FL_REVERSE(cobj, cflags)
	runtime.KeepAlive(cflagsAllocMap)
	runtime.KeepAlive(cobjAllocMap)
}

// RB_OBJ_TAINTABLE function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_OBJ_TAINTABLE(obj VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_OBJ_TAINTABLE(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_OBJ_TAINTED_RAW function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_OBJ_TAINTED_RAW(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_OBJ_TAINTED_RAW(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RB_OBJ_TAINTED function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_OBJ_TAINTED(obj VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_OBJ_TAINTED(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_OBJ_TAINT_RAW function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_OBJ_TAINT_RAW(obj VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	C.RB_OBJ_TAINT_RAW(cobj)
	runtime.KeepAlive(cobjAllocMap)
}

// RB_OBJ_TAINT function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_OBJ_TAINT(obj VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	C.RB_OBJ_TAINT(cobj)
	runtime.KeepAlive(cobjAllocMap)
}

// RB_OBJ_INFECT_RAW function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_OBJ_INFECT_RAW(dst VALUE, src VALUE) {
	cdst, cdstAllocMap := (C.VALUE)(dst), cgoAllocsUnknown
	csrc, csrcAllocMap := (C.VALUE)(src), cgoAllocsUnknown
	C.RB_OBJ_INFECT_RAW(cdst, csrc)
	runtime.KeepAlive(csrcAllocMap)
	runtime.KeepAlive(cdstAllocMap)
}

// RB_OBJ_INFECT function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_OBJ_INFECT(dst VALUE, src VALUE) {
	cdst, cdstAllocMap := (C.VALUE)(dst), cgoAllocsUnknown
	csrc, csrcAllocMap := (C.VALUE)(src), cgoAllocsUnknown
	C.RB_OBJ_INFECT(cdst, csrc)
	runtime.KeepAlive(csrcAllocMap)
	runtime.KeepAlive(cdstAllocMap)
}

// RB_OBJ_FROZEN_RAW function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_OBJ_FROZEN_RAW(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_OBJ_FROZEN_RAW(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RB_OBJ_FROZEN function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_OBJ_FROZEN(obj VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_OBJ_FROZEN(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_OBJ_FREEZE_RAW function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RB_OBJ_FREEZE_RAW(obj VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	C.RB_OBJ_FREEZE_RAW(cobj)
	runtime.KeepAlive(cobjAllocMap)
}

// RbObjFreezeInline function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/fl_type.h
func RbObjFreezeInline(obj VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	C.rb_obj_freeze_inline(cobj)
	runtime.KeepAlive(cobjAllocMap)
}

// RbMemerror function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbMemerror() {
	C.rb_memerror()
}

// RbDuringGc function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbDuringGc() int32 {
	__ret := C.rb_during_gc()
	__v := (int32)(__ret)
	return __v
}

// RbGcMarkLocations function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGcMarkLocations(start []VALUE, end []VALUE) {
	cstart, cstartAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&start)).Data)), cgoAllocsUnknown
	cend, cendAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&end)).Data)), cgoAllocsUnknown
	C.rb_gc_mark_locations(cstart, cend)
	runtime.KeepAlive(cendAllocMap)
	runtime.KeepAlive(cstartAllocMap)
}

// RbGcMarkMaybe function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGcMarkMaybe(obj VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	C.rb_gc_mark_maybe(cobj)
	runtime.KeepAlive(cobjAllocMap)
}

// RbGcMark function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGcMark(obj VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	C.rb_gc_mark(cobj)
	runtime.KeepAlive(cobjAllocMap)
}

// RbGcMarkMovable function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGcMarkMovable(obj VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	C.rb_gc_mark_movable(cobj)
	runtime.KeepAlive(cobjAllocMap)
}

// RbGcLocation function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGcLocation(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_gc_location(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbGcForceRecycle function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGcForceRecycle(obj VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	C.rb_gc_force_recycle(cobj)
	runtime.KeepAlive(cobjAllocMap)
}

// RbGc function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGc() {
	C.rb_gc()
}

// RbGcCopyFinalizer function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGcCopyFinalizer(dst VALUE, src VALUE) {
	cdst, cdstAllocMap := (C.VALUE)(dst), cgoAllocsUnknown
	csrc, csrcAllocMap := (C.VALUE)(src), cgoAllocsUnknown
	C.rb_gc_copy_finalizer(cdst, csrc)
	runtime.KeepAlive(csrcAllocMap)
	runtime.KeepAlive(cdstAllocMap)
}

// RbGcEnable function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGcEnable() VALUE {
	__ret := C.rb_gc_enable()
	__v := (VALUE)(__ret)
	return __v
}

// RbGcDisable function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGcDisable() VALUE {
	__ret := C.rb_gc_disable()
	__v := (VALUE)(__ret)
	return __v
}

// RbGcStart function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGcStart() VALUE {
	__ret := C.rb_gc_start()
	__v := (VALUE)(__ret)
	return __v
}

// RbDefineFinalizer function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbDefineFinalizer(obj VALUE, block VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cblock, cblockAllocMap := (C.VALUE)(block), cgoAllocsUnknown
	__ret := C.rb_define_finalizer(cobj, cblock)
	runtime.KeepAlive(cblockAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbUndefineFinalizer function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbUndefineFinalizer(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_undefine_finalizer(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbGcCount function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGcCount() uint64 {
	__ret := C.rb_gc_count()
	__v := (uint64)(__ret)
	return __v
}

// RbGcStat function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGcStat(keyOrBuf VALUE) uint64 {
	ckeyOrBuf, ckeyOrBufAllocMap := (C.VALUE)(keyOrBuf), cgoAllocsUnknown
	__ret := C.rb_gc_stat(ckeyOrBuf)
	runtime.KeepAlive(ckeyOrBufAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbGcLatestGcInfo function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGcLatestGcInfo(keyOrBuf VALUE) VALUE {
	ckeyOrBuf, ckeyOrBufAllocMap := (C.VALUE)(keyOrBuf), cgoAllocsUnknown
	__ret := C.rb_gc_latest_gc_info(ckeyOrBuf)
	runtime.KeepAlive(ckeyOrBufAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbGcAdjustMemoryUsage function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGcAdjustMemoryUsage(diff int64) {
	cdiff, cdiffAllocMap := (C.ssize_t)(diff), cgoAllocsUnknown
	C.rb_gc_adjust_memory_usage(cdiff)
	runtime.KeepAlive(cdiffAllocMap)
}

// RbGcRegisterAddress function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGcRegisterAddress(valptr []VALUE) {
	cvalptr, cvalptrAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&valptr)).Data)), cgoAllocsUnknown
	C.rb_gc_register_address(cvalptr)
	runtime.KeepAlive(cvalptrAllocMap)
}

// RbGlobalVariable function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGlobalVariable(arg0 []VALUE) {
	carg0, carg0AllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&arg0)).Data)), cgoAllocsUnknown
	C.rb_global_variable(carg0)
	runtime.KeepAlive(carg0AllocMap)
}

// RbGcUnregisterAddress function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGcUnregisterAddress(valptr []VALUE) {
	cvalptr, cvalptrAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&valptr)).Data)), cgoAllocsUnknown
	C.rb_gc_unregister_address(cvalptr)
	runtime.KeepAlive(cvalptrAllocMap)
}

// RbGcRegisterMarkObject function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGcRegisterMarkObject(object VALUE) {
	cobject, cobjectAllocMap := (C.VALUE)(object), cgoAllocsUnknown
	C.rb_gc_register_mark_object(cobject)
	runtime.KeepAlive(cobjectAllocMap)
}

// RbGcWritebarrier function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGcWritebarrier(old VALUE, young VALUE) {
	cold, coldAllocMap := (C.VALUE)(old), cgoAllocsUnknown
	cyoung, cyoungAllocMap := (C.VALUE)(young), cgoAllocsUnknown
	C.rb_gc_writebarrier(cold, cyoung)
	runtime.KeepAlive(cyoungAllocMap)
	runtime.KeepAlive(coldAllocMap)
}

// RbGcWritebarrierUnprotect function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbGcWritebarrierUnprotect(obj VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	C.rb_gc_writebarrier_unprotect(cobj)
	runtime.KeepAlive(cobjAllocMap)
}

// RB_OBJ_PROMOTED_RAW function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RB_OBJ_PROMOTED_RAW(obj VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_OBJ_PROMOTED_RAW(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_OBJ_PROMOTED function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RB_OBJ_PROMOTED(obj VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_OBJ_PROMOTED(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RbObjWbUnprotect function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbObjWbUnprotect(x VALUE, filename string, line int32) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	filename = safeString(filename)
	cfilename, cfilenameAllocMap := unpackPCharString(filename)
	cline, clineAllocMap := (C.int)(line), cgoAllocsUnknown
	__ret := C.rb_obj_wb_unprotect(cx, cfilename, cline)
	runtime.KeepAlive(clineAllocMap)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(cfilenameAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjWritten function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbObjWritten(a VALUE, oldv VALUE, b VALUE, filename string, line int32) VALUE {
	ca, caAllocMap := (C.VALUE)(a), cgoAllocsUnknown
	coldv, coldvAllocMap := (C.VALUE)(oldv), cgoAllocsUnknown
	cb, cbAllocMap := (C.VALUE)(b), cgoAllocsUnknown
	filename = safeString(filename)
	cfilename, cfilenameAllocMap := unpackPCharString(filename)
	cline, clineAllocMap := (C.int)(line), cgoAllocsUnknown
	__ret := C.rb_obj_written(ca, coldv, cb, cfilename, cline)
	runtime.KeepAlive(clineAllocMap)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(cfilenameAllocMap)
	runtime.KeepAlive(cbAllocMap)
	runtime.KeepAlive(coldvAllocMap)
	runtime.KeepAlive(caAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjWrite function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/gc.h
func RbObjWrite(a VALUE, slot []VALUE, b VALUE, filename string, line int32) VALUE {
	ca, caAllocMap := (C.VALUE)(a), cgoAllocsUnknown
	cslot, cslotAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&slot)).Data)), cgoAllocsUnknown
	cb, cbAllocMap := (C.VALUE)(b), cgoAllocsUnknown
	filename = safeString(filename)
	cfilename, cfilenameAllocMap := unpackPCharString(filename)
	cline, clineAllocMap := (C.int)(line), cgoAllocsUnknown
	__ret := C.rb_obj_write(ca, cslot, cb, cfilename, cline)
	runtime.KeepAlive(clineAllocMap)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(cfilenameAllocMap)
	runtime.KeepAlive(cbAllocMap)
	runtime.KeepAlive(cslotAllocMap)
	runtime.KeepAlive(caAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbClassOf function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/globals.h
func RbClassOf(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_class_of(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbMemClear function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbMemClear(buf []VALUE, len int64) {
	cbuf, cbufAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	C.rb_mem_clear(cbuf, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(cbufAllocMap)
}

// RbAssocNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAssocNew(car VALUE, cdr VALUE) VALUE {
	ccar, ccarAllocMap := (C.VALUE)(car), cgoAllocsUnknown
	ccdr, ccdrAllocMap := (C.VALUE)(cdr), cgoAllocsUnknown
	__ret := C.rb_assoc_new(ccar, ccdr)
	runtime.KeepAlive(ccdrAllocMap)
	runtime.KeepAlive(ccarAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCheckArrayType function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbCheckArrayType(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_check_array_type(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryNew() VALUE {
	__ret := C.rb_ary_new()
	__v := (VALUE)(__ret)
	return __v
}

// RbAryNewCapa function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryNewCapa(capa int64) VALUE {
	ccapa, ccapaAllocMap := (C.long)(capa), cgoAllocsUnknown
	__ret := C.rb_ary_new_capa(ccapa)
	runtime.KeepAlive(ccapaAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryNewFromArgs function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryNewFromArgs(n int64) VALUE {
	cn, cnAllocMap := (C.long)(n), cgoAllocsUnknown
	__ret := C.rb_ary_new_from_args(cn)
	runtime.KeepAlive(cnAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryNewFromValues function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryNewFromValues(n int64, elts []VALUE) VALUE {
	cn, cnAllocMap := (C.long)(n), cgoAllocsUnknown
	celts, celtsAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&elts)).Data)), cgoAllocsUnknown
	__ret := C.rb_ary_new_from_values(cn, celts)
	runtime.KeepAlive(celtsAllocMap)
	runtime.KeepAlive(cnAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryHiddenNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryHiddenNew(capa int64) VALUE {
	ccapa, ccapaAllocMap := (C.long)(capa), cgoAllocsUnknown
	__ret := C.rb_ary_hidden_new(ccapa)
	runtime.KeepAlive(ccapaAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryFree function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryFree(ary VALUE) {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	C.rb_ary_free(cary)
	runtime.KeepAlive(caryAllocMap)
}

// RbAryModify function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryModify(ary VALUE) {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	C.rb_ary_modify(cary)
	runtime.KeepAlive(caryAllocMap)
}

// RbAryFreeze function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryFreeze(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_ary_freeze(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbArySharedWithP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbArySharedWithP(lhs VALUE, rhs VALUE) VALUE {
	clhs, clhsAllocMap := (C.VALUE)(lhs), cgoAllocsUnknown
	crhs, crhsAllocMap := (C.VALUE)(rhs), cgoAllocsUnknown
	__ret := C.rb_ary_shared_with_p(clhs, crhs)
	runtime.KeepAlive(crhsAllocMap)
	runtime.KeepAlive(clhsAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryAref function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryAref(argc int32, argv []VALUE, ary VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	__ret := C.rb_ary_aref(cargc, cargv, cary)
	runtime.KeepAlive(caryAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbArySubseq function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbArySubseq(ary VALUE, beg int64, len int64) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	cbeg, cbegAllocMap := (C.long)(beg), cgoAllocsUnknown
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_ary_subseq(cary, cbeg, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(cbegAllocMap)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryStore function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryStore(ary VALUE, key int64, val VALUE) {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	ckey, ckeyAllocMap := (C.long)(key), cgoAllocsUnknown
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	C.rb_ary_store(cary, ckey, cval)
	runtime.KeepAlive(cvalAllocMap)
	runtime.KeepAlive(ckeyAllocMap)
	runtime.KeepAlive(caryAllocMap)
}

// RbAryDup function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryDup(ary VALUE) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	__ret := C.rb_ary_dup(cary)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryResurrect function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryResurrect(ary VALUE) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	__ret := C.rb_ary_resurrect(cary)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryToAry function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryToAry(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_ary_to_ary(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryToS function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryToS(ary VALUE) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	__ret := C.rb_ary_to_s(cary)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryCat function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryCat(ary VALUE, train []VALUE, len int64) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	ctrain, ctrainAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&train)).Data)), cgoAllocsUnknown
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_ary_cat(cary, ctrain, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(ctrainAllocMap)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryPush function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryPush(ary VALUE, elem VALUE) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	celem, celemAllocMap := (C.VALUE)(elem), cgoAllocsUnknown
	__ret := C.rb_ary_push(cary, celem)
	runtime.KeepAlive(celemAllocMap)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryPop function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryPop(ary VALUE) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	__ret := C.rb_ary_pop(cary)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryShift function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryShift(ary VALUE) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	__ret := C.rb_ary_shift(cary)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryUnshift function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryUnshift(ary VALUE, elem VALUE) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	celem, celemAllocMap := (C.VALUE)(elem), cgoAllocsUnknown
	__ret := C.rb_ary_unshift(cary, celem)
	runtime.KeepAlive(celemAllocMap)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryEntry function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryEntry(ary VALUE, off int64) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	coff, coffAllocMap := (C.long)(off), cgoAllocsUnknown
	__ret := C.rb_ary_entry(cary, coff)
	runtime.KeepAlive(coffAllocMap)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryEach function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryEach(ary VALUE) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	__ret := C.rb_ary_each(cary)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryJoin function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryJoin(ary VALUE, sep VALUE) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	csep, csepAllocMap := (C.VALUE)(sep), cgoAllocsUnknown
	__ret := C.rb_ary_join(cary, csep)
	runtime.KeepAlive(csepAllocMap)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryReverse function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryReverse(ary VALUE) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	__ret := C.rb_ary_reverse(cary)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryRotate function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryRotate(ary VALUE, rot int64) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	crot, crotAllocMap := (C.long)(rot), cgoAllocsUnknown
	__ret := C.rb_ary_rotate(cary, crot)
	runtime.KeepAlive(crotAllocMap)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbArySort function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbArySort(ary VALUE) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	__ret := C.rb_ary_sort(cary)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbArySortBang function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbArySortBang(ary VALUE) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	__ret := C.rb_ary_sort_bang(cary)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryDelete function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryDelete(ary VALUE, elem VALUE) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	celem, celemAllocMap := (C.VALUE)(elem), cgoAllocsUnknown
	__ret := C.rb_ary_delete(cary, celem)
	runtime.KeepAlive(celemAllocMap)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryDeleteAt function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryDeleteAt(ary VALUE, pos int64) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	cpos, cposAllocMap := (C.long)(pos), cgoAllocsUnknown
	__ret := C.rb_ary_delete_at(cary, cpos)
	runtime.KeepAlive(cposAllocMap)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryClear function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryClear(ary VALUE) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	__ret := C.rb_ary_clear(cary)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryPlus function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryPlus(lhs VALUE, rhs VALUE) VALUE {
	clhs, clhsAllocMap := (C.VALUE)(lhs), cgoAllocsUnknown
	crhs, crhsAllocMap := (C.VALUE)(rhs), cgoAllocsUnknown
	__ret := C.rb_ary_plus(clhs, crhs)
	runtime.KeepAlive(crhsAllocMap)
	runtime.KeepAlive(clhsAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryConcat function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryConcat(lhs VALUE, rhs VALUE) VALUE {
	clhs, clhsAllocMap := (C.VALUE)(lhs), cgoAllocsUnknown
	crhs, crhsAllocMap := (C.VALUE)(rhs), cgoAllocsUnknown
	__ret := C.rb_ary_concat(clhs, crhs)
	runtime.KeepAlive(crhsAllocMap)
	runtime.KeepAlive(clhsAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryAssoc function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryAssoc(alist VALUE, key VALUE) VALUE {
	calist, calistAllocMap := (C.VALUE)(alist), cgoAllocsUnknown
	ckey, ckeyAllocMap := (C.VALUE)(key), cgoAllocsUnknown
	__ret := C.rb_ary_assoc(calist, ckey)
	runtime.KeepAlive(ckeyAllocMap)
	runtime.KeepAlive(calistAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryRassoc function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryRassoc(alist VALUE, key VALUE) VALUE {
	calist, calistAllocMap := (C.VALUE)(alist), cgoAllocsUnknown
	ckey, ckeyAllocMap := (C.VALUE)(key), cgoAllocsUnknown
	__ret := C.rb_ary_rassoc(calist, ckey)
	runtime.KeepAlive(ckeyAllocMap)
	runtime.KeepAlive(calistAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryIncludes function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryIncludes(ary VALUE, elem VALUE) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	celem, celemAllocMap := (C.VALUE)(elem), cgoAllocsUnknown
	__ret := C.rb_ary_includes(cary, celem)
	runtime.KeepAlive(celemAllocMap)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryCmp function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryCmp(lhs VALUE, rhs VALUE) VALUE {
	clhs, clhsAllocMap := (C.VALUE)(lhs), cgoAllocsUnknown
	crhs, crhsAllocMap := (C.VALUE)(rhs), cgoAllocsUnknown
	__ret := C.rb_ary_cmp(clhs, crhs)
	runtime.KeepAlive(crhsAllocMap)
	runtime.KeepAlive(clhsAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryReplace function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryReplace(copy VALUE, orig VALUE) VALUE {
	ccopy, ccopyAllocMap := (C.VALUE)(copy), cgoAllocsUnknown
	corig, corigAllocMap := (C.VALUE)(orig), cgoAllocsUnknown
	__ret := C.rb_ary_replace(ccopy, corig)
	runtime.KeepAlive(corigAllocMap)
	runtime.KeepAlive(ccopyAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbGetValuesAt function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbGetValuesAt(obj VALUE, olen int64, argc int32, argv []VALUE, _func VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	colen, colenAllocMap := (C.long)(olen), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	c_func, c_funcAllocMap := _func.PassRef()
	__ret := C.rb_get_values_at(cobj, colen, cargc, cargv, c_func)
	runtime.KeepAlive(c_funcAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(colenAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAryResize function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/array.h
func RbAryResize(ary VALUE, len int64) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_ary_resize(cary, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBigNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigNew(len uint64, sign int32) VALUE {
	clen, clenAllocMap := (C.size_t)(len), cgoAllocsUnknown
	csign, csignAllocMap := (C.int)(sign), cgoAllocsUnknown
	__ret := C.rb_big_new(clen, csign)
	runtime.KeepAlive(csignAllocMap)
	runtime.KeepAlive(clenAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBigzeroP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigzeroP(x VALUE) int32 {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	__ret := C.rb_bigzero_p(cx)
	runtime.KeepAlive(cxAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbBigClone function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigClone(num VALUE) VALUE {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	__ret := C.rb_big_clone(cnum)
	runtime.KeepAlive(cnumAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBig2comp function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBig2comp(num VALUE) {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	C.rb_big_2comp(cnum)
	runtime.KeepAlive(cnumAllocMap)
}

// RbBigNorm function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigNorm(x VALUE) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	__ret := C.rb_big_norm(cx)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBigResize function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigResize(big VALUE, len uint64) {
	cbig, cbigAllocMap := (C.VALUE)(big), cgoAllocsUnknown
	clen, clenAllocMap := (C.size_t)(len), cgoAllocsUnknown
	C.rb_big_resize(cbig, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(cbigAllocMap)
}

// RbCstrToInum function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbCstrToInum(str string, base int32, badcheck int32) VALUE {
	str = safeString(str)
	cstr, cstrAllocMap := unpackPCharString(str)
	cbase, cbaseAllocMap := (C.int)(base), cgoAllocsUnknown
	cbadcheck, cbadcheckAllocMap := (C.int)(badcheck), cgoAllocsUnknown
	__ret := C.rb_cstr_to_inum(cstr, cbase, cbadcheck)
	runtime.KeepAlive(cbadcheckAllocMap)
	runtime.KeepAlive(cbaseAllocMap)
	runtime.KeepAlive(str)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrToInum function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbStrToInum(str VALUE, base int32, badcheck int32) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	cbase, cbaseAllocMap := (C.int)(base), cgoAllocsUnknown
	cbadcheck, cbadcheckAllocMap := (C.int)(badcheck), cgoAllocsUnknown
	__ret := C.rb_str_to_inum(cstr, cbase, cbadcheck)
	runtime.KeepAlive(cbadcheckAllocMap)
	runtime.KeepAlive(cbaseAllocMap)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCstr2inum function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbCstr2inum(str string, base int32) VALUE {
	str = safeString(str)
	cstr, cstrAllocMap := unpackPCharString(str)
	cbase, cbaseAllocMap := (C.int)(base), cgoAllocsUnknown
	__ret := C.rb_cstr2inum(cstr, cbase)
	runtime.KeepAlive(cbaseAllocMap)
	runtime.KeepAlive(str)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStr2inum function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbStr2inum(str VALUE, base int32) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	cbase, cbaseAllocMap := (C.int)(base), cgoAllocsUnknown
	__ret := C.rb_str2inum(cstr, cbase)
	runtime.KeepAlive(cbaseAllocMap)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBig2str function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBig2str(x VALUE, base int32) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	cbase, cbaseAllocMap := (C.int)(base), cgoAllocsUnknown
	__ret := C.rb_big2str(cx, cbase)
	runtime.KeepAlive(cbaseAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBig2long function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBig2long(x VALUE) int64 {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	__ret := C.rb_big2long(cx)
	runtime.KeepAlive(cxAllocMap)
	__v := (int64)(__ret)
	return __v
}

// RbBig2ulong function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBig2ulong(x VALUE) uint64 {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	__ret := C.rb_big2ulong(cx)
	runtime.KeepAlive(cxAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbBig2ll function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBig2ll(arg0 VALUE) int64 {
	carg0, carg0AllocMap := (C.VALUE)(arg0), cgoAllocsUnknown
	__ret := C.rb_big2ll(carg0)
	runtime.KeepAlive(carg0AllocMap)
	__v := (int64)(__ret)
	return __v
}

// RbBig2ull function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBig2ull(arg0 VALUE) uint64 {
	carg0, carg0AllocMap := (C.VALUE)(arg0), cgoAllocsUnknown
	__ret := C.rb_big2ull(carg0)
	runtime.KeepAlive(carg0AllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbBigPack function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigPack(val VALUE, buf []uint64, numLongs int64) {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	cbuf, cbufAllocMap := (*C.ulong)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cnumLongs, cnumLongsAllocMap := (C.long)(numLongs), cgoAllocsUnknown
	C.rb_big_pack(cval, cbuf, cnumLongs)
	runtime.KeepAlive(cnumLongsAllocMap)
	runtime.KeepAlive(cbufAllocMap)
	runtime.KeepAlive(cvalAllocMap)
}

// RbBigUnpack function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigUnpack(buf []uint64, numLongs int64) VALUE {
	cbuf, cbufAllocMap := (*C.ulong)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cnumLongs, cnumLongsAllocMap := (C.long)(numLongs), cgoAllocsUnknown
	__ret := C.rb_big_unpack(cbuf, cnumLongs)
	runtime.KeepAlive(cnumLongsAllocMap)
	runtime.KeepAlive(cbufAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbUvToUtf8 function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbUvToUtf8(buf []byte, uv uint64) int32 {
	cbuf, cbufAllocMap := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&buf)).Data)), cgoAllocsUnknown
	cuv, cuvAllocMap := (C.ulong)(uv), cgoAllocsUnknown
	__ret := C.rb_uv_to_utf8(cbuf, cuv)
	runtime.KeepAlive(cuvAllocMap)
	runtime.KeepAlive(cbufAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbDbl2big function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbDbl2big(d float64) VALUE {
	cd, cdAllocMap := (C.double)(d), cgoAllocsUnknown
	__ret := C.rb_dbl2big(cd)
	runtime.KeepAlive(cdAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBig2dbl function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBig2dbl(x VALUE) float64 {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	__ret := C.rb_big2dbl(cx)
	runtime.KeepAlive(cxAllocMap)
	__v := (float64)(__ret)
	return __v
}

// RbBigCmp function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigCmp(lhs VALUE, rhs VALUE) VALUE {
	clhs, clhsAllocMap := (C.VALUE)(lhs), cgoAllocsUnknown
	crhs, crhsAllocMap := (C.VALUE)(rhs), cgoAllocsUnknown
	__ret := C.rb_big_cmp(clhs, crhs)
	runtime.KeepAlive(crhsAllocMap)
	runtime.KeepAlive(clhsAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBigEq function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigEq(lhs VALUE, rhs VALUE) VALUE {
	clhs, clhsAllocMap := (C.VALUE)(lhs), cgoAllocsUnknown
	crhs, crhsAllocMap := (C.VALUE)(rhs), cgoAllocsUnknown
	__ret := C.rb_big_eq(clhs, crhs)
	runtime.KeepAlive(crhsAllocMap)
	runtime.KeepAlive(clhsAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBigEql function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigEql(lhs VALUE, rhs VALUE) VALUE {
	clhs, clhsAllocMap := (C.VALUE)(lhs), cgoAllocsUnknown
	crhs, crhsAllocMap := (C.VALUE)(rhs), cgoAllocsUnknown
	__ret := C.rb_big_eql(clhs, crhs)
	runtime.KeepAlive(crhsAllocMap)
	runtime.KeepAlive(clhsAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBigPlus function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigPlus(x VALUE, y VALUE) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	cy, cyAllocMap := (C.VALUE)(y), cgoAllocsUnknown
	__ret := C.rb_big_plus(cx, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBigMinus function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigMinus(x VALUE, y VALUE) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	cy, cyAllocMap := (C.VALUE)(y), cgoAllocsUnknown
	__ret := C.rb_big_minus(cx, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBigMul function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigMul(x VALUE, y VALUE) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	cy, cyAllocMap := (C.VALUE)(y), cgoAllocsUnknown
	__ret := C.rb_big_mul(cx, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBigDiv function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigDiv(x VALUE, y VALUE) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	cy, cyAllocMap := (C.VALUE)(y), cgoAllocsUnknown
	__ret := C.rb_big_div(cx, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBigIdiv function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigIdiv(x VALUE, y VALUE) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	cy, cyAllocMap := (C.VALUE)(y), cgoAllocsUnknown
	__ret := C.rb_big_idiv(cx, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBigModulo function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigModulo(x VALUE, y VALUE) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	cy, cyAllocMap := (C.VALUE)(y), cgoAllocsUnknown
	__ret := C.rb_big_modulo(cx, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBigDivmod function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigDivmod(x VALUE, y VALUE) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	cy, cyAllocMap := (C.VALUE)(y), cgoAllocsUnknown
	__ret := C.rb_big_divmod(cx, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBigPow function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigPow(x VALUE, y VALUE) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	cy, cyAllocMap := (C.VALUE)(y), cgoAllocsUnknown
	__ret := C.rb_big_pow(cx, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBigAnd function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigAnd(x VALUE, y VALUE) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	cy, cyAllocMap := (C.VALUE)(y), cgoAllocsUnknown
	__ret := C.rb_big_and(cx, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBigOr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigOr(x VALUE, y VALUE) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	cy, cyAllocMap := (C.VALUE)(y), cgoAllocsUnknown
	__ret := C.rb_big_or(cx, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBigXor function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigXor(x VALUE, y VALUE) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	cy, cyAllocMap := (C.VALUE)(y), cgoAllocsUnknown
	__ret := C.rb_big_xor(cx, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBigLshift function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigLshift(x VALUE, y VALUE) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	cy, cyAllocMap := (C.VALUE)(y), cgoAllocsUnknown
	__ret := C.rb_big_lshift(cx, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBigRshift function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbBigRshift(x VALUE, y VALUE) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	cy, cyAllocMap := (C.VALUE)(y), cgoAllocsUnknown
	__ret := C.rb_big_rshift(cx, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIntegerPack function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbIntegerPack(val VALUE, words unsafe.Pointer, numwords uint64, wordsize uint64, nails uint64, flags int32) int32 {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	cwords, cwordsAllocMap := words, cgoAllocsUnknown
	cnumwords, cnumwordsAllocMap := (C.size_t)(numwords), cgoAllocsUnknown
	cwordsize, cwordsizeAllocMap := (C.size_t)(wordsize), cgoAllocsUnknown
	cnails, cnailsAllocMap := (C.size_t)(nails), cgoAllocsUnknown
	cflags, cflagsAllocMap := (C.int)(flags), cgoAllocsUnknown
	__ret := C.rb_integer_pack(cval, cwords, cnumwords, cwordsize, cnails, cflags)
	runtime.KeepAlive(cflagsAllocMap)
	runtime.KeepAlive(cnailsAllocMap)
	runtime.KeepAlive(cwordsizeAllocMap)
	runtime.KeepAlive(cnumwordsAllocMap)
	runtime.KeepAlive(cwordsAllocMap)
	runtime.KeepAlive(cvalAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbIntegerUnpack function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbIntegerUnpack(words unsafe.Pointer, numwords uint64, wordsize uint64, nails uint64, flags int32) VALUE {
	cwords, cwordsAllocMap := words, cgoAllocsUnknown
	cnumwords, cnumwordsAllocMap := (C.size_t)(numwords), cgoAllocsUnknown
	cwordsize, cwordsizeAllocMap := (C.size_t)(wordsize), cgoAllocsUnknown
	cnails, cnailsAllocMap := (C.size_t)(nails), cgoAllocsUnknown
	cflags, cflagsAllocMap := (C.int)(flags), cgoAllocsUnknown
	__ret := C.rb_integer_unpack(cwords, cnumwords, cwordsize, cnails, cflags)
	runtime.KeepAlive(cflagsAllocMap)
	runtime.KeepAlive(cnailsAllocMap)
	runtime.KeepAlive(cwordsizeAllocMap)
	runtime.KeepAlive(cnumwordsAllocMap)
	runtime.KeepAlive(cwordsAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAbsintSize function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbAbsintSize(val VALUE, nlzBitsRet []int32) uint64 {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	cnlzBitsRet, cnlzBitsRetAllocMap := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&nlzBitsRet)).Data)), cgoAllocsUnknown
	__ret := C.rb_absint_size(cval, cnlzBitsRet)
	runtime.KeepAlive(cnlzBitsRetAllocMap)
	runtime.KeepAlive(cvalAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbAbsintNumwords function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbAbsintNumwords(val VALUE, wordNumbits uint64, nlzBitsRet []uint64) uint64 {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	cwordNumbits, cwordNumbitsAllocMap := (C.size_t)(wordNumbits), cgoAllocsUnknown
	cnlzBitsRet, cnlzBitsRetAllocMap := (*C.size_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&nlzBitsRet)).Data)), cgoAllocsUnknown
	__ret := C.rb_absint_numwords(cval, cwordNumbits, cnlzBitsRet)
	runtime.KeepAlive(cnlzBitsRetAllocMap)
	runtime.KeepAlive(cwordNumbitsAllocMap)
	runtime.KeepAlive(cvalAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbAbsintSinglebitP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/bignum.h
func RbAbsintSinglebitP(val VALUE) int32 {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	__ret := C.rb_absint_singlebit_p(cval)
	runtime.KeepAlive(cvalAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbClassNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbClassNew(super VALUE) VALUE {
	csuper, csuperAllocMap := (C.VALUE)(super), cgoAllocsUnknown
	__ret := C.rb_class_new(csuper)
	runtime.KeepAlive(csuperAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbModInitCopy function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbModInitCopy(clone VALUE, orig VALUE) VALUE {
	cclone, ccloneAllocMap := (C.VALUE)(clone), cgoAllocsUnknown
	corig, corigAllocMap := (C.VALUE)(orig), cgoAllocsUnknown
	__ret := C.rb_mod_init_copy(cclone, corig)
	runtime.KeepAlive(corigAllocMap)
	runtime.KeepAlive(ccloneAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCheckInheritable function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbCheckInheritable(super VALUE) {
	csuper, csuperAllocMap := (C.VALUE)(super), cgoAllocsUnknown
	C.rb_check_inheritable(csuper)
	runtime.KeepAlive(csuperAllocMap)
}

// RbDefineClassId function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbDefineClassId(id ID, super VALUE) VALUE {
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	csuper, csuperAllocMap := (C.VALUE)(super), cgoAllocsUnknown
	__ret := C.rb_define_class_id(cid, csuper)
	runtime.KeepAlive(csuperAllocMap)
	runtime.KeepAlive(cidAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDefineClassIdUnder function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbDefineClassIdUnder(outer VALUE, id ID, super VALUE) VALUE {
	couter, couterAllocMap := (C.VALUE)(outer), cgoAllocsUnknown
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	csuper, csuperAllocMap := (C.VALUE)(super), cgoAllocsUnknown
	__ret := C.rb_define_class_id_under(couter, cid, csuper)
	runtime.KeepAlive(csuperAllocMap)
	runtime.KeepAlive(cidAllocMap)
	runtime.KeepAlive(couterAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbModuleNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbModuleNew() VALUE {
	__ret := C.rb_module_new()
	__v := (VALUE)(__ret)
	return __v
}

// RbRefinementNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbRefinementNew() VALUE {
	__ret := C.rb_refinement_new()
	__v := (VALUE)(__ret)
	return __v
}

// RbDefineModuleId function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbDefineModuleId(id ID) VALUE {
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	__ret := C.rb_define_module_id(cid)
	runtime.KeepAlive(cidAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDefineModuleIdUnder function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbDefineModuleIdUnder(outer VALUE, id ID) VALUE {
	couter, couterAllocMap := (C.VALUE)(outer), cgoAllocsUnknown
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	__ret := C.rb_define_module_id_under(couter, cid)
	runtime.KeepAlive(cidAllocMap)
	runtime.KeepAlive(couterAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbModIncludedModules function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbModIncludedModules(mod VALUE) VALUE {
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	__ret := C.rb_mod_included_modules(cmod)
	runtime.KeepAlive(cmodAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbModIncludeP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbModIncludeP(child VALUE, parent VALUE) VALUE {
	cchild, cchildAllocMap := (C.VALUE)(child), cgoAllocsUnknown
	cparent, cparentAllocMap := (C.VALUE)(parent), cgoAllocsUnknown
	__ret := C.rb_mod_include_p(cchild, cparent)
	runtime.KeepAlive(cparentAllocMap)
	runtime.KeepAlive(cchildAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbModAncestors function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbModAncestors(mod VALUE) VALUE {
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	__ret := C.rb_mod_ancestors(cmod)
	runtime.KeepAlive(cmodAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbClassDescendants function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbClassDescendants(klass VALUE) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	__ret := C.rb_class_descendants(cklass)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbClassSubclasses function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbClassSubclasses(klass VALUE) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	__ret := C.rb_class_subclasses(cklass)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbClassAttachedObject function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbClassAttachedObject(klass VALUE) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	__ret := C.rb_class_attached_object(cklass)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbClassInstanceMethods function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbClassInstanceMethods(argc int32, argv []VALUE, mod VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	__ret := C.rb_class_instance_methods(cargc, cargv, cmod)
	runtime.KeepAlive(cmodAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbClassPublicInstanceMethods function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbClassPublicInstanceMethods(argc int32, argv []VALUE, mod VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	__ret := C.rb_class_public_instance_methods(cargc, cargv, cmod)
	runtime.KeepAlive(cmodAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbClassProtectedInstanceMethods function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbClassProtectedInstanceMethods(argc int32, argv []VALUE, mod VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	__ret := C.rb_class_protected_instance_methods(cargc, cargv, cmod)
	runtime.KeepAlive(cmodAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbClassPrivateInstanceMethods function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbClassPrivateInstanceMethods(argc int32, argv []VALUE, mod VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	__ret := C.rb_class_private_instance_methods(cargc, cargv, cmod)
	runtime.KeepAlive(cmodAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjSingletonMethods function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbObjSingletonMethods(argc int32, argv []VALUE, obj VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_obj_singleton_methods(cargc, cargv, cobj)
	runtime.KeepAlive(cobjAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDefineMethodId function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbDefineMethodId(klass VALUE, mid ID, _func VALUE, arity int32) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	c_func, c_funcAllocMap := _func.PassRef()
	carity, carityAllocMap := (C.int)(arity), cgoAllocsUnknown
	C.rb_define_method_id(cklass, cmid, c_func, carity)
	runtime.KeepAlive(carityAllocMap)
	runtime.KeepAlive(c_funcAllocMap)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbUndef function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbUndef(mod VALUE, mid ID) {
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	C.rb_undef(cmod, cmid)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(cmodAllocMap)
}

// RbDefineProtectedMethod function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbDefineProtectedMethod(klass VALUE, mid string, _func VALUE, arity int32) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	mid = safeString(mid)
	cmid, cmidAllocMap := unpackPCharString(mid)
	c_func, c_funcAllocMap := _func.PassRef()
	carity, carityAllocMap := (C.int)(arity), cgoAllocsUnknown
	C.rb_define_protected_method(cklass, cmid, c_func, carity)
	runtime.KeepAlive(carityAllocMap)
	runtime.KeepAlive(c_funcAllocMap)
	runtime.KeepAlive(mid)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbDefinePrivateMethod function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbDefinePrivateMethod(klass VALUE, mid string, _func VALUE, arity int32) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	mid = safeString(mid)
	cmid, cmidAllocMap := unpackPCharString(mid)
	c_func, c_funcAllocMap := _func.PassRef()
	carity, carityAllocMap := (C.int)(arity), cgoAllocsUnknown
	C.rb_define_private_method(cklass, cmid, c_func, carity)
	runtime.KeepAlive(carityAllocMap)
	runtime.KeepAlive(c_funcAllocMap)
	runtime.KeepAlive(mid)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbDefineSingletonMethod function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbDefineSingletonMethod(obj VALUE, mid string, _func VALUE, arity int32) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	mid = safeString(mid)
	cmid, cmidAllocMap := unpackPCharString(mid)
	c_func, c_funcAllocMap := _func.PassRef()
	carity, carityAllocMap := (C.int)(arity), cgoAllocsUnknown
	C.rb_define_singleton_method(cobj, cmid, c_func, carity)
	runtime.KeepAlive(carityAllocMap)
	runtime.KeepAlive(c_funcAllocMap)
	runtime.KeepAlive(mid)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(cobjAllocMap)
}

// RbSingletonClass function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/class.h
func RbSingletonClass(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_singleton_class(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCmpint function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/compar.h
func RbCmpint(val VALUE, a VALUE, b VALUE) int32 {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	ca, caAllocMap := (C.VALUE)(a), cgoAllocsUnknown
	cb, cbAllocMap := (C.VALUE)(b), cgoAllocsUnknown
	__ret := C.rb_cmpint(cval, ca, cb)
	runtime.KeepAlive(cbAllocMap)
	runtime.KeepAlive(caAllocMap)
	runtime.KeepAlive(cvalAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbCmperr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/compar.h
func RbCmperr(a VALUE, b VALUE) {
	ca, caAllocMap := (C.VALUE)(a), cgoAllocsUnknown
	cb, cbAllocMap := (C.VALUE)(b), cgoAllocsUnknown
	C.rb_cmperr(ca, cb)
	runtime.KeepAlive(cbAllocMap)
	runtime.KeepAlive(caAllocMap)
}

// RbComplexRaw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/complex.h
func RbComplexRaw(real VALUE, imag VALUE) VALUE {
	creal, crealAllocMap := (C.VALUE)(real), cgoAllocsUnknown
	cimag, cimagAllocMap := (C.VALUE)(imag), cgoAllocsUnknown
	__ret := C.rb_complex_raw(creal, cimag)
	runtime.KeepAlive(cimagAllocMap)
	runtime.KeepAlive(crealAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbComplexNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/complex.h
func RbComplexNew(real VALUE, imag VALUE) VALUE {
	creal, crealAllocMap := (C.VALUE)(real), cgoAllocsUnknown
	cimag, cimagAllocMap := (C.VALUE)(imag), cgoAllocsUnknown
	__ret := C.rb_complex_new(creal, cimag)
	runtime.KeepAlive(cimagAllocMap)
	runtime.KeepAlive(crealAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbComplexNewPolar function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/complex.h
func RbComplexNewPolar(abs VALUE, arg VALUE) VALUE {
	cabs, cabsAllocMap := (C.VALUE)(abs), cgoAllocsUnknown
	carg, cargAllocMap := (C.VALUE)(arg), cgoAllocsUnknown
	__ret := C.rb_complex_new_polar(cabs, carg)
	runtime.KeepAlive(cargAllocMap)
	runtime.KeepAlive(cabsAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbComplexPolar function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/complex.h
func RbComplexPolar(abs VALUE, arg VALUE) VALUE {
	cabs, cabsAllocMap := (C.VALUE)(abs), cgoAllocsUnknown
	carg, cargAllocMap := (C.VALUE)(arg), cgoAllocsUnknown
	__ret := C.rb_complex_polar(cabs, carg)
	runtime.KeepAlive(cargAllocMap)
	runtime.KeepAlive(cabsAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbComplexReal function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/complex.h
func RbComplexReal(z VALUE) VALUE {
	cz, czAllocMap := (C.VALUE)(z), cgoAllocsUnknown
	__ret := C.rb_complex_real(cz)
	runtime.KeepAlive(czAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbComplexImag function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/complex.h
func RbComplexImag(z VALUE) VALUE {
	cz, czAllocMap := (C.VALUE)(z), cgoAllocsUnknown
	__ret := C.rb_complex_imag(cz)
	runtime.KeepAlive(czAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbComplexPlus function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/complex.h
func RbComplexPlus(x VALUE, y VALUE) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	cy, cyAllocMap := (C.VALUE)(y), cgoAllocsUnknown
	__ret := C.rb_complex_plus(cx, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbComplexMinus function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/complex.h
func RbComplexMinus(x VALUE, y VALUE) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	cy, cyAllocMap := (C.VALUE)(y), cgoAllocsUnknown
	__ret := C.rb_complex_minus(cx, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbComplexMul function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/complex.h
func RbComplexMul(x VALUE, y VALUE) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	cy, cyAllocMap := (C.VALUE)(y), cgoAllocsUnknown
	__ret := C.rb_complex_mul(cx, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbComplexDiv function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/complex.h
func RbComplexDiv(x VALUE, y VALUE) VALUE {
	cx, cxAllocMap := (C.VALUE)(x), cgoAllocsUnknown
	cy, cyAllocMap := (C.VALUE)(y), cgoAllocsUnknown
	__ret := C.rb_complex_div(cx, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbComplexUminus function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/complex.h
func RbComplexUminus(z VALUE) VALUE {
	cz, czAllocMap := (C.VALUE)(z), cgoAllocsUnknown
	__ret := C.rb_complex_uminus(cz)
	runtime.KeepAlive(czAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbComplexConjugate function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/complex.h
func RbComplexConjugate(z VALUE) VALUE {
	cz, czAllocMap := (C.VALUE)(z), cgoAllocsUnknown
	__ret := C.rb_complex_conjugate(cz)
	runtime.KeepAlive(czAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbComplexAbs function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/complex.h
func RbComplexAbs(z VALUE) VALUE {
	cz, czAllocMap := (C.VALUE)(z), cgoAllocsUnknown
	__ret := C.rb_complex_abs(cz)
	runtime.KeepAlive(czAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbComplexArg function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/complex.h
func RbComplexArg(z VALUE) VALUE {
	cz, czAllocMap := (C.VALUE)(z), cgoAllocsUnknown
	__ret := C.rb_complex_arg(cz)
	runtime.KeepAlive(czAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbComplexPow function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/complex.h
func RbComplexPow(base VALUE, exp VALUE) VALUE {
	cbase, cbaseAllocMap := (C.VALUE)(base), cgoAllocsUnknown
	cexp, cexpAllocMap := (C.VALUE)(exp), cgoAllocsUnknown
	__ret := C.rb_complex_pow(cbase, cexp)
	runtime.KeepAlive(cexpAllocMap)
	runtime.KeepAlive(cbaseAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDblComplexNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/complex.h
func RbDblComplexNew(real float64, imag float64) VALUE {
	creal, crealAllocMap := (C.double)(real), cgoAllocsUnknown
	cimag, cimagAllocMap := (C.double)(imag), cgoAllocsUnknown
	__ret := C.rb_dbl_complex_new(creal, cimag)
	runtime.KeepAlive(cimagAllocMap)
	runtime.KeepAlive(crealAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbComplex function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/complex.h
func RbComplex(real VALUE, imag VALUE) VALUE {
	creal, crealAllocMap := (C.VALUE)(real), cgoAllocsUnknown
	cimag, cimagAllocMap := (C.VALUE)(imag), cgoAllocsUnknown
	__ret := C.rb_Complex(creal, cimag)
	runtime.KeepAlive(cimagAllocMap)
	runtime.KeepAlive(crealAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFiberNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/cont.h
func RbFiberNew(_func RbBlockCallFuncT, callbackObj VALUE) VALUE {
	c_func, c_funcAllocMap := _func.PassValue()
	ccallbackObj, ccallbackObjAllocMap := (C.VALUE)(callbackObj), cgoAllocsUnknown
	__ret := C.rb_fiber_new(c_func, ccallbackObj)
	runtime.KeepAlive(ccallbackObjAllocMap)
	runtime.KeepAlive(c_funcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFiberNewStorage function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/cont.h
func RbFiberNewStorage(_func RbBlockCallFuncT, callbackObj VALUE, storage VALUE) VALUE {
	c_func, c_funcAllocMap := _func.PassValue()
	ccallbackObj, ccallbackObjAllocMap := (C.VALUE)(callbackObj), cgoAllocsUnknown
	cstorage, cstorageAllocMap := (C.VALUE)(storage), cgoAllocsUnknown
	__ret := C.rb_fiber_new_storage(c_func, ccallbackObj, cstorage)
	runtime.KeepAlive(cstorageAllocMap)
	runtime.KeepAlive(ccallbackObjAllocMap)
	runtime.KeepAlive(c_funcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFiberCurrent function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/cont.h
func RbFiberCurrent() VALUE {
	__ret := C.rb_fiber_current()
	__v := (VALUE)(__ret)
	return __v
}

// RbFiberAliveP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/cont.h
func RbFiberAliveP(fiber VALUE) VALUE {
	cfiber, cfiberAllocMap := (C.VALUE)(fiber), cgoAllocsUnknown
	__ret := C.rb_fiber_alive_p(cfiber)
	runtime.KeepAlive(cfiberAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjIsFiber function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/cont.h
func RbObjIsFiber(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_obj_is_fiber(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFiberResume function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/cont.h
func RbFiberResume(fiber VALUE, argc int32, argv []VALUE) VALUE {
	cfiber, cfiberAllocMap := (C.VALUE)(fiber), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_fiber_resume(cfiber, cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cfiberAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFiberResumeKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/cont.h
func RbFiberResumeKw(fiber VALUE, argc int32, argv []VALUE, kwSplat int32) VALUE {
	cfiber, cfiberAllocMap := (C.VALUE)(fiber), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	__ret := C.rb_fiber_resume_kw(cfiber, cargc, cargv, ckwSplat)
	runtime.KeepAlive(ckwSplatAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cfiberAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFiberYield function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/cont.h
func RbFiberYield(argc int32, argv []VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_fiber_yield(cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFiberYieldKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/cont.h
func RbFiberYieldKw(argc int32, argv []VALUE, kwSplat int32) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	__ret := C.rb_fiber_yield_kw(cargc, cargv, ckwSplat)
	runtime.KeepAlive(ckwSplatAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFiberTransfer function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/cont.h
func RbFiberTransfer(fiber VALUE, argc int32, argv []VALUE) VALUE {
	cfiber, cfiberAllocMap := (C.VALUE)(fiber), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_fiber_transfer(cfiber, cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cfiberAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFiberTransferKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/cont.h
func RbFiberTransferKw(fiber VALUE, argc int32, argv []VALUE, kwSplat int32) VALUE {
	cfiber, cfiberAllocMap := (C.VALUE)(fiber), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	__ret := C.rb_fiber_transfer_kw(cfiber, cargc, cargv, ckwSplat)
	runtime.KeepAlive(ckwSplatAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cfiberAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFiberRaise function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/cont.h
func RbFiberRaise(fiber VALUE, argc int32, argv []VALUE) VALUE {
	cfiber, cfiberAllocMap := (C.VALUE)(fiber), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_fiber_raise(cfiber, cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cfiberAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDirGetwd function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/dir.h
func RbDirGetwd() VALUE {
	__ret := C.rb_dir_getwd()
	__v := (VALUE)(__ret)
	return __v
}

// RbEnumValuesPack function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/enum.h
func RbEnumValuesPack(argc int32, argv []VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_enum_values_pack(cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbEnumeratorize function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/enumerator.h
func RbEnumeratorize(recv VALUE, meth VALUE, argc int32, argv []VALUE) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cmeth, cmethAllocMap := (C.VALUE)(meth), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_enumeratorize(crecv, cmeth, cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cmethAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbEnumeratorizeWithSize function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/enumerator.h
func RbEnumeratorizeWithSize(recv VALUE, meth VALUE, argc int32, argv []VALUE, _func RbEnumeratorSizeFunc) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cmeth, cmethAllocMap := (C.VALUE)(meth), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	c_func, c_funcAllocMap := _func.PassRef()
	__ret := C.rb_enumeratorize_with_size(crecv, cmeth, cargc, cargv, c_func)
	runtime.KeepAlive(c_funcAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cmethAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbEnumeratorizeWithSizeKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/enumerator.h
func RbEnumeratorizeWithSizeKw(recv VALUE, meth VALUE, argc int32, argv []VALUE, _func RbEnumeratorSizeFunc, kwSplat int32) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cmeth, cmethAllocMap := (C.VALUE)(meth), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	c_func, c_funcAllocMap := _func.PassRef()
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	__ret := C.rb_enumeratorize_with_size_kw(crecv, cmeth, cargc, cargv, c_func, ckwSplat)
	runtime.KeepAlive(ckwSplatAllocMap)
	runtime.KeepAlive(c_funcAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cmethAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbArithmeticSequenceExtract function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/enumerator.h
func RbArithmeticSequenceExtract(as VALUE, buf []RbArithmeticSequenceComponentsT) int32 {
	cas, casAllocMap := (C.VALUE)(as), cgoAllocsUnknown
	cbuf, cbufAllocMap := unpackArgSRbArithmeticSequenceComponentsT(buf)
	__ret := C.rb_arithmetic_sequence_extract(cas, cbuf)
	packSRbArithmeticSequenceComponentsT(buf, cbuf)
	runtime.KeepAlive(cbufAllocMap)
	runtime.KeepAlive(casAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbArithmeticSequenceBegLenStep function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/enumerator.h
func RbArithmeticSequenceBegLenStep(as VALUE, begp []int64, lenp []int64, stepp []int64, len int64, err int32) VALUE {
	cas, casAllocMap := (C.VALUE)(as), cgoAllocsUnknown
	cbegp, cbegpAllocMap := (*C.long)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&begp)).Data)), cgoAllocsUnknown
	clenp, clenpAllocMap := (*C.long)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&lenp)).Data)), cgoAllocsUnknown
	cstepp, csteppAllocMap := (*C.long)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&stepp)).Data)), cgoAllocsUnknown
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	cerr, cerrAllocMap := (C.int)(err), cgoAllocsUnknown
	__ret := C.rb_arithmetic_sequence_beg_len_step(cas, cbegp, clenp, cstepp, clen, cerr)
	runtime.KeepAlive(cerrAllocMap)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(csteppAllocMap)
	runtime.KeepAlive(clenpAllocMap)
	runtime.KeepAlive(cbegpAllocMap)
	runtime.KeepAlive(casAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbExcNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/error.h
func RbExcNew(etype VALUE, ptr string, len int64) VALUE {
	cetype, cetypeAllocMap := (C.VALUE)(etype), cgoAllocsUnknown
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_exc_new(cetype, cptr, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	runtime.KeepAlive(cetypeAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbExcNewCstr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/error.h
func RbExcNewCstr(etype VALUE, str string) VALUE {
	cetype, cetypeAllocMap := (C.VALUE)(etype), cgoAllocsUnknown
	str = safeString(str)
	cstr, cstrAllocMap := unpackPCharString(str)
	__ret := C.rb_exc_new_cstr(cetype, cstr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(cstrAllocMap)
	runtime.KeepAlive(cetypeAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbExcNewStr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/error.h
func RbExcNewStr(etype VALUE, str VALUE) VALUE {
	cetype, cetypeAllocMap := (C.VALUE)(etype), cgoAllocsUnknown
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_exc_new_str(cetype, cstr)
	runtime.KeepAlive(cstrAllocMap)
	runtime.KeepAlive(cetypeAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbLoaderror function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/error.h
func RbLoaderror(fmt string) {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	C.rb_loaderror(cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
}

// RbLoaderrorWithPath function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/error.h
func RbLoaderrorWithPath(path VALUE, fmt string) {
	cpath, cpathAllocMap := (C.VALUE)(path), cgoAllocsUnknown
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	C.rb_loaderror_with_path(cpath, cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	runtime.KeepAlive(cpathAllocMap)
}

// RbNameError function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/error.h
func RbNameError(name ID, fmt string) {
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	C.rb_name_error(cname, cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	runtime.KeepAlive(cnameAllocMap)
}

// RbNameErrorStr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/error.h
func RbNameErrorStr(name VALUE, fmt string) {
	cname, cnameAllocMap := (C.VALUE)(name), cgoAllocsUnknown
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	C.rb_name_error_str(cname, cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	runtime.KeepAlive(cnameAllocMap)
}

// RbFrozenErrorRaise function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/error.h
func RbFrozenErrorRaise(recv VALUE, fmt string) {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	C.rb_frozen_error_raise(crecv, cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	runtime.KeepAlive(crecvAllocMap)
}

// RbInvalidStr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/error.h
func RbInvalidStr(str string, kind string) {
	str = safeString(str)
	cstr, cstrAllocMap := unpackPCharString(str)
	kind = safeString(kind)
	ckind, ckindAllocMap := unpackPCharString(kind)
	C.rb_invalid_str(cstr, ckind)
	runtime.KeepAlive(kind)
	runtime.KeepAlive(ckindAllocMap)
	runtime.KeepAlive(str)
	runtime.KeepAlive(cstrAllocMap)
}

// RbErrorFrozen function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/error.h
func RbErrorFrozen(what string) {
	what = safeString(what)
	cwhat, cwhatAllocMap := unpackPCharString(what)
	C.rb_error_frozen(cwhat)
	runtime.KeepAlive(what)
	runtime.KeepAlive(cwhatAllocMap)
}

// RbErrorFrozenObject function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/error.h
func RbErrorFrozenObject(what VALUE) {
	cwhat, cwhatAllocMap := (C.VALUE)(what), cgoAllocsUnknown
	C.rb_error_frozen_object(cwhat)
	runtime.KeepAlive(cwhatAllocMap)
}

// RbCheckFrozen function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/error.h
func RbCheckFrozen(obj VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	C.rb_check_frozen(cobj)
	runtime.KeepAlive(cobjAllocMap)
}

// RbCheckCopyable function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/error.h
func RbCheckCopyable(obj VALUE, orig VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	corig, corigAllocMap := (C.VALUE)(orig), cgoAllocsUnknown
	C.rb_check_copyable(cobj, corig)
	runtime.KeepAlive(corigAllocMap)
	runtime.KeepAlive(cobjAllocMap)
}

// RbErrorArity function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/error.h
func RbErrorArity(argc int32, min int32, max int32) {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cmin, cminAllocMap := (C.int)(min), cgoAllocsUnknown
	cmax, cmaxAllocMap := (C.int)(max), cgoAllocsUnknown
	C.rb_error_arity(cargc, cmin, cmax)
	runtime.KeepAlive(cmaxAllocMap)
	runtime.KeepAlive(cminAllocMap)
	runtime.KeepAlive(cargcAllocMap)
}

// RbCheckFrozenInline function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/error.h
func RbCheckFrozenInline(obj VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	C.rb_check_frozen_inline(cobj)
	runtime.KeepAlive(cobjAllocMap)
}

// RbCheckArity function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/error.h
func RbCheckArity(argc int32, min int32, max int32) int32 {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cmin, cminAllocMap := (C.int)(min), cgoAllocsUnknown
	cmax, cmaxAllocMap := (C.int)(max), cgoAllocsUnknown
	__ret := C.rb_check_arity(cargc, cmin, cmax)
	runtime.KeepAlive(cmaxAllocMap)
	runtime.KeepAlive(cminAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbExcRaise function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/eval.h
func RbExcRaise(exc VALUE) {
	cexc, cexcAllocMap := (C.VALUE)(exc), cgoAllocsUnknown
	C.rb_exc_raise(cexc)
	runtime.KeepAlive(cexcAllocMap)
}

// RbExcFatal function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/eval.h
func RbExcFatal(exc VALUE) {
	cexc, cexcAllocMap := (C.VALUE)(exc), cgoAllocsUnknown
	C.rb_exc_fatal(cexc)
	runtime.KeepAlive(cexcAllocMap)
}

// RbFExit function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/eval.h
func RbFExit(argc int32, argv []VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_f_exit(cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFAbort function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/eval.h
func RbFAbort(argc int32, argv []VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_f_abort(cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbInterrupt function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/eval.h
func RbInterrupt() {
	C.rb_interrupt()
}

// RbFrameThisFunc function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/eval.h
func RbFrameThisFunc() ID {
	__ret := C.rb_frame_this_func()
	__v := (ID)(__ret)
	return __v
}

// RbJumpTag function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/eval.h
func RbJumpTag(state int32) {
	cstate, cstateAllocMap := (C.int)(state), cgoAllocsUnknown
	C.rb_jump_tag(cstate)
	runtime.KeepAlive(cstateAllocMap)
}

// RbObjCallInit function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/eval.h
func RbObjCallInit(obj VALUE, argc int32, argv []VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	C.rb_obj_call_init(cobj, cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cobjAllocMap)
}

// RbObjCallInitKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/eval.h
func RbObjCallInitKw(arg0 VALUE, arg1 int32, arg2 []VALUE, arg3 int32) {
	carg0, carg0AllocMap := (C.VALUE)(arg0), cgoAllocsUnknown
	carg1, carg1AllocMap := (C.int)(arg1), cgoAllocsUnknown
	carg2, carg2AllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&arg2)).Data)), cgoAllocsUnknown
	carg3, carg3AllocMap := (C.int)(arg3), cgoAllocsUnknown
	C.rb_obj_call_init_kw(carg0, carg1, carg2, carg3)
	runtime.KeepAlive(carg3AllocMap)
	runtime.KeepAlive(carg2AllocMap)
	runtime.KeepAlive(carg1AllocMap)
	runtime.KeepAlive(carg0AllocMap)
}

// RbFrameCallee function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/eval.h
func RbFrameCallee() ID {
	__ret := C.rb_frame_callee()
	__v := (ID)(__ret)
	return __v
}

// RbMakeException function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/eval.h
func RbMakeException(argc int32, argv []VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_make_exception(cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFileSExpandPath function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/file.h
func RbFileSExpandPath(argc int32, argv []VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_file_s_expand_path(cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFileExpandPath function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/file.h
func RbFileExpandPath(fname VALUE, dname VALUE) VALUE {
	cfname, cfnameAllocMap := (C.VALUE)(fname), cgoAllocsUnknown
	cdname, cdnameAllocMap := (C.VALUE)(dname), cgoAllocsUnknown
	__ret := C.rb_file_expand_path(cfname, cdname)
	runtime.KeepAlive(cdnameAllocMap)
	runtime.KeepAlive(cfnameAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFileSAbsolutePath function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/file.h
func RbFileSAbsolutePath(argc int32, argv []VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_file_s_absolute_path(cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFileAbsolutePath function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/file.h
func RbFileAbsolutePath(fname VALUE, dname VALUE) VALUE {
	cfname, cfnameAllocMap := (C.VALUE)(fname), cgoAllocsUnknown
	cdname, cdnameAllocMap := (C.VALUE)(dname), cgoAllocsUnknown
	__ret := C.rb_file_absolute_path(cfname, cdname)
	runtime.KeepAlive(cdnameAllocMap)
	runtime.KeepAlive(cfnameAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFileDirname function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/file.h
func RbFileDirname(fname VALUE) VALUE {
	cfname, cfnameAllocMap := (C.VALUE)(fname), cgoAllocsUnknown
	__ret := C.rb_file_dirname(cfname)
	runtime.KeepAlive(cfnameAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFindFileExt function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/file.h
func RbFindFileExt(feature []VALUE, exts []string) int32 {
	cfeature, cfeatureAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&feature)).Data)), cgoAllocsUnknown
	cexts, cextsAllocMap := unpackArgSString(exts)
	__ret := C.rb_find_file_ext(cfeature, cexts)
	packSString(exts, cexts)
	runtime.KeepAlive(cextsAllocMap)
	runtime.KeepAlive(cfeatureAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbFindFile function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/file.h
func RbFindFile(path VALUE) VALUE {
	cpath, cpathAllocMap := (C.VALUE)(path), cgoAllocsUnknown
	__ret := C.rb_find_file(cpath)
	runtime.KeepAlive(cpathAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFileDirectoryP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/file.h
func RbFileDirectoryP(arg VALUE, path VALUE) VALUE {
	carg, cargAllocMap := (C.VALUE)(arg), cgoAllocsUnknown
	cpath, cpathAllocMap := (C.VALUE)(path), cgoAllocsUnknown
	__ret := C.rb_file_directory_p(carg, cpath)
	runtime.KeepAlive(cpathAllocMap)
	runtime.KeepAlive(cargAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrEncodeOspath function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/file.h
func RbStrEncodeOspath(path VALUE) VALUE {
	cpath, cpathAllocMap := (C.VALUE)(path), cgoAllocsUnknown
	__ret := C.rb_str_encode_ospath(cpath)
	runtime.KeepAlive(cpathAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIsAbsolutePath function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/file.h
func RbIsAbsolutePath(path string) int32 {
	path = safeString(path)
	cpath, cpathAllocMap := unpackPCharString(path)
	__ret := C.rb_is_absolute_path(cpath)
	runtime.KeepAlive(path)
	runtime.KeepAlive(cpathAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbFileSize function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/file.h
func RbFileSize(file VALUE) int64 {
	cfile, cfileAllocMap := (C.VALUE)(file), cgoAllocsUnknown
	__ret := C.rb_file_size(cfile)
	runtime.KeepAlive(cfileAllocMap)
	__v := (int64)(__ret)
	return __v
}

// RbCheckHashType function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/hash.h
func RbCheckHashType(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_check_hash_type(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbHash function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/hash.h
func RbHash(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_hash(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbHashNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/hash.h
func RbHashNew() VALUE {
	__ret := C.rb_hash_new()
	__v := (VALUE)(__ret)
	return __v
}

// RbHashNewCapa function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/hash.h
func RbHashNewCapa(capa int64) VALUE {
	ccapa, ccapaAllocMap := (C.long)(capa), cgoAllocsUnknown
	__ret := C.rb_hash_new_capa(ccapa)
	runtime.KeepAlive(ccapaAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbHashDup function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/hash.h
func RbHashDup(hash VALUE) VALUE {
	chash, chashAllocMap := (C.VALUE)(hash), cgoAllocsUnknown
	__ret := C.rb_hash_dup(chash)
	runtime.KeepAlive(chashAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbHashFreeze function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/hash.h
func RbHashFreeze(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_hash_freeze(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbHashAref function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/hash.h
func RbHashAref(hash VALUE, key VALUE) VALUE {
	chash, chashAllocMap := (C.VALUE)(hash), cgoAllocsUnknown
	ckey, ckeyAllocMap := (C.VALUE)(key), cgoAllocsUnknown
	__ret := C.rb_hash_aref(chash, ckey)
	runtime.KeepAlive(ckeyAllocMap)
	runtime.KeepAlive(chashAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbHashLookup function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/hash.h
func RbHashLookup(hash VALUE, key VALUE) VALUE {
	chash, chashAllocMap := (C.VALUE)(hash), cgoAllocsUnknown
	ckey, ckeyAllocMap := (C.VALUE)(key), cgoAllocsUnknown
	__ret := C.rb_hash_lookup(chash, ckey)
	runtime.KeepAlive(ckeyAllocMap)
	runtime.KeepAlive(chashAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbHashLookup2 function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/hash.h
func RbHashLookup2(hash VALUE, key VALUE, def VALUE) VALUE {
	chash, chashAllocMap := (C.VALUE)(hash), cgoAllocsUnknown
	ckey, ckeyAllocMap := (C.VALUE)(key), cgoAllocsUnknown
	cdef, cdefAllocMap := (C.VALUE)(def), cgoAllocsUnknown
	__ret := C.rb_hash_lookup2(chash, ckey, cdef)
	runtime.KeepAlive(cdefAllocMap)
	runtime.KeepAlive(ckeyAllocMap)
	runtime.KeepAlive(chashAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbHashFetch function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/hash.h
func RbHashFetch(hash VALUE, key VALUE) VALUE {
	chash, chashAllocMap := (C.VALUE)(hash), cgoAllocsUnknown
	ckey, ckeyAllocMap := (C.VALUE)(key), cgoAllocsUnknown
	__ret := C.rb_hash_fetch(chash, ckey)
	runtime.KeepAlive(ckeyAllocMap)
	runtime.KeepAlive(chashAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbHashAset function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/hash.h
func RbHashAset(hash VALUE, key VALUE, val VALUE) VALUE {
	chash, chashAllocMap := (C.VALUE)(hash), cgoAllocsUnknown
	ckey, ckeyAllocMap := (C.VALUE)(key), cgoAllocsUnknown
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	__ret := C.rb_hash_aset(chash, ckey, cval)
	runtime.KeepAlive(cvalAllocMap)
	runtime.KeepAlive(ckeyAllocMap)
	runtime.KeepAlive(chashAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbHashClear function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/hash.h
func RbHashClear(hash VALUE) VALUE {
	chash, chashAllocMap := (C.VALUE)(hash), cgoAllocsUnknown
	__ret := C.rb_hash_clear(chash)
	runtime.KeepAlive(chashAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbHashDeleteIf function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/hash.h
func RbHashDeleteIf(hash VALUE) VALUE {
	chash, chashAllocMap := (C.VALUE)(hash), cgoAllocsUnknown
	__ret := C.rb_hash_delete_if(chash)
	runtime.KeepAlive(chashAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbHashDelete function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/hash.h
func RbHashDelete(hash VALUE, key VALUE) VALUE {
	chash, chashAllocMap := (C.VALUE)(hash), cgoAllocsUnknown
	ckey, ckeyAllocMap := (C.VALUE)(key), cgoAllocsUnknown
	__ret := C.rb_hash_delete(chash, ckey)
	runtime.KeepAlive(ckeyAllocMap)
	runtime.KeepAlive(chashAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbHashBulkInsert function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/hash.h
func RbHashBulkInsert(argc int64, argv []VALUE, hash VALUE) {
	cargc, cargcAllocMap := (C.long)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	chash, chashAllocMap := (C.VALUE)(hash), cgoAllocsUnknown
	C.rb_hash_bulk_insert(cargc, cargv, chash)
	runtime.KeepAlive(chashAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
}

// RbHashUpdateBy function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/hash.h
func RbHashUpdateBy(hash1 VALUE, hash2 VALUE, _func RbHashUpdateFunc) VALUE {
	chash1, chash1AllocMap := (C.VALUE)(hash1), cgoAllocsUnknown
	chash2, chash2AllocMap := (C.VALUE)(hash2), cgoAllocsUnknown
	c_func, c_funcAllocMap := _func.PassRef()
	__ret := C.rb_hash_update_by(chash1, chash2, c_func)
	runtime.KeepAlive(c_funcAllocMap)
	runtime.KeepAlive(chash2AllocMap)
	runtime.KeepAlive(chash1AllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbPathCheck function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/hash.h
func RbPathCheck(path string) int32 {
	path = safeString(path)
	cpath, cpathAllocMap := unpackPCharString(path)
	__ret := C.rb_path_check(cpath)
	runtime.KeepAlive(path)
	runtime.KeepAlive(cpathAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbEnvClear function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/hash.h
func RbEnvClear() VALUE {
	__ret := C.rb_env_clear()
	__v := (VALUE)(__ret)
	return __v
}

// RbHashSize function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/hash.h
func RbHashSize(hash VALUE) VALUE {
	chash, chashAllocMap := (C.VALUE)(hash), cgoAllocsUnknown
	__ret := C.rb_hash_size(chash)
	runtime.KeepAlive(chashAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIoWrite function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbIoWrite(io VALUE, str VALUE) VALUE {
	cio, cioAllocMap := (C.VALUE)(io), cgoAllocsUnknown
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_io_write(cio, cstr)
	runtime.KeepAlive(cstrAllocMap)
	runtime.KeepAlive(cioAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIoGets function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbIoGets(io VALUE) VALUE {
	cio, cioAllocMap := (C.VALUE)(io), cgoAllocsUnknown
	__ret := C.rb_io_gets(cio)
	runtime.KeepAlive(cioAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIoGetbyte function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbIoGetbyte(io VALUE) VALUE {
	cio, cioAllocMap := (C.VALUE)(io), cgoAllocsUnknown
	__ret := C.rb_io_getbyte(cio)
	runtime.KeepAlive(cioAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIoUngetc function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbIoUngetc(io VALUE, c VALUE) VALUE {
	cio, cioAllocMap := (C.VALUE)(io), cgoAllocsUnknown
	cc, ccAllocMap := (C.VALUE)(c), cgoAllocsUnknown
	__ret := C.rb_io_ungetc(cio, cc)
	runtime.KeepAlive(ccAllocMap)
	runtime.KeepAlive(cioAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIoUngetbyte function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbIoUngetbyte(io VALUE, b VALUE) VALUE {
	cio, cioAllocMap := (C.VALUE)(io), cgoAllocsUnknown
	cb, cbAllocMap := (C.VALUE)(b), cgoAllocsUnknown
	__ret := C.rb_io_ungetbyte(cio, cb)
	runtime.KeepAlive(cbAllocMap)
	runtime.KeepAlive(cioAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIoClose function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbIoClose(io VALUE) VALUE {
	cio, cioAllocMap := (C.VALUE)(io), cgoAllocsUnknown
	__ret := C.rb_io_close(cio)
	runtime.KeepAlive(cioAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIoFlush function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbIoFlush(io VALUE) VALUE {
	cio, cioAllocMap := (C.VALUE)(io), cgoAllocsUnknown
	__ret := C.rb_io_flush(cio)
	runtime.KeepAlive(cioAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIoEof function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbIoEof(io VALUE) VALUE {
	cio, cioAllocMap := (C.VALUE)(io), cgoAllocsUnknown
	__ret := C.rb_io_eof(cio)
	runtime.KeepAlive(cioAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIoBinmode function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbIoBinmode(io VALUE) VALUE {
	cio, cioAllocMap := (C.VALUE)(io), cgoAllocsUnknown
	__ret := C.rb_io_binmode(cio)
	runtime.KeepAlive(cioAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIoAscii8bitBinmode function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbIoAscii8bitBinmode(io VALUE) VALUE {
	cio, cioAllocMap := (C.VALUE)(io), cgoAllocsUnknown
	__ret := C.rb_io_ascii8bit_binmode(cio)
	runtime.KeepAlive(cioAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIoAddstr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbIoAddstr(io VALUE, str VALUE) VALUE {
	cio, cioAllocMap := (C.VALUE)(io), cgoAllocsUnknown
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_io_addstr(cio, cstr)
	runtime.KeepAlive(cstrAllocMap)
	runtime.KeepAlive(cioAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIoPrintf function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbIoPrintf(argc int32, argv []VALUE, io VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cio, cioAllocMap := (C.VALUE)(io), cgoAllocsUnknown
	__ret := C.rb_io_printf(cargc, cargv, cio)
	runtime.KeepAlive(cioAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIoPrint function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbIoPrint(argc int32, argv []VALUE, io VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cio, cioAllocMap := (C.VALUE)(io), cgoAllocsUnknown
	__ret := C.rb_io_print(cargc, cargv, cio)
	runtime.KeepAlive(cioAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIoPuts function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbIoPuts(argc int32, argv []VALUE, io VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cio, cioAllocMap := (C.VALUE)(io), cgoAllocsUnknown
	__ret := C.rb_io_puts(cargc, cargv, cio)
	runtime.KeepAlive(cioAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIoFdopen function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbIoFdopen(fd int32, flags int32, path string) VALUE {
	cfd, cfdAllocMap := (C.int)(fd), cgoAllocsUnknown
	cflags, cflagsAllocMap := (C.int)(flags), cgoAllocsUnknown
	path = safeString(path)
	cpath, cpathAllocMap := unpackPCharString(path)
	__ret := C.rb_io_fdopen(cfd, cflags, cpath)
	runtime.KeepAlive(path)
	runtime.KeepAlive(cpathAllocMap)
	runtime.KeepAlive(cflagsAllocMap)
	runtime.KeepAlive(cfdAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFileOpen function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbFileOpen(fname string, fmode string) VALUE {
	fname = safeString(fname)
	cfname, cfnameAllocMap := unpackPCharString(fname)
	fmode = safeString(fmode)
	cfmode, cfmodeAllocMap := unpackPCharString(fmode)
	__ret := C.rb_file_open(cfname, cfmode)
	runtime.KeepAlive(fmode)
	runtime.KeepAlive(cfmodeAllocMap)
	runtime.KeepAlive(fname)
	runtime.KeepAlive(cfnameAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFileOpenStr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbFileOpenStr(fname VALUE, fmode string) VALUE {
	cfname, cfnameAllocMap := (C.VALUE)(fname), cgoAllocsUnknown
	fmode = safeString(fmode)
	cfmode, cfmodeAllocMap := unpackPCharString(fmode)
	__ret := C.rb_file_open_str(cfname, cfmode)
	runtime.KeepAlive(fmode)
	runtime.KeepAlive(cfmodeAllocMap)
	runtime.KeepAlive(cfnameAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbGets function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbGets() VALUE {
	__ret := C.rb_gets()
	__v := (VALUE)(__ret)
	return __v
}

// RbWriteError function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbWriteError(str string) {
	str = safeString(str)
	cstr, cstrAllocMap := unpackPCharString(str)
	C.rb_write_error(cstr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(cstrAllocMap)
}

// RbWriteError2 function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbWriteError2(str string, len int64) {
	str = safeString(str)
	cstr, cstrAllocMap := unpackPCharString(str)
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	C.rb_write_error2(cstr, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(str)
	runtime.KeepAlive(cstrAllocMap)
}

// RbCloseBeforeExec function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbCloseBeforeExec(lowfd int32, maxhint int32, nocloseFds VALUE) {
	clowfd, clowfdAllocMap := (C.int)(lowfd), cgoAllocsUnknown
	cmaxhint, cmaxhintAllocMap := (C.int)(maxhint), cgoAllocsUnknown
	cnocloseFds, cnocloseFdsAllocMap := (C.VALUE)(nocloseFds), cgoAllocsUnknown
	C.rb_close_before_exec(clowfd, cmaxhint, cnocloseFds)
	runtime.KeepAlive(cnocloseFdsAllocMap)
	runtime.KeepAlive(cmaxhintAllocMap)
	runtime.KeepAlive(clowfdAllocMap)
}

// RbPipe function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbPipe(pipes []int32) int32 {
	cpipes, cpipesAllocMap := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&pipes)).Data)), cgoAllocsUnknown
	__ret := C.rb_pipe(cpipes)
	runtime.KeepAlive(cpipesAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbReservedFdP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbReservedFdP(fd int32) int32 {
	cfd, cfdAllocMap := (C.int)(fd), cgoAllocsUnknown
	__ret := C.rb_reserved_fd_p(cfd)
	runtime.KeepAlive(cfdAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbCloexecOpen function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbCloexecOpen(pathname string, flags int32, mode uint16) int32 {
	pathname = safeString(pathname)
	cpathname, cpathnameAllocMap := unpackPCharString(pathname)
	cflags, cflagsAllocMap := (C.int)(flags), cgoAllocsUnknown
	cmode, cmodeAllocMap := (C.mode_t)(mode), cgoAllocsUnknown
	__ret := C.rb_cloexec_open(cpathname, cflags, cmode)
	runtime.KeepAlive(cmodeAllocMap)
	runtime.KeepAlive(cflagsAllocMap)
	runtime.KeepAlive(pathname)
	runtime.KeepAlive(cpathnameAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbCloexecDup function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbCloexecDup(oldfd int32) int32 {
	coldfd, coldfdAllocMap := (C.int)(oldfd), cgoAllocsUnknown
	__ret := C.rb_cloexec_dup(coldfd)
	runtime.KeepAlive(coldfdAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbCloexecDup2 function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbCloexecDup2(oldfd int32, newfd int32) int32 {
	coldfd, coldfdAllocMap := (C.int)(oldfd), cgoAllocsUnknown
	cnewfd, cnewfdAllocMap := (C.int)(newfd), cgoAllocsUnknown
	__ret := C.rb_cloexec_dup2(coldfd, cnewfd)
	runtime.KeepAlive(cnewfdAllocMap)
	runtime.KeepAlive(coldfdAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbCloexecPipe function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbCloexecPipe(fildes []int32) int32 {
	cfildes, cfildesAllocMap := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&fildes)).Data)), cgoAllocsUnknown
	__ret := C.rb_cloexec_pipe(cfildes)
	runtime.KeepAlive(cfildesAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbCloexecFcntlDupfd function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbCloexecFcntlDupfd(fd int32, minfd int32) int32 {
	cfd, cfdAllocMap := (C.int)(fd), cgoAllocsUnknown
	cminfd, cminfdAllocMap := (C.int)(minfd), cgoAllocsUnknown
	__ret := C.rb_cloexec_fcntl_dupfd(cfd, cminfd)
	runtime.KeepAlive(cminfdAllocMap)
	runtime.KeepAlive(cfdAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbUpdateMaxFd function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/io.h
func RbUpdateMaxFd(fd int32) {
	cfd, cfdAllocMap := (C.int)(fd), cgoAllocsUnknown
	C.rb_update_max_fd(cfd)
	runtime.KeepAlive(cfdAllocMap)
}

// RbFdFixCloexec function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/intern/io.h
func RbFdFixCloexec(fd int32) {
	cfd, cfdAllocMap := (C.int)(fd), cgoAllocsUnknown
	C.rb_fd_fix_cloexec(cfd)
	runtime.KeepAlive(cfdAllocMap)
}

// RbLoad function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/load.h
func RbLoad(path VALUE, wrap int32) {
	cpath, cpathAllocMap := (C.VALUE)(path), cgoAllocsUnknown
	cwrap, cwrapAllocMap := (C.int)(wrap), cgoAllocsUnknown
	C.rb_load(cpath, cwrap)
	runtime.KeepAlive(cwrapAllocMap)
	runtime.KeepAlive(cpathAllocMap)
}

// RbLoadProtect function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/load.h
func RbLoadProtect(path VALUE, wrap int32, state []int32) {
	cpath, cpathAllocMap := (C.VALUE)(path), cgoAllocsUnknown
	cwrap, cwrapAllocMap := (C.int)(wrap), cgoAllocsUnknown
	cstate, cstateAllocMap := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&state)).Data)), cgoAllocsUnknown
	C.rb_load_protect(cpath, cwrap, cstate)
	runtime.KeepAlive(cstateAllocMap)
	runtime.KeepAlive(cwrapAllocMap)
	runtime.KeepAlive(cpathAllocMap)
}

// RbProvided function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/load.h
func RbProvided(feature string) int32 {
	feature = safeString(feature)
	cfeature, cfeatureAllocMap := unpackPCharString(feature)
	__ret := C.rb_provided(cfeature)
	runtime.KeepAlive(feature)
	runtime.KeepAlive(cfeatureAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbFeatureProvided function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/load.h
func RbFeatureProvided(feature string, loading []string) int32 {
	feature = safeString(feature)
	cfeature, cfeatureAllocMap := unpackPCharString(feature)
	cloading, cloadingAllocMap := unpackArgSString(loading)
	__ret := C.rb_feature_provided(cfeature, cloading)
	packSString(loading, cloading)
	runtime.KeepAlive(cloadingAllocMap)
	runtime.KeepAlive(feature)
	runtime.KeepAlive(cfeatureAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbProvide function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/load.h
func RbProvide(feature string) {
	feature = safeString(feature)
	cfeature, cfeatureAllocMap := unpackPCharString(feature)
	C.rb_provide(cfeature)
	runtime.KeepAlive(feature)
	runtime.KeepAlive(cfeatureAllocMap)
}

// RbFRequire function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/load.h
func RbFRequire(self VALUE, feature VALUE) VALUE {
	cself, cselfAllocMap := (C.VALUE)(self), cgoAllocsUnknown
	cfeature, cfeatureAllocMap := (C.VALUE)(feature), cgoAllocsUnknown
	__ret := C.rb_f_require(cself, cfeature)
	runtime.KeepAlive(cfeatureAllocMap)
	runtime.KeepAlive(cselfAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRequireString function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/load.h
func RbRequireString(feature VALUE) VALUE {
	cfeature, cfeatureAllocMap := (C.VALUE)(feature), cgoAllocsUnknown
	__ret := C.rb_require_string(cfeature)
	runtime.KeepAlive(cfeatureAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbExtResolveSymbol function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/load.h
func RbExtResolveSymbol(feature string, symbol string) unsafe.Pointer {
	feature = safeString(feature)
	cfeature, cfeatureAllocMap := unpackPCharString(feature)
	symbol = safeString(symbol)
	csymbol, csymbolAllocMap := unpackPCharString(symbol)
	__ret := C.rb_ext_resolve_symbol(cfeature, csymbol)
	runtime.KeepAlive(symbol)
	runtime.KeepAlive(csymbolAllocMap)
	runtime.KeepAlive(feature)
	runtime.KeepAlive(cfeatureAllocMap)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// RbExtRactorSafe function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/load.h
func RbExtRactorSafe(flag bool) {
	cflag, cflagAllocMap := (C._Bool)(flag), cgoAllocsUnknown
	C.rb_ext_ractor_safe(cflag)
	runtime.KeepAlive(cflagAllocMap)
}

// RbMarshalDump function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/marshal.h
func RbMarshalDump(obj VALUE, port VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cport, cportAllocMap := (C.VALUE)(port), cgoAllocsUnknown
	__ret := C.rb_marshal_dump(cobj, cport)
	runtime.KeepAlive(cportAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbMarshalLoad function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/marshal.h
func RbMarshalLoad(port VALUE) VALUE {
	cport, cportAllocMap := (C.VALUE)(port), cgoAllocsUnknown
	__ret := C.rb_marshal_load(cport)
	runtime.KeepAlive(cportAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbMarshalDefineCompat function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/marshal.h
func RbMarshalDefineCompat(newclass VALUE, oldclass VALUE, dumper VALUE, loader VALUE) {
	cnewclass, cnewclassAllocMap := (C.VALUE)(newclass), cgoAllocsUnknown
	coldclass, coldclassAllocMap := (C.VALUE)(oldclass), cgoAllocsUnknown
	cdumper, cdumperAllocMap := dumper.PassRef()
	cloader, cloaderAllocMap := loader.PassRef()
	C.rb_marshal_define_compat(cnewclass, coldclass, cdumper, cloader)
	runtime.KeepAlive(cloaderAllocMap)
	runtime.KeepAlive(cdumperAllocMap)
	runtime.KeepAlive(coldclassAllocMap)
	runtime.KeepAlive(cnewclassAllocMap)
}

// RbNumZerodiv function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/numeric.h
func RbNumZerodiv() {
	C.rb_num_zerodiv()
}

// RbNumCoerceBin function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/numeric.h
func RbNumCoerceBin(lhs VALUE, rhs VALUE, op ID) VALUE {
	clhs, clhsAllocMap := (C.VALUE)(lhs), cgoAllocsUnknown
	crhs, crhsAllocMap := (C.VALUE)(rhs), cgoAllocsUnknown
	cop, copAllocMap := (C.ID)(op), cgoAllocsUnknown
	__ret := C.rb_num_coerce_bin(clhs, crhs, cop)
	runtime.KeepAlive(copAllocMap)
	runtime.KeepAlive(crhsAllocMap)
	runtime.KeepAlive(clhsAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbNumCoerceCmp function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/numeric.h
func RbNumCoerceCmp(lhs VALUE, rhs VALUE, op ID) VALUE {
	clhs, clhsAllocMap := (C.VALUE)(lhs), cgoAllocsUnknown
	crhs, crhsAllocMap := (C.VALUE)(rhs), cgoAllocsUnknown
	cop, copAllocMap := (C.ID)(op), cgoAllocsUnknown
	__ret := C.rb_num_coerce_cmp(clhs, crhs, cop)
	runtime.KeepAlive(copAllocMap)
	runtime.KeepAlive(crhsAllocMap)
	runtime.KeepAlive(clhsAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbNumCoerceRelop function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/numeric.h
func RbNumCoerceRelop(lhs VALUE, rhs VALUE, op ID) VALUE {
	clhs, clhsAllocMap := (C.VALUE)(lhs), cgoAllocsUnknown
	crhs, crhsAllocMap := (C.VALUE)(rhs), cgoAllocsUnknown
	cop, copAllocMap := (C.ID)(op), cgoAllocsUnknown
	__ret := C.rb_num_coerce_relop(clhs, crhs, cop)
	runtime.KeepAlive(copAllocMap)
	runtime.KeepAlive(crhsAllocMap)
	runtime.KeepAlive(clhsAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbNumCoerceBit function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/numeric.h
func RbNumCoerceBit(lhs VALUE, rhs VALUE, op ID) VALUE {
	clhs, clhsAllocMap := (C.VALUE)(lhs), cgoAllocsUnknown
	crhs, crhsAllocMap := (C.VALUE)(rhs), cgoAllocsUnknown
	cop, copAllocMap := (C.ID)(op), cgoAllocsUnknown
	__ret := C.rb_num_coerce_bit(clhs, crhs, cop)
	runtime.KeepAlive(copAllocMap)
	runtime.KeepAlive(crhsAllocMap)
	runtime.KeepAlive(clhsAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbNum2fix function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/numeric.h
func RbNum2fix(val VALUE) VALUE {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	__ret := C.rb_num2fix(cval)
	runtime.KeepAlive(cvalAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFix2str function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/numeric.h
func RbFix2str(val VALUE, base int32) VALUE {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	cbase, cbaseAllocMap := (C.int)(base), cgoAllocsUnknown
	__ret := C.rb_fix2str(cval, cbase)
	runtime.KeepAlive(cbaseAllocMap)
	runtime.KeepAlive(cvalAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDblCmp function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/numeric.h
func RbDblCmp(lhs float64, rhs float64) VALUE {
	clhs, clhsAllocMap := (C.double)(lhs), cgoAllocsUnknown
	crhs, crhsAllocMap := (C.double)(rhs), cgoAllocsUnknown
	__ret := C.rb_dbl_cmp(clhs, crhs)
	runtime.KeepAlive(crhsAllocMap)
	runtime.KeepAlive(clhsAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIntPositivePow function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/numeric.h
func RbIntPositivePow(x int64, y uint64) VALUE {
	cx, cxAllocMap := (C.long)(x), cgoAllocsUnknown
	cy, cyAllocMap := (C.ulong)(y), cgoAllocsUnknown
	__ret := C.rb_int_positive_pow(cx, cy)
	runtime.KeepAlive(cyAllocMap)
	runtime.KeepAlive(cxAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbClassNewInstancePassKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbClassNewInstancePassKw(argc int32, argv []VALUE, klass VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	__ret := C.rb_class_new_instance_pass_kw(cargc, cargv, cklass)
	runtime.KeepAlive(cklassAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbClassNewInstance function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbClassNewInstance(argc int32, argv []VALUE, klass VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	__ret := C.rb_class_new_instance(cargc, cargv, cklass)
	runtime.KeepAlive(cklassAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbClassNewInstanceKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbClassNewInstanceKw(argc int32, argv []VALUE, klass VALUE, kwSplat int32) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	__ret := C.rb_class_new_instance_kw(cargc, cargv, cklass, ckwSplat)
	runtime.KeepAlive(ckwSplatAllocMap)
	runtime.KeepAlive(cklassAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbEql function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbEql(lhs VALUE, rhs VALUE) int32 {
	clhs, clhsAllocMap := (C.VALUE)(lhs), cgoAllocsUnknown
	crhs, crhsAllocMap := (C.VALUE)(rhs), cgoAllocsUnknown
	__ret := C.rb_eql(clhs, crhs)
	runtime.KeepAlive(crhsAllocMap)
	runtime.KeepAlive(clhsAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbAnyToS function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbAnyToS(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_any_to_s(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbInspect function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbInspect(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_inspect(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjIsInstanceOf function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbObjIsInstanceOf(obj VALUE, klass VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	__ret := C.rb_obj_is_instance_of(cobj, cklass)
	runtime.KeepAlive(cklassAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjIsKindOf function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbObjIsKindOf(obj VALUE, klass VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	__ret := C.rb_obj_is_kind_of(cobj, cklass)
	runtime.KeepAlive(cklassAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjAlloc function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbObjAlloc(klass VALUE) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	__ret := C.rb_obj_alloc(cklass)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjClone function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbObjClone(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_obj_clone(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjDup function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbObjDup(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_obj_dup(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjInitCopy function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbObjInitCopy(src VALUE, dst VALUE) VALUE {
	csrc, csrcAllocMap := (C.VALUE)(src), cgoAllocsUnknown
	cdst, cdstAllocMap := (C.VALUE)(dst), cgoAllocsUnknown
	__ret := C.rb_obj_init_copy(csrc, cdst)
	runtime.KeepAlive(cdstAllocMap)
	runtime.KeepAlive(csrcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjFreeze function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbObjFreeze(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_obj_freeze(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjFrozenP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbObjFrozenP(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_obj_frozen_p(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjId function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbObjId(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_obj_id(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbMemoryId function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbMemoryId(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_memory_id(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbClassReal function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbClassReal(klass VALUE) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	__ret := C.rb_class_real(cklass)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbClassInheritedP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbClassInheritedP(scion VALUE, ascendant VALUE) VALUE {
	cscion, cscionAllocMap := (C.VALUE)(scion), cgoAllocsUnknown
	cascendant, cascendantAllocMap := (C.VALUE)(ascendant), cgoAllocsUnknown
	__ret := C.rb_class_inherited_p(cscion, cascendant)
	runtime.KeepAlive(cascendantAllocMap)
	runtime.KeepAlive(cscionAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbClassSuperclass function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbClassSuperclass(klass VALUE) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	__ret := C.rb_class_superclass(cklass)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbConvertType function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbConvertType(val VALUE, kind int32, name string, mid string) VALUE {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	ckind, ckindAllocMap := (C.int)(kind), cgoAllocsUnknown
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	mid = safeString(mid)
	cmid, cmidAllocMap := unpackPCharString(mid)
	__ret := C.rb_convert_type(cval, ckind, cname, cmid)
	runtime.KeepAlive(mid)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(ckindAllocMap)
	runtime.KeepAlive(cvalAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCheckConvertType function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbCheckConvertType(val VALUE, kind int32, name string, mid string) VALUE {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	ckind, ckindAllocMap := (C.int)(kind), cgoAllocsUnknown
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	mid = safeString(mid)
	cmid, cmidAllocMap := unpackPCharString(mid)
	__ret := C.rb_check_convert_type(cval, ckind, cname, cmid)
	runtime.KeepAlive(mid)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(ckindAllocMap)
	runtime.KeepAlive(cvalAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCheckToInteger function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbCheckToInteger(val VALUE, mid string) VALUE {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	mid = safeString(mid)
	cmid, cmidAllocMap := unpackPCharString(mid)
	__ret := C.rb_check_to_integer(cval, cmid)
	runtime.KeepAlive(mid)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(cvalAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCheckToFloat function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbCheckToFloat(val VALUE) VALUE {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	__ret := C.rb_check_to_float(cval)
	runtime.KeepAlive(cvalAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbToInt function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbToInt(val VALUE) VALUE {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	__ret := C.rb_to_int(cval)
	runtime.KeepAlive(cvalAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCheckToInt function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbCheckToInt(val VALUE) VALUE {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	__ret := C.rb_check_to_int(cval)
	runtime.KeepAlive(cvalAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbInteger function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbInteger(val VALUE) VALUE {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	__ret := C.rb_Integer(cval)
	runtime.KeepAlive(cvalAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbToFloat function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbToFloat(val VALUE) VALUE {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	__ret := C.rb_to_float(cval)
	runtime.KeepAlive(cvalAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFloat function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbFloat(val VALUE) VALUE {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	__ret := C.rb_Float(cval)
	runtime.KeepAlive(cvalAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbString function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbString(val VALUE) VALUE {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	__ret := C.rb_String(cval)
	runtime.KeepAlive(cvalAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbArray function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbArray(val VALUE) VALUE {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	__ret := C.rb_Array(cval)
	runtime.KeepAlive(cvalAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCstrToDbl function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbCstrToDbl(str string, mode int32) float64 {
	str = safeString(str)
	cstr, cstrAllocMap := unpackPCharString(str)
	cmode, cmodeAllocMap := (C.int)(mode), cgoAllocsUnknown
	__ret := C.rb_cstr_to_dbl(cstr, cmode)
	runtime.KeepAlive(cmodeAllocMap)
	runtime.KeepAlive(str)
	runtime.KeepAlive(cstrAllocMap)
	__v := (float64)(__ret)
	return __v
}

// RbStrToDbl function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/object.h
func RbStrToDbl(str VALUE, mode int32) float64 {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	cmode, cmodeAllocMap := (C.int)(mode), cgoAllocsUnknown
	__ret := C.rb_str_to_dbl(cstr, cmode)
	runtime.KeepAlive(cmodeAllocMap)
	runtime.KeepAlive(cstrAllocMap)
	__v := (float64)(__ret)
	return __v
}

// RbIdAttrset function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/parse.h
func RbIdAttrset(id ID) ID {
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	__ret := C.rb_id_attrset(cid)
	runtime.KeepAlive(cidAllocMap)
	__v := (ID)(__ret)
	return __v
}

// RbIsConstId function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/parse.h
func RbIsConstId(id ID) int32 {
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	__ret := C.rb_is_const_id(cid)
	runtime.KeepAlive(cidAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbIsGlobalId function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/parse.h
func RbIsGlobalId(id ID) int32 {
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	__ret := C.rb_is_global_id(cid)
	runtime.KeepAlive(cidAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbIsInstanceId function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/parse.h
func RbIsInstanceId(id ID) int32 {
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	__ret := C.rb_is_instance_id(cid)
	runtime.KeepAlive(cidAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbIsAttrsetId function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/parse.h
func RbIsAttrsetId(id ID) int32 {
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	__ret := C.rb_is_attrset_id(cid)
	runtime.KeepAlive(cidAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbIsClassId function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/parse.h
func RbIsClassId(id ID) int32 {
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	__ret := C.rb_is_class_id(cid)
	runtime.KeepAlive(cidAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbIsLocalId function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/parse.h
func RbIsLocalId(id ID) int32 {
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	__ret := C.rb_is_local_id(cid)
	runtime.KeepAlive(cidAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbIsJunkId function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/parse.h
func RbIsJunkId(arg0 ID) int32 {
	carg0, carg0AllocMap := (C.ID)(arg0), cgoAllocsUnknown
	__ret := C.rb_is_junk_id(carg0)
	runtime.KeepAlive(carg0AllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbSymnameP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/parse.h
func RbSymnameP(str string) int32 {
	str = safeString(str)
	cstr, cstrAllocMap := unpackPCharString(str)
	__ret := C.rb_symname_p(cstr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(cstrAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbBackrefGet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/parse.h
func RbBackrefGet() VALUE {
	__ret := C.rb_backref_get()
	__v := (VALUE)(__ret)
	return __v
}

// RbBackrefSet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/parse.h
func RbBackrefSet(md VALUE) {
	cmd, cmdAllocMap := (C.VALUE)(md), cgoAllocsUnknown
	C.rb_backref_set(cmd)
	runtime.KeepAlive(cmdAllocMap)
}

// RbLastlineGet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/parse.h
func RbLastlineGet() VALUE {
	__ret := C.rb_lastline_get()
	__v := (VALUE)(__ret)
	return __v
}

// RbLastlineSet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/parse.h
func RbLastlineSet(str VALUE) {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	C.rb_lastline_set(cstr)
	runtime.KeepAlive(cstrAllocMap)
}

// RbSymAllSymbols function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/parse.h
func RbSymAllSymbols() VALUE {
	__ret := C.rb_sym_all_symbols()
	__v := (VALUE)(__ret)
	return __v
}

// RbBlockProc function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/proc.h
func RbBlockProc() VALUE {
	__ret := C.rb_block_proc()
	__v := (VALUE)(__ret)
	return __v
}

// RbBlockLambda function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/proc.h
func RbBlockLambda() VALUE {
	__ret := C.rb_block_lambda()
	__v := (VALUE)(__ret)
	return __v
}

// RbProcNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/proc.h
func RbProcNew(_func RbBlockCallFuncT, callbackArg VALUE) VALUE {
	c_func, c_funcAllocMap := _func.PassValue()
	ccallbackArg, ccallbackArgAllocMap := (C.VALUE)(callbackArg), cgoAllocsUnknown
	__ret := C.rb_proc_new(c_func, ccallbackArg)
	runtime.KeepAlive(ccallbackArgAllocMap)
	runtime.KeepAlive(c_funcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjIsProc function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/proc.h
func RbObjIsProc(recv VALUE) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	__ret := C.rb_obj_is_proc(crecv)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbProcCall function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/proc.h
func RbProcCall(recv VALUE, args VALUE) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cargs, cargsAllocMap := (C.VALUE)(args), cgoAllocsUnknown
	__ret := C.rb_proc_call(crecv, cargs)
	runtime.KeepAlive(cargsAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbProcCallKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/proc.h
func RbProcCallKw(recv VALUE, args VALUE, kwSplat int32) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cargs, cargsAllocMap := (C.VALUE)(args), cgoAllocsUnknown
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	__ret := C.rb_proc_call_kw(crecv, cargs, ckwSplat)
	runtime.KeepAlive(ckwSplatAllocMap)
	runtime.KeepAlive(cargsAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbProcCallWithBlock function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/proc.h
func RbProcCallWithBlock(recv VALUE, argc int32, argv []VALUE, proc VALUE) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cproc, cprocAllocMap := (C.VALUE)(proc), cgoAllocsUnknown
	__ret := C.rb_proc_call_with_block(crecv, cargc, cargv, cproc)
	runtime.KeepAlive(cprocAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbProcCallWithBlockKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/proc.h
func RbProcCallWithBlockKw(recv VALUE, argc int32, argv []VALUE, proc VALUE, kwSplat int32) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cproc, cprocAllocMap := (C.VALUE)(proc), cgoAllocsUnknown
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	__ret := C.rb_proc_call_with_block_kw(crecv, cargc, cargv, cproc, ckwSplat)
	runtime.KeepAlive(ckwSplatAllocMap)
	runtime.KeepAlive(cprocAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbProcArity function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/proc.h
func RbProcArity(recv VALUE) int32 {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	__ret := C.rb_proc_arity(crecv)
	runtime.KeepAlive(crecvAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbProcLambdaP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/proc.h
func RbProcLambdaP(recv VALUE) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	__ret := C.rb_proc_lambda_p(crecv)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBindingNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/proc.h
func RbBindingNew() VALUE {
	__ret := C.rb_binding_new()
	__v := (VALUE)(__ret)
	return __v
}

// RbObjMethod function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/proc.h
func RbObjMethod(recv VALUE, mid VALUE) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.VALUE)(mid), cgoAllocsUnknown
	__ret := C.rb_obj_method(crecv, cmid)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjIsMethod function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/proc.h
func RbObjIsMethod(recv VALUE) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	__ret := C.rb_obj_is_method(crecv)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbMethodCall function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/proc.h
func RbMethodCall(argc int32, argv []VALUE, recv VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	__ret := C.rb_method_call(cargc, cargv, crecv)
	runtime.KeepAlive(crecvAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbMethodCallKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/proc.h
func RbMethodCallKw(argc int32, argv []VALUE, recv VALUE, kwSplat int32) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	__ret := C.rb_method_call_kw(cargc, cargv, crecv, ckwSplat)
	runtime.KeepAlive(ckwSplatAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbMethodCallWithBlock function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/proc.h
func RbMethodCallWithBlock(argc int32, argv []VALUE, recv VALUE, proc VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cproc, cprocAllocMap := (C.VALUE)(proc), cgoAllocsUnknown
	__ret := C.rb_method_call_with_block(cargc, cargv, crecv, cproc)
	runtime.KeepAlive(cprocAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbMethodCallWithBlockKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/proc.h
func RbMethodCallWithBlockKw(argc int32, argv []VALUE, recv VALUE, proc VALUE, kwSplat int32) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cproc, cprocAllocMap := (C.VALUE)(proc), cgoAllocsUnknown
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	__ret := C.rb_method_call_with_block_kw(cargc, cargv, crecv, cproc, ckwSplat)
	runtime.KeepAlive(ckwSplatAllocMap)
	runtime.KeepAlive(cprocAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbModMethodArity function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/proc.h
func RbModMethodArity(mod VALUE, mid ID) int32 {
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	__ret := C.rb_mod_method_arity(cmod, cmid)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(cmodAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbObjMethodArity function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/proc.h
func RbObjMethodArity(obj VALUE, mid ID) int32 {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	__ret := C.rb_obj_method_arity(cobj, cmid)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbProtect function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/proc.h
func RbProtect(_func VALUE, args VALUE, state []int32) VALUE {
	c_func, c_funcAllocMap := _func.PassRef()
	cargs, cargsAllocMap := (C.VALUE)(args), cgoAllocsUnknown
	cstate, cstateAllocMap := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&state)).Data)), cgoAllocsUnknown
	__ret := C.rb_protect(c_func, cargs, cstate)
	runtime.KeepAlive(cstateAllocMap)
	runtime.KeepAlive(cargsAllocMap)
	runtime.KeepAlive(c_funcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbProcessStatusWait function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/process.h
func RbProcessStatusWait(pid int32, flags int32) VALUE {
	cpid, cpidAllocMap := (C.pid_t)(pid), cgoAllocsUnknown
	cflags, cflagsAllocMap := (C.int)(flags), cgoAllocsUnknown
	__ret := C.rb_process_status_wait(cpid, cflags)
	runtime.KeepAlive(cflagsAllocMap)
	runtime.KeepAlive(cpidAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbLastStatusSet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/process.h
func RbLastStatusSet(status int32, pid int32) {
	cstatus, cstatusAllocMap := (C.int)(status), cgoAllocsUnknown
	cpid, cpidAllocMap := (C.pid_t)(pid), cgoAllocsUnknown
	C.rb_last_status_set(cstatus, cpid)
	runtime.KeepAlive(cpidAllocMap)
	runtime.KeepAlive(cstatusAllocMap)
}

// RbLastStatusGet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/process.h
func RbLastStatusGet() VALUE {
	__ret := C.rb_last_status_get()
	__v := (VALUE)(__ret)
	return __v
}

// RbProcExec function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/process.h
func RbProcExec(cmd string) int32 {
	cmd = safeString(cmd)
	ccmd, ccmdAllocMap := unpackPCharString(cmd)
	__ret := C.rb_proc_exec(ccmd)
	runtime.KeepAlive(cmd)
	runtime.KeepAlive(ccmdAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbFExec function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/process.h
func RbFExec(argc int32, argv []VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_f_exec(cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbWaitpid function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/process.h
func RbWaitpid(pid int32, status []int32, flags int32) int32 {
	cpid, cpidAllocMap := (C.pid_t)(pid), cgoAllocsUnknown
	cstatus, cstatusAllocMap := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&status)).Data)), cgoAllocsUnknown
	cflags, cflagsAllocMap := (C.int)(flags), cgoAllocsUnknown
	__ret := C.rb_waitpid(cpid, cstatus, cflags)
	runtime.KeepAlive(cflagsAllocMap)
	runtime.KeepAlive(cstatusAllocMap)
	runtime.KeepAlive(cpidAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbSyswait function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/process.h
func RbSyswait(pid int32) {
	cpid, cpidAllocMap := (C.pid_t)(pid), cgoAllocsUnknown
	C.rb_syswait(cpid)
	runtime.KeepAlive(cpidAllocMap)
}

// RbSpawn function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/process.h
func RbSpawn(argc int32, argv []VALUE) int32 {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_spawn(cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbSpawnErr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/process.h
func RbSpawnErr(argc int32, argv []VALUE, errbuf []byte, buflen uint64) int32 {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cerrbuf, cerrbufAllocMap := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&errbuf)).Data)), cgoAllocsUnknown
	cbuflen, cbuflenAllocMap := (C.size_t)(buflen), cgoAllocsUnknown
	__ret := C.rb_spawn_err(cargc, cargv, cerrbuf, cbuflen)
	runtime.KeepAlive(cbuflenAllocMap)
	runtime.KeepAlive(cerrbufAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbProcTimes function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/process.h
func RbProcTimes(arg VALUE) VALUE {
	carg, cargAllocMap := (C.VALUE)(arg), cgoAllocsUnknown
	__ret := C.rb_proc_times(carg)
	runtime.KeepAlive(cargAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDetachProcess function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/process.h
func RbDetachProcess(pid int32) VALUE {
	cpid, cpidAllocMap := (C.pid_t)(pid), cgoAllocsUnknown
	__ret := C.rb_detach_process(cpid)
	runtime.KeepAlive(cpidAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbGenrandInt32 function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/random.h
func RbGenrandInt32() uint32 {
	__ret := C.rb_genrand_int32()
	__v := (uint32)(__ret)
	return __v
}

// RbGenrandReal function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/random.h
func RbGenrandReal() float64 {
	__ret := C.rb_genrand_real()
	__v := (float64)(__ret)
	return __v
}

// RbResetRandomSeed function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/random.h
func RbResetRandomSeed() {
	C.rb_reset_random_seed()
}

// RbRandomBytes function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/random.h
func RbRandomBytes(rnd VALUE, n int64) VALUE {
	crnd, crndAllocMap := (C.VALUE)(rnd), cgoAllocsUnknown
	cn, cnAllocMap := (C.long)(n), cgoAllocsUnknown
	__ret := C.rb_random_bytes(crnd, cn)
	runtime.KeepAlive(cnAllocMap)
	runtime.KeepAlive(crndAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRandomInt32 function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/random.h
func RbRandomInt32(rnd VALUE) uint32 {
	crnd, crndAllocMap := (C.VALUE)(rnd), cgoAllocsUnknown
	__ret := C.rb_random_int32(crnd)
	runtime.KeepAlive(crndAllocMap)
	__v := (uint32)(__ret)
	return __v
}

// RbRandomReal function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/random.h
func RbRandomReal(rnd VALUE) float64 {
	crnd, crndAllocMap := (C.VALUE)(rnd), cgoAllocsUnknown
	__ret := C.rb_random_real(crnd)
	runtime.KeepAlive(crndAllocMap)
	__v := (float64)(__ret)
	return __v
}

// RbRandomUlongLimited function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/random.h
func RbRandomUlongLimited(rnd VALUE, limit uint64) uint64 {
	crnd, crndAllocMap := (C.VALUE)(rnd), cgoAllocsUnknown
	climit, climitAllocMap := (C.ulong)(limit), cgoAllocsUnknown
	__ret := C.rb_random_ulong_limited(crnd, climit)
	runtime.KeepAlive(climitAllocMap)
	runtime.KeepAlive(crndAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbGenrandUlongLimited function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/random.h
func RbGenrandUlongLimited(i uint64) uint64 {
	ci, ciAllocMap := (C.ulong)(i), cgoAllocsUnknown
	__ret := C.rb_genrand_ulong_limited(ci)
	runtime.KeepAlive(ciAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbRangeNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/range.h
func RbRangeNew(beg VALUE, end VALUE, excl int32) VALUE {
	cbeg, cbegAllocMap := (C.VALUE)(beg), cgoAllocsUnknown
	cend, cendAllocMap := (C.VALUE)(end), cgoAllocsUnknown
	cexcl, cexclAllocMap := (C.int)(excl), cgoAllocsUnknown
	__ret := C.rb_range_new(cbeg, cend, cexcl)
	runtime.KeepAlive(cexclAllocMap)
	runtime.KeepAlive(cendAllocMap)
	runtime.KeepAlive(cbegAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRangeBegLen function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/range.h
func RbRangeBegLen(_range VALUE, begp []int64, lenp []int64, len int64, err int32) VALUE {
	c_range, c_rangeAllocMap := (C.VALUE)(_range), cgoAllocsUnknown
	cbegp, cbegpAllocMap := (*C.long)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&begp)).Data)), cgoAllocsUnknown
	clenp, clenpAllocMap := (*C.long)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&lenp)).Data)), cgoAllocsUnknown
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	cerr, cerrAllocMap := (C.int)(err), cgoAllocsUnknown
	__ret := C.rb_range_beg_len(c_range, cbegp, clenp, clen, cerr)
	runtime.KeepAlive(cerrAllocMap)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(clenpAllocMap)
	runtime.KeepAlive(cbegpAllocMap)
	runtime.KeepAlive(c_rangeAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRangeValues function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/range.h
func RbRangeValues(_range VALUE, begp []VALUE, endp []VALUE, exclp []int32) int32 {
	c_range, c_rangeAllocMap := (C.VALUE)(_range), cgoAllocsUnknown
	cbegp, cbegpAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&begp)).Data)), cgoAllocsUnknown
	cendp, cendpAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&endp)).Data)), cgoAllocsUnknown
	cexclp, cexclpAllocMap := (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&exclp)).Data)), cgoAllocsUnknown
	__ret := C.rb_range_values(c_range, cbegp, cendp, cexclp)
	runtime.KeepAlive(cexclpAllocMap)
	runtime.KeepAlive(cendpAllocMap)
	runtime.KeepAlive(cbegpAllocMap)
	runtime.KeepAlive(c_rangeAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbRationalRaw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/rational.h
func RbRationalRaw(num VALUE, den VALUE) VALUE {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	cden, cdenAllocMap := (C.VALUE)(den), cgoAllocsUnknown
	__ret := C.rb_rational_raw(cnum, cden)
	runtime.KeepAlive(cdenAllocMap)
	runtime.KeepAlive(cnumAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRationalNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/rational.h
func RbRationalNew(num VALUE, den VALUE) VALUE {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	cden, cdenAllocMap := (C.VALUE)(den), cgoAllocsUnknown
	__ret := C.rb_rational_new(cnum, cden)
	runtime.KeepAlive(cdenAllocMap)
	runtime.KeepAlive(cnumAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRational function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/rational.h
func RbRational(num VALUE, den VALUE) VALUE {
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	cden, cdenAllocMap := (C.VALUE)(den), cgoAllocsUnknown
	__ret := C.rb_Rational(cnum, cden)
	runtime.KeepAlive(cdenAllocMap)
	runtime.KeepAlive(cnumAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRationalNum function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/rational.h
func RbRationalNum(rat VALUE) VALUE {
	crat, cratAllocMap := (C.VALUE)(rat), cgoAllocsUnknown
	__ret := C.rb_rational_num(crat)
	runtime.KeepAlive(cratAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRationalDen function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/rational.h
func RbRationalDen(rat VALUE) VALUE {
	crat, cratAllocMap := (C.VALUE)(rat), cgoAllocsUnknown
	__ret := C.rb_rational_den(crat)
	runtime.KeepAlive(cratAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFltRationalizeWithPrec function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/rational.h
func RbFltRationalizeWithPrec(flt VALUE, prec VALUE) VALUE {
	cflt, cfltAllocMap := (C.VALUE)(flt), cgoAllocsUnknown
	cprec, cprecAllocMap := (C.VALUE)(prec), cgoAllocsUnknown
	__ret := C.rb_flt_rationalize_with_prec(cflt, cprec)
	runtime.KeepAlive(cprecAllocMap)
	runtime.KeepAlive(cfltAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFltRationalize function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/rational.h
func RbFltRationalize(flt VALUE) VALUE {
	cflt, cfltAllocMap := (C.VALUE)(flt), cgoAllocsUnknown
	__ret := C.rb_flt_rationalize(cflt)
	runtime.KeepAlive(cfltAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbMemcicmp function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/re.h
func RbMemcicmp(s1 unsafe.Pointer, s2 unsafe.Pointer, n int64) int32 {
	cs1, cs1AllocMap := s1, cgoAllocsUnknown
	cs2, cs2AllocMap := s2, cgoAllocsUnknown
	cn, cnAllocMap := (C.long)(n), cgoAllocsUnknown
	__ret := C.rb_memcicmp(cs1, cs2, cn)
	runtime.KeepAlive(cnAllocMap)
	runtime.KeepAlive(cs2AllocMap)
	runtime.KeepAlive(cs1AllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbMatchBusy function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/re.h
func RbMatchBusy(md VALUE) {
	cmd, cmdAllocMap := (C.VALUE)(md), cgoAllocsUnknown
	C.rb_match_busy(cmd)
	runtime.KeepAlive(cmdAllocMap)
}

// RbRegNthDefined function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/re.h
func RbRegNthDefined(n int32, md VALUE) VALUE {
	cn, cnAllocMap := (C.int)(n), cgoAllocsUnknown
	cmd, cmdAllocMap := (C.VALUE)(md), cgoAllocsUnknown
	__ret := C.rb_reg_nth_defined(cn, cmd)
	runtime.KeepAlive(cmdAllocMap)
	runtime.KeepAlive(cnAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRegNthMatch function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/re.h
func RbRegNthMatch(n int32, md VALUE) VALUE {
	cn, cnAllocMap := (C.int)(n), cgoAllocsUnknown
	cmd, cmdAllocMap := (C.VALUE)(md), cgoAllocsUnknown
	__ret := C.rb_reg_nth_match(cn, cmd)
	runtime.KeepAlive(cmdAllocMap)
	runtime.KeepAlive(cnAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRegBackrefNumber function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/re.h
func RbRegBackrefNumber(match VALUE, backref VALUE) int32 {
	cmatch, cmatchAllocMap := (C.VALUE)(match), cgoAllocsUnknown
	cbackref, cbackrefAllocMap := (C.VALUE)(backref), cgoAllocsUnknown
	__ret := C.rb_reg_backref_number(cmatch, cbackref)
	runtime.KeepAlive(cbackrefAllocMap)
	runtime.KeepAlive(cmatchAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbRegLastMatch function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/re.h
func RbRegLastMatch(md VALUE) VALUE {
	cmd, cmdAllocMap := (C.VALUE)(md), cgoAllocsUnknown
	__ret := C.rb_reg_last_match(cmd)
	runtime.KeepAlive(cmdAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRegMatchPre function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/re.h
func RbRegMatchPre(md VALUE) VALUE {
	cmd, cmdAllocMap := (C.VALUE)(md), cgoAllocsUnknown
	__ret := C.rb_reg_match_pre(cmd)
	runtime.KeepAlive(cmdAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRegMatchPost function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/re.h
func RbRegMatchPost(md VALUE) VALUE {
	cmd, cmdAllocMap := (C.VALUE)(md), cgoAllocsUnknown
	__ret := C.rb_reg_match_post(cmd)
	runtime.KeepAlive(cmdAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRegMatchLast function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/re.h
func RbRegMatchLast(md VALUE) VALUE {
	cmd, cmdAllocMap := (C.VALUE)(md), cgoAllocsUnknown
	__ret := C.rb_reg_match_last(cmd)
	runtime.KeepAlive(cmdAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRegNewStr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/re.h
func RbRegNewStr(src VALUE, opts int32) VALUE {
	csrc, csrcAllocMap := (C.VALUE)(src), cgoAllocsUnknown
	copts, coptsAllocMap := (C.int)(opts), cgoAllocsUnknown
	__ret := C.rb_reg_new_str(csrc, copts)
	runtime.KeepAlive(coptsAllocMap)
	runtime.KeepAlive(csrcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRegNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/re.h
func RbRegNew(src string, len int64, opts int32) VALUE {
	src = safeString(src)
	csrc, csrcAllocMap := unpackPCharString(src)
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	copts, coptsAllocMap := (C.int)(opts), cgoAllocsUnknown
	__ret := C.rb_reg_new(csrc, clen, copts)
	runtime.KeepAlive(coptsAllocMap)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(src)
	runtime.KeepAlive(csrcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRegAlloc function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/re.h
func RbRegAlloc() VALUE {
	__ret := C.rb_reg_alloc()
	__v := (VALUE)(__ret)
	return __v
}

// RbRegInitStr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/re.h
func RbRegInitStr(re VALUE, s VALUE, options int32) VALUE {
	cre, creAllocMap := (C.VALUE)(re), cgoAllocsUnknown
	cs, csAllocMap := (C.VALUE)(s), cgoAllocsUnknown
	coptions, coptionsAllocMap := (C.int)(options), cgoAllocsUnknown
	__ret := C.rb_reg_init_str(cre, cs, coptions)
	runtime.KeepAlive(coptionsAllocMap)
	runtime.KeepAlive(csAllocMap)
	runtime.KeepAlive(creAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRegMatch function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/re.h
func RbRegMatch(re VALUE, str VALUE) VALUE {
	cre, creAllocMap := (C.VALUE)(re), cgoAllocsUnknown
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_reg_match(cre, cstr)
	runtime.KeepAlive(cstrAllocMap)
	runtime.KeepAlive(creAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRegMatch2 function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/re.h
func RbRegMatch2(re VALUE) VALUE {
	cre, creAllocMap := (C.VALUE)(re), cgoAllocsUnknown
	__ret := C.rb_reg_match2(cre)
	runtime.KeepAlive(creAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRegOptions function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/re.h
func RbRegOptions(re VALUE) int32 {
	cre, creAllocMap := (C.VALUE)(re), cgoAllocsUnknown
	__ret := C.rb_reg_options(cre)
	runtime.KeepAlive(creAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbGetArgv function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/ruby.h
func RbGetArgv() VALUE {
	__ret := C.rb_get_argv()
	__v := (VALUE)(__ret)
	return __v
}

// RbLoadFile function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/ruby.h
func RbLoadFile(file string) unsafe.Pointer {
	file = safeString(file)
	cfile, cfileAllocMap := unpackPCharString(file)
	__ret := C.rb_load_file(cfile)
	runtime.KeepAlive(file)
	runtime.KeepAlive(cfileAllocMap)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// RbLoadFileStr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/ruby.h
func RbLoadFileStr(file VALUE) unsafe.Pointer {
	cfile, cfileAllocMap := (C.VALUE)(file), cgoAllocsUnknown
	__ret := C.rb_load_file_str(cfile)
	runtime.KeepAlive(cfileAllocMap)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// RbFdInit function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/select/largesize.h
func RbFdInit(f []RbFdsetT) {
	cf, cfAllocMap := unpackArgSRbFdsetT(f)
	C.rb_fd_init(cf)
	packSRbFdsetT(f, cf)
	runtime.KeepAlive(cfAllocMap)
}

// RbFdTerm function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/select/largesize.h
func RbFdTerm(f []RbFdsetT) {
	cf, cfAllocMap := unpackArgSRbFdsetT(f)
	C.rb_fd_term(cf)
	packSRbFdsetT(f, cf)
	runtime.KeepAlive(cfAllocMap)
}

// RbFdZero function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/select/largesize.h
func RbFdZero(f []RbFdsetT) {
	cf, cfAllocMap := unpackArgSRbFdsetT(f)
	C.rb_fd_zero(cf)
	packSRbFdsetT(f, cf)
	runtime.KeepAlive(cfAllocMap)
}

// RbFdSet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/select/largesize.h
func RbFdSet(fd int32, f []RbFdsetT) {
	cfd, cfdAllocMap := (C.int)(fd), cgoAllocsUnknown
	cf, cfAllocMap := unpackArgSRbFdsetT(f)
	C.rb_fd_set(cfd, cf)
	packSRbFdsetT(f, cf)
	runtime.KeepAlive(cfAllocMap)
	runtime.KeepAlive(cfdAllocMap)
}

// RbFdClr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/select/largesize.h
func RbFdClr(fd int32, f []RbFdsetT) {
	cfd, cfdAllocMap := (C.int)(fd), cgoAllocsUnknown
	cf, cfAllocMap := unpackArgSRbFdsetT(f)
	C.rb_fd_clr(cfd, cf)
	packSRbFdsetT(f, cf)
	runtime.KeepAlive(cfAllocMap)
	runtime.KeepAlive(cfdAllocMap)
}

// RbFdIsset function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/select/largesize.h
func RbFdIsset(fd int32, f []RbFdsetT) int32 {
	cfd, cfdAllocMap := (C.int)(fd), cgoAllocsUnknown
	cf, cfAllocMap := unpackArgSRbFdsetT(f)
	__ret := C.rb_fd_isset(cfd, cf)
	packSRbFdsetT(f, cf)
	runtime.KeepAlive(cfAllocMap)
	runtime.KeepAlive(cfdAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbFdCopy function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/select/largesize.h
func RbFdCopy(dst []RbFdsetT, src []FdSet, max int32) {
	cdst, cdstAllocMap := unpackArgSRbFdsetT(dst)
	csrc, csrcAllocMap := unpackArgSFdSet(src)
	cmax, cmaxAllocMap := (C.int)(max), cgoAllocsUnknown
	C.rb_fd_copy(cdst, csrc, cmax)
	runtime.KeepAlive(cmaxAllocMap)
	packSFdSet(src, csrc)
	runtime.KeepAlive(csrcAllocMap)
	packSRbFdsetT(dst, cdst)
	runtime.KeepAlive(cdstAllocMap)
}

// RbFdDup function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/select/largesize.h
func RbFdDup(dst []RbFdsetT, src []RbFdsetT) {
	cdst, cdstAllocMap := unpackArgSRbFdsetT(dst)
	csrc, csrcAllocMap := unpackArgSRbFdsetT(src)
	C.rb_fd_dup(cdst, csrc)
	packSRbFdsetT(src, csrc)
	runtime.KeepAlive(csrcAllocMap)
	packSRbFdsetT(dst, cdst)
	runtime.KeepAlive(cdstAllocMap)
}

// RbFdPtr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/select/largesize.h
func RbFdPtr(f []RbFdsetT) *FdSet {
	cf, cfAllocMap := unpackArgSRbFdsetT(f)
	__ret := C.rb_fd_ptr(cf)
	packSRbFdsetT(f, cf)
	runtime.KeepAlive(cfAllocMap)
	__v := NewFdSetRef(unsafe.Pointer(__ret))
	return __v
}

// RbFdMax function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/select/largesize.h
func RbFdMax(f []RbFdsetT) int32 {
	cf, cfAllocMap := unpackArgSRbFdsetT(f)
	__ret := C.rb_fd_max(cf)
	packSRbFdsetT(f, cf)
	runtime.KeepAlive(cfAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbFKill function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/signal.h
func RbFKill(argc int32, argv []VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_f_kill(cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFSprintf function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/sprintf.h
func RbFSprintf(argc int32, argv []VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_f_sprintf(cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbSprintf function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/sprintf.h
func RbSprintf(fmt string) VALUE {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	__ret := C.rb_sprintf(cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbVsprintf function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/sprintf.h
func RbVsprintf(fmt string, ap unsafe.Pointer) VALUE {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	cap, capAllocMap := ap, cgoAllocsUnknown
	__ret := C.rb_vsprintf(cfmt, cap)
	runtime.KeepAlive(capAllocMap)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrCatf function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/sprintf.h
func RbStrCatf(dst VALUE, fmt string) VALUE {
	cdst, cdstAllocMap := (C.VALUE)(dst), cgoAllocsUnknown
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	__ret := C.rb_str_catf(cdst, cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	runtime.KeepAlive(cdstAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrVcatf function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/sprintf.h
func RbStrVcatf(dst VALUE, fmt string, ap unsafe.Pointer) VALUE {
	cdst, cdstAllocMap := (C.VALUE)(dst), cgoAllocsUnknown
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	cap, capAllocMap := ap, cgoAllocsUnknown
	__ret := C.rb_str_vcatf(cdst, cfmt, cap)
	runtime.KeepAlive(capAllocMap)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	runtime.KeepAlive(cdstAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrFormat function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/sprintf.h
func RbStrFormat(argc int32, argv []VALUE, fmt VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cfmt, cfmtAllocMap := (C.VALUE)(fmt), cgoAllocsUnknown
	__ret := C.rb_str_format(cargc, cargv, cfmt)
	runtime.KeepAlive(cfmtAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrNew(ptr string, len int64) VALUE {
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_str_new(cptr, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrNewCstr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrNewCstr(ptr string) VALUE {
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	__ret := C.rb_str_new_cstr(cptr)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrNewShared function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrNewShared(str VALUE) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_str_new_shared(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrNewFrozen function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrNewFrozen(str VALUE) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_str_new_frozen(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrNewWithClass function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrNewWithClass(obj VALUE, ptr string, len int64) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_str_new_with_class(cobj, cptr, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbExternalStrNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbExternalStrNew(ptr string, len int64) VALUE {
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_external_str_new(cptr, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbExternalStrNewCstr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbExternalStrNewCstr(ptr string) VALUE {
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	__ret := C.rb_external_str_new_cstr(cptr)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbLocaleStrNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbLocaleStrNew(ptr string, len int64) VALUE {
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_locale_str_new(cptr, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbLocaleStrNewCstr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbLocaleStrNewCstr(ptr string) VALUE {
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	__ret := C.rb_locale_str_new_cstr(cptr)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFilesystemStrNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbFilesystemStrNew(ptr string, len int64) VALUE {
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_filesystem_str_new(cptr, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFilesystemStrNewCstr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbFilesystemStrNewCstr(ptr string) VALUE {
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	__ret := C.rb_filesystem_str_new_cstr(cptr)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrBufNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrBufNew(capa int64) VALUE {
	ccapa, ccapaAllocMap := (C.long)(capa), cgoAllocsUnknown
	__ret := C.rb_str_buf_new(ccapa)
	runtime.KeepAlive(ccapaAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrBufNewCstr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrBufNewCstr(ptr string) VALUE {
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	__ret := C.rb_str_buf_new_cstr(cptr)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrTmpNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrTmpNew(len int64) VALUE {
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_str_tmp_new(clen)
	runtime.KeepAlive(clenAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbUsasciiStrNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbUsasciiStrNew(ptr string, len int64) VALUE {
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_usascii_str_new(cptr, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbUsasciiStrNewCstr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbUsasciiStrNewCstr(ptr string) VALUE {
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	__ret := C.rb_usascii_str_new_cstr(cptr)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbUtf8StrNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbUtf8StrNew(ptr string, len int64) VALUE {
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_utf8_str_new(cptr, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbUtf8StrNewCstr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbUtf8StrNewCstr(ptr string) VALUE {
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	__ret := C.rb_utf8_str_new_cstr(cptr)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrNewStatic function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrNewStatic(ptr string, len int64) VALUE {
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_str_new_static(cptr, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbUsasciiStrNewStatic function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbUsasciiStrNewStatic(ptr string, len int64) VALUE {
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_usascii_str_new_static(cptr, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbUtf8StrNewStatic function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbUtf8StrNewStatic(ptr string, len int64) VALUE {
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_utf8_str_new_static(cptr, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrToInternedStr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrToInternedStr(str VALUE) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_str_to_interned_str(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbInternedStr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbInternedStr(ptr string, len int64) VALUE {
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_interned_str(cptr, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbInternedStrCstr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbInternedStrCstr(ptr string) VALUE {
	ptr = safeString(ptr)
	cptr, cptrAllocMap := unpackPCharString(ptr)
	__ret := C.rb_interned_str_cstr(cptr)
	runtime.KeepAlive(ptr)
	runtime.KeepAlive(cptrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrFree function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrFree(str VALUE) {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	C.rb_str_free(cstr)
	runtime.KeepAlive(cstrAllocMap)
}

// RbStrSharedReplace function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrSharedReplace(dst VALUE, src VALUE) {
	cdst, cdstAllocMap := (C.VALUE)(dst), cgoAllocsUnknown
	csrc, csrcAllocMap := (C.VALUE)(src), cgoAllocsUnknown
	C.rb_str_shared_replace(cdst, csrc)
	runtime.KeepAlive(csrcAllocMap)
	runtime.KeepAlive(cdstAllocMap)
}

// RbStrBufAppend function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrBufAppend(dst VALUE, src VALUE) VALUE {
	cdst, cdstAllocMap := (C.VALUE)(dst), cgoAllocsUnknown
	csrc, csrcAllocMap := (C.VALUE)(src), cgoAllocsUnknown
	__ret := C.rb_str_buf_append(cdst, csrc)
	runtime.KeepAlive(csrcAllocMap)
	runtime.KeepAlive(cdstAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrBufCat function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrBufCat(arg0 VALUE, arg1 []byte, arg2 int64) VALUE {
	carg0, carg0AllocMap := (C.VALUE)(arg0), cgoAllocsUnknown
	carg1, carg1AllocMap := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&arg1)).Data)), cgoAllocsUnknown
	carg2, carg2AllocMap := (C.long)(arg2), cgoAllocsUnknown
	__ret := C.rb_str_buf_cat(carg0, carg1, carg2)
	runtime.KeepAlive(carg2AllocMap)
	runtime.KeepAlive(carg1AllocMap)
	runtime.KeepAlive(carg0AllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrBufCat2 function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrBufCat2(arg0 VALUE, arg1 []byte) VALUE {
	carg0, carg0AllocMap := (C.VALUE)(arg0), cgoAllocsUnknown
	carg1, carg1AllocMap := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&arg1)).Data)), cgoAllocsUnknown
	__ret := C.rb_str_buf_cat2(carg0, carg1)
	runtime.KeepAlive(carg1AllocMap)
	runtime.KeepAlive(carg0AllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrBufCatAscii function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrBufCatAscii(dst VALUE, src string) VALUE {
	cdst, cdstAllocMap := (C.VALUE)(dst), cgoAllocsUnknown
	src = safeString(src)
	csrc, csrcAllocMap := unpackPCharString(src)
	__ret := C.rb_str_buf_cat_ascii(cdst, csrc)
	runtime.KeepAlive(src)
	runtime.KeepAlive(csrcAllocMap)
	runtime.KeepAlive(cdstAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjAsString function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbObjAsString(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_obj_as_string(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCheckStringType function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbCheckStringType(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_check_string_type(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbMustAsciicompat function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbMustAsciicompat(obj VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	C.rb_must_asciicompat(cobj)
	runtime.KeepAlive(cobjAllocMap)
}

// RbStrDup function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrDup(str VALUE) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_str_dup(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrResurrect function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrResurrect(str VALUE) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_str_resurrect(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrLocktmp function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrLocktmp(str VALUE) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_str_locktmp(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrUnlocktmp function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrUnlocktmp(str VALUE) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_str_unlocktmp(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrDupFrozen function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrDupFrozen(arg0 VALUE) VALUE {
	carg0, carg0AllocMap := (C.VALUE)(arg0), cgoAllocsUnknown
	__ret := C.rb_str_dup_frozen(carg0)
	runtime.KeepAlive(carg0AllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrPlus function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrPlus(lhs VALUE, rhs VALUE) VALUE {
	clhs, clhsAllocMap := (C.VALUE)(lhs), cgoAllocsUnknown
	crhs, crhsAllocMap := (C.VALUE)(rhs), cgoAllocsUnknown
	__ret := C.rb_str_plus(clhs, crhs)
	runtime.KeepAlive(crhsAllocMap)
	runtime.KeepAlive(clhsAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrTimes function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrTimes(str VALUE, num VALUE) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	cnum, cnumAllocMap := (C.VALUE)(num), cgoAllocsUnknown
	__ret := C.rb_str_times(cstr, cnum)
	runtime.KeepAlive(cnumAllocMap)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrSublen function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrSublen(str VALUE, pos int64) int64 {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	cpos, cposAllocMap := (C.long)(pos), cgoAllocsUnknown
	__ret := C.rb_str_sublen(cstr, cpos)
	runtime.KeepAlive(cposAllocMap)
	runtime.KeepAlive(cstrAllocMap)
	__v := (int64)(__ret)
	return __v
}

// RbStrSubstr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrSubstr(str VALUE, beg int64, len int64) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	cbeg, cbegAllocMap := (C.long)(beg), cgoAllocsUnknown
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_str_substr(cstr, cbeg, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(cbegAllocMap)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrSubseq function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrSubseq(str VALUE, beg int64, len int64) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	cbeg, cbegAllocMap := (C.long)(beg), cgoAllocsUnknown
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_str_subseq(cstr, cbeg, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(cbegAllocMap)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrSubpos function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrSubpos(str VALUE, beg int64, len []int64) *byte {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	cbeg, cbegAllocMap := (C.long)(beg), cgoAllocsUnknown
	clen, clenAllocMap := (*C.long)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&len)).Data)), cgoAllocsUnknown
	__ret := C.rb_str_subpos(cstr, cbeg, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(cbegAllocMap)
	runtime.KeepAlive(cstrAllocMap)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// RbStrModify function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrModify(str VALUE) {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	C.rb_str_modify(cstr)
	runtime.KeepAlive(cstrAllocMap)
}

// RbStrModifyExpand function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrModifyExpand(str VALUE, capa int64) {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	ccapa, ccapaAllocMap := (C.long)(capa), cgoAllocsUnknown
	C.rb_str_modify_expand(cstr, ccapa)
	runtime.KeepAlive(ccapaAllocMap)
	runtime.KeepAlive(cstrAllocMap)
}

// RbStrFreeze function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrFreeze(str VALUE) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_str_freeze(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrSetLen function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrSetLen(str VALUE, len int64) {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	C.rb_str_set_len(cstr, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(cstrAllocMap)
}

// RbStrResize function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrResize(str VALUE, len int64) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_str_resize(cstr, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrCat function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrCat(dst VALUE, src string, srclen int64) VALUE {
	cdst, cdstAllocMap := (C.VALUE)(dst), cgoAllocsUnknown
	src = safeString(src)
	csrc, csrcAllocMap := unpackPCharString(src)
	csrclen, csrclenAllocMap := (C.long)(srclen), cgoAllocsUnknown
	__ret := C.rb_str_cat(cdst, csrc, csrclen)
	runtime.KeepAlive(csrclenAllocMap)
	runtime.KeepAlive(src)
	runtime.KeepAlive(csrcAllocMap)
	runtime.KeepAlive(cdstAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrCatCstr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrCatCstr(dst VALUE, src string) VALUE {
	cdst, cdstAllocMap := (C.VALUE)(dst), cgoAllocsUnknown
	src = safeString(src)
	csrc, csrcAllocMap := unpackPCharString(src)
	__ret := C.rb_str_cat_cstr(cdst, csrc)
	runtime.KeepAlive(src)
	runtime.KeepAlive(csrcAllocMap)
	runtime.KeepAlive(cdstAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrCat2 function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrCat2(arg0 VALUE, arg1 []byte) VALUE {
	carg0, carg0AllocMap := (C.VALUE)(arg0), cgoAllocsUnknown
	carg1, carg1AllocMap := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&arg1)).Data)), cgoAllocsUnknown
	__ret := C.rb_str_cat2(carg0, carg1)
	runtime.KeepAlive(carg1AllocMap)
	runtime.KeepAlive(carg0AllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrAppend function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrAppend(dst VALUE, src VALUE) VALUE {
	cdst, cdstAllocMap := (C.VALUE)(dst), cgoAllocsUnknown
	csrc, csrcAllocMap := (C.VALUE)(src), cgoAllocsUnknown
	__ret := C.rb_str_append(cdst, csrc)
	runtime.KeepAlive(csrcAllocMap)
	runtime.KeepAlive(cdstAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrConcat function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrConcat(dst VALUE, src VALUE) VALUE {
	cdst, cdstAllocMap := (C.VALUE)(dst), cgoAllocsUnknown
	csrc, csrcAllocMap := (C.VALUE)(src), cgoAllocsUnknown
	__ret := C.rb_str_concat(cdst, csrc)
	runtime.KeepAlive(csrcAllocMap)
	runtime.KeepAlive(cdstAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbMemhash function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbMemhash(ptr unsafe.Pointer, len int64) uint64 {
	cptr, cptrAllocMap := ptr, cgoAllocsUnknown
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_memhash(cptr, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(cptrAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbHashStart function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/intern/string.h
func RbHashStart(i uint64) uint64 {
	ci, ciAllocMap := (C.st_index_t)(i), cgoAllocsUnknown
	__ret := C.rb_hash_start(ci)
	runtime.KeepAlive(ciAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbStrHash function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrHash(str VALUE) uint64 {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_str_hash(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbStrHashCmp function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrHashCmp(str1 VALUE, str2 VALUE) int32 {
	cstr1, cstr1AllocMap := (C.VALUE)(str1), cgoAllocsUnknown
	cstr2, cstr2AllocMap := (C.VALUE)(str2), cgoAllocsUnknown
	__ret := C.rb_str_hash_cmp(cstr1, cstr2)
	runtime.KeepAlive(cstr2AllocMap)
	runtime.KeepAlive(cstr1AllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbStrComparable function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrComparable(str1 VALUE, str2 VALUE) int32 {
	cstr1, cstr1AllocMap := (C.VALUE)(str1), cgoAllocsUnknown
	cstr2, cstr2AllocMap := (C.VALUE)(str2), cgoAllocsUnknown
	__ret := C.rb_str_comparable(cstr1, cstr2)
	runtime.KeepAlive(cstr2AllocMap)
	runtime.KeepAlive(cstr1AllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbStrCmp function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrCmp(lhs VALUE, rhs VALUE) int32 {
	clhs, clhsAllocMap := (C.VALUE)(lhs), cgoAllocsUnknown
	crhs, crhsAllocMap := (C.VALUE)(rhs), cgoAllocsUnknown
	__ret := C.rb_str_cmp(clhs, crhs)
	runtime.KeepAlive(crhsAllocMap)
	runtime.KeepAlive(clhsAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbStrEqual function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrEqual(str1 VALUE, str2 VALUE) VALUE {
	cstr1, cstr1AllocMap := (C.VALUE)(str1), cgoAllocsUnknown
	cstr2, cstr2AllocMap := (C.VALUE)(str2), cgoAllocsUnknown
	__ret := C.rb_str_equal(cstr1, cstr2)
	runtime.KeepAlive(cstr2AllocMap)
	runtime.KeepAlive(cstr1AllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrDropBytes function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrDropBytes(str VALUE, len int64) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_str_drop_bytes(cstr, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrUpdate function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrUpdate(dst VALUE, beg int64, len int64, src VALUE) {
	cdst, cdstAllocMap := (C.VALUE)(dst), cgoAllocsUnknown
	cbeg, cbegAllocMap := (C.long)(beg), cgoAllocsUnknown
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	csrc, csrcAllocMap := (C.VALUE)(src), cgoAllocsUnknown
	C.rb_str_update(cdst, cbeg, clen, csrc)
	runtime.KeepAlive(csrcAllocMap)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(cbegAllocMap)
	runtime.KeepAlive(cdstAllocMap)
}

// RbStrReplace function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrReplace(dst VALUE, src VALUE) VALUE {
	cdst, cdstAllocMap := (C.VALUE)(dst), cgoAllocsUnknown
	csrc, csrcAllocMap := (C.VALUE)(src), cgoAllocsUnknown
	__ret := C.rb_str_replace(cdst, csrc)
	runtime.KeepAlive(csrcAllocMap)
	runtime.KeepAlive(cdstAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrInspect function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrInspect(str VALUE) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_str_inspect(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrDump function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrDump(str VALUE) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_str_dump(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrSplit function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrSplit(str VALUE, delim string) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	delim = safeString(delim)
	cdelim, cdelimAllocMap := unpackPCharString(delim)
	__ret := C.rb_str_split(cstr, cdelim)
	runtime.KeepAlive(delim)
	runtime.KeepAlive(cdelimAllocMap)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrSetter function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrSetter(val VALUE, id ID, data []VALUE) {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	cdata, cdataAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	C.rb_str_setter(cval, cid, cdata)
	runtime.KeepAlive(cdataAllocMap)
	runtime.KeepAlive(cidAllocMap)
	runtime.KeepAlive(cvalAllocMap)
}

// RbStrIntern function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrIntern(str VALUE) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_str_intern(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbSymToS function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbSymToS(sym VALUE) VALUE {
	csym, csymAllocMap := (C.VALUE)(sym), cgoAllocsUnknown
	__ret := C.rb_sym_to_s(csym)
	runtime.KeepAlive(csymAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrStrlen function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrStrlen(str VALUE) int64 {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_str_strlen(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := (int64)(__ret)
	return __v
}

// RbStrLength function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrLength(arg0 VALUE) VALUE {
	carg0, carg0AllocMap := (C.VALUE)(arg0), cgoAllocsUnknown
	__ret := C.rb_str_length(carg0)
	runtime.KeepAlive(carg0AllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrOffset function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrOffset(str VALUE, pos int64) int64 {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	cpos, cposAllocMap := (C.long)(pos), cgoAllocsUnknown
	__ret := C.rb_str_offset(cstr, cpos)
	runtime.KeepAlive(cposAllocMap)
	runtime.KeepAlive(cstrAllocMap)
	__v := (int64)(__ret)
	return __v
}

// RbStrCapacity function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrCapacity(str VALUE) uint64 {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_str_capacity(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbStrEllipsize function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrEllipsize(str VALUE, len int64) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_str_ellipsize(cstr, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrScrub function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrScrub(str VALUE, repl VALUE) VALUE {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	crepl, creplAllocMap := (C.VALUE)(repl), cgoAllocsUnknown
	__ret := C.rb_str_scrub(cstr, crepl)
	runtime.KeepAlive(creplAllocMap)
	runtime.KeepAlive(cstrAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStrSucc function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/string.h
func RbStrSucc(orig VALUE) VALUE {
	corig, corigAllocMap := (C.VALUE)(orig), cgoAllocsUnknown
	__ret := C.rb_str_succ(corig)
	runtime.KeepAlive(corigAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStructNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/struct.h
func RbStructNew(klass VALUE) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	__ret := C.rb_struct_new(cklass)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStructDefine function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/struct.h
func RbStructDefine(name string) VALUE {
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	__ret := C.rb_struct_define(cname)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStructDefineUnder function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/struct.h
func RbStructDefineUnder(space VALUE, name string) VALUE {
	cspace, cspaceAllocMap := (C.VALUE)(space), cgoAllocsUnknown
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	__ret := C.rb_struct_define_under(cspace, cname)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cspaceAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStructAlloc function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/struct.h
func RbStructAlloc(klass VALUE, values VALUE) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cvalues, cvaluesAllocMap := (C.VALUE)(values), cgoAllocsUnknown
	__ret := C.rb_struct_alloc(cklass, cvalues)
	runtime.KeepAlive(cvaluesAllocMap)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStructInitialize function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/struct.h
func RbStructInitialize(self VALUE, values VALUE) VALUE {
	cself, cselfAllocMap := (C.VALUE)(self), cgoAllocsUnknown
	cvalues, cvaluesAllocMap := (C.VALUE)(values), cgoAllocsUnknown
	__ret := C.rb_struct_initialize(cself, cvalues)
	runtime.KeepAlive(cvaluesAllocMap)
	runtime.KeepAlive(cselfAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStructGetmember function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/struct.h
func RbStructGetmember(self VALUE, key ID) VALUE {
	cself, cselfAllocMap := (C.VALUE)(self), cgoAllocsUnknown
	ckey, ckeyAllocMap := (C.ID)(key), cgoAllocsUnknown
	__ret := C.rb_struct_getmember(cself, ckey)
	runtime.KeepAlive(ckeyAllocMap)
	runtime.KeepAlive(cselfAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStructSMembers function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/struct.h
func RbStructSMembers(klass VALUE) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	__ret := C.rb_struct_s_members(cklass)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStructMembers function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/struct.h
func RbStructMembers(self VALUE) VALUE {
	cself, cselfAllocMap := (C.VALUE)(self), cgoAllocsUnknown
	__ret := C.rb_struct_members(cself)
	runtime.KeepAlive(cselfAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStructAllocNoinit function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/struct.h
func RbStructAllocNoinit(klass VALUE) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	__ret := C.rb_struct_alloc_noinit(cklass)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStructDefineWithoutAccessor function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/struct.h
func RbStructDefineWithoutAccessor(name string, super VALUE, _func RbAllocFuncT) VALUE {
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	csuper, csuperAllocMap := (C.VALUE)(super), cgoAllocsUnknown
	c_func, c_funcAllocMap := _func.PassValue()
	__ret := C.rb_struct_define_without_accessor(cname, csuper, c_func)
	runtime.KeepAlive(c_funcAllocMap)
	runtime.KeepAlive(csuperAllocMap)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbStructDefineWithoutAccessorUnder function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/struct.h
func RbStructDefineWithoutAccessorUnder(outer VALUE, className string, super VALUE, alloc RbAllocFuncT) VALUE {
	couter, couterAllocMap := (C.VALUE)(outer), cgoAllocsUnknown
	className = safeString(className)
	cclassName, cclassNameAllocMap := unpackPCharString(className)
	csuper, csuperAllocMap := (C.VALUE)(super), cgoAllocsUnknown
	calloc, callocAllocMap := alloc.PassValue()
	__ret := C.rb_struct_define_without_accessor_under(couter, cclassName, csuper, calloc)
	runtime.KeepAlive(callocAllocMap)
	runtime.KeepAlive(csuperAllocMap)
	runtime.KeepAlive(className)
	runtime.KeepAlive(cclassNameAllocMap)
	runtime.KeepAlive(couterAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDataDefine function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/struct.h
func RbDataDefine(super VALUE) VALUE {
	csuper, csuperAllocMap := (C.VALUE)(super), cgoAllocsUnknown
	__ret := C.rb_data_define(csuper)
	runtime.KeepAlive(csuperAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbThreadSchedule function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadSchedule() {
	C.rb_thread_schedule()
}

// RbThreadWaitFd function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadWaitFd(fd int32) int32 {
	cfd, cfdAllocMap := (C.int)(fd), cgoAllocsUnknown
	__ret := C.rb_thread_wait_fd(cfd)
	runtime.KeepAlive(cfdAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbThreadFdWritable function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadFdWritable(fd int32) int32 {
	cfd, cfdAllocMap := (C.int)(fd), cgoAllocsUnknown
	__ret := C.rb_thread_fd_writable(cfd)
	runtime.KeepAlive(cfdAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbThreadFdClose function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadFdClose(fd int32) {
	cfd, cfdAllocMap := (C.int)(fd), cgoAllocsUnknown
	C.rb_thread_fd_close(cfd)
	runtime.KeepAlive(cfdAllocMap)
}

// RbThreadAlone function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadAlone() int32 {
	__ret := C.rb_thread_alone()
	__v := (int32)(__ret)
	return __v
}

// RbThreadSleep function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadSleep(sec int32) {
	csec, csecAllocMap := (C.int)(sec), cgoAllocsUnknown
	C.rb_thread_sleep(csec)
	runtime.KeepAlive(csecAllocMap)
}

// RbThreadSleepForever function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadSleepForever() {
	C.rb_thread_sleep_forever()
}

// RbThreadSleepDeadly function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadSleepDeadly() {
	C.rb_thread_sleep_deadly()
}

// RbThreadStop function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadStop() VALUE {
	__ret := C.rb_thread_stop()
	__v := (VALUE)(__ret)
	return __v
}

// RbThreadWakeup function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadWakeup(thread VALUE) VALUE {
	cthread, cthreadAllocMap := (C.VALUE)(thread), cgoAllocsUnknown
	__ret := C.rb_thread_wakeup(cthread)
	runtime.KeepAlive(cthreadAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbThreadWakeupAlive function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadWakeupAlive(thread VALUE) VALUE {
	cthread, cthreadAllocMap := (C.VALUE)(thread), cgoAllocsUnknown
	__ret := C.rb_thread_wakeup_alive(cthread)
	runtime.KeepAlive(cthreadAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbThreadRun function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadRun(thread VALUE) VALUE {
	cthread, cthreadAllocMap := (C.VALUE)(thread), cgoAllocsUnknown
	__ret := C.rb_thread_run(cthread)
	runtime.KeepAlive(cthreadAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbThreadKill function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadKill(thread VALUE) VALUE {
	cthread, cthreadAllocMap := (C.VALUE)(thread), cgoAllocsUnknown
	__ret := C.rb_thread_kill(cthread)
	runtime.KeepAlive(cthreadAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbThreadCreate function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadCreate(f VALUE, g unsafe.Pointer) VALUE {
	cf, cfAllocMap := f.PassRef()
	cg, cgAllocMap := g, cgoAllocsUnknown
	__ret := C.rb_thread_create(cf, cg)
	runtime.KeepAlive(cgAllocMap)
	runtime.KeepAlive(cfAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbThreadCurrent function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadCurrent() VALUE {
	__ret := C.rb_thread_current()
	__v := (VALUE)(__ret)
	return __v
}

// RbThreadMain function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadMain() VALUE {
	__ret := C.rb_thread_main()
	__v := (VALUE)(__ret)
	return __v
}

// RbThreadLocalAref function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadLocalAref(thread VALUE, key ID) VALUE {
	cthread, cthreadAllocMap := (C.VALUE)(thread), cgoAllocsUnknown
	ckey, ckeyAllocMap := (C.ID)(key), cgoAllocsUnknown
	__ret := C.rb_thread_local_aref(cthread, ckey)
	runtime.KeepAlive(ckeyAllocMap)
	runtime.KeepAlive(cthreadAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbThreadLocalAset function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadLocalAset(thread VALUE, key ID, val VALUE) VALUE {
	cthread, cthreadAllocMap := (C.VALUE)(thread), cgoAllocsUnknown
	ckey, ckeyAllocMap := (C.ID)(key), cgoAllocsUnknown
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	__ret := C.rb_thread_local_aset(cthread, ckey, cval)
	runtime.KeepAlive(cvalAllocMap)
	runtime.KeepAlive(ckeyAllocMap)
	runtime.KeepAlive(cthreadAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbThreadAtfork function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadAtfork() {
	C.rb_thread_atfork()
}

// RbThreadAtforkBeforeExec function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadAtforkBeforeExec() {
	C.rb_thread_atfork_before_exec()
}

// RbExecRecursive function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbExecRecursive(f VALUE, g VALUE, h VALUE) VALUE {
	cf, cfAllocMap := f.PassRef()
	cg, cgAllocMap := (C.VALUE)(g), cgoAllocsUnknown
	ch, chAllocMap := (C.VALUE)(h), cgoAllocsUnknown
	__ret := C.rb_exec_recursive(cf, cg, ch)
	runtime.KeepAlive(chAllocMap)
	runtime.KeepAlive(cgAllocMap)
	runtime.KeepAlive(cfAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbExecRecursivePaired function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbExecRecursivePaired(f VALUE, g VALUE, p VALUE, h VALUE) VALUE {
	cf, cfAllocMap := f.PassRef()
	cg, cgAllocMap := (C.VALUE)(g), cgoAllocsUnknown
	cp, cpAllocMap := (C.VALUE)(p), cgoAllocsUnknown
	ch, chAllocMap := (C.VALUE)(h), cgoAllocsUnknown
	__ret := C.rb_exec_recursive_paired(cf, cg, cp, ch)
	runtime.KeepAlive(chAllocMap)
	runtime.KeepAlive(cpAllocMap)
	runtime.KeepAlive(cgAllocMap)
	runtime.KeepAlive(cfAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbExecRecursiveOuter function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbExecRecursiveOuter(f VALUE, g VALUE, h VALUE) VALUE {
	cf, cfAllocMap := f.PassRef()
	cg, cgAllocMap := (C.VALUE)(g), cgoAllocsUnknown
	ch, chAllocMap := (C.VALUE)(h), cgoAllocsUnknown
	__ret := C.rb_exec_recursive_outer(cf, cg, ch)
	runtime.KeepAlive(chAllocMap)
	runtime.KeepAlive(cgAllocMap)
	runtime.KeepAlive(cfAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbExecRecursivePairedOuter function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbExecRecursivePairedOuter(f VALUE, g VALUE, p VALUE, h VALUE) VALUE {
	cf, cfAllocMap := f.PassRef()
	cg, cgAllocMap := (C.VALUE)(g), cgoAllocsUnknown
	cp, cpAllocMap := (C.VALUE)(p), cgoAllocsUnknown
	ch, chAllocMap := (C.VALUE)(h), cgoAllocsUnknown
	__ret := C.rb_exec_recursive_paired_outer(cf, cg, cp, ch)
	runtime.KeepAlive(chAllocMap)
	runtime.KeepAlive(cpAllocMap)
	runtime.KeepAlive(cgAllocMap)
	runtime.KeepAlive(cfAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbThreadCheckInts function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadCheckInts() {
	C.rb_thread_check_ints()
}

// RbThreadInterrupted function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbThreadInterrupted(thval VALUE) int32 {
	cthval, cthvalAllocMap := (C.VALUE)(thval), cgoAllocsUnknown
	__ret := C.rb_thread_interrupted(cthval)
	runtime.KeepAlive(cthvalAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbMutexNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbMutexNew() VALUE {
	__ret := C.rb_mutex_new()
	__v := (VALUE)(__ret)
	return __v
}

// RbMutexLockedP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbMutexLockedP(mutex VALUE) VALUE {
	cmutex, cmutexAllocMap := (C.VALUE)(mutex), cgoAllocsUnknown
	__ret := C.rb_mutex_locked_p(cmutex)
	runtime.KeepAlive(cmutexAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbMutexTrylock function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbMutexTrylock(mutex VALUE) VALUE {
	cmutex, cmutexAllocMap := (C.VALUE)(mutex), cgoAllocsUnknown
	__ret := C.rb_mutex_trylock(cmutex)
	runtime.KeepAlive(cmutexAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbMutexLock function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbMutexLock(mutex VALUE) VALUE {
	cmutex, cmutexAllocMap := (C.VALUE)(mutex), cgoAllocsUnknown
	__ret := C.rb_mutex_lock(cmutex)
	runtime.KeepAlive(cmutexAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbMutexUnlock function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbMutexUnlock(mutex VALUE) VALUE {
	cmutex, cmutexAllocMap := (C.VALUE)(mutex), cgoAllocsUnknown
	__ret := C.rb_mutex_unlock(cmutex)
	runtime.KeepAlive(cmutexAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbMutexSleep function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbMutexSleep(self VALUE, timeout VALUE) VALUE {
	cself, cselfAllocMap := (C.VALUE)(self), cgoAllocsUnknown
	ctimeout, ctimeoutAllocMap := (C.VALUE)(timeout), cgoAllocsUnknown
	__ret := C.rb_mutex_sleep(cself, ctimeout)
	runtime.KeepAlive(ctimeoutAllocMap)
	runtime.KeepAlive(cselfAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbMutexSynchronize function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/thread.h
func RbMutexSynchronize(mutex VALUE, _func VALUE, arg VALUE) VALUE {
	cmutex, cmutexAllocMap := (C.VALUE)(mutex), cgoAllocsUnknown
	c_func, c_funcAllocMap := _func.PassRef()
	carg, cargAllocMap := (C.VALUE)(arg), cgoAllocsUnknown
	__ret := C.rb_mutex_synchronize(cmutex, c_func, carg)
	runtime.KeepAlive(cargAllocMap)
	runtime.KeepAlive(c_funcAllocMap)
	runtime.KeepAlive(cmutexAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbTimeNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/time.h
func RbTimeNew(sec int64, usec int64) VALUE {
	csec, csecAllocMap := (C.time_t)(sec), cgoAllocsUnknown
	cusec, cusecAllocMap := (C.long)(usec), cgoAllocsUnknown
	__ret := C.rb_time_new(csec, cusec)
	runtime.KeepAlive(cusecAllocMap)
	runtime.KeepAlive(csecAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbTimeNanoNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/time.h
func RbTimeNanoNew(sec int64, nsec int64) VALUE {
	csec, csecAllocMap := (C.time_t)(sec), cgoAllocsUnknown
	cnsec, cnsecAllocMap := (C.long)(nsec), cgoAllocsUnknown
	__ret := C.rb_time_nano_new(csec, cnsec)
	runtime.KeepAlive(cnsecAllocMap)
	runtime.KeepAlive(csecAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbTimeNumNew function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/time.h
func RbTimeNumNew(timev VALUE, off VALUE) VALUE {
	ctimev, ctimevAllocMap := (C.VALUE)(timev), cgoAllocsUnknown
	coff, coffAllocMap := (C.VALUE)(off), cgoAllocsUnknown
	__ret := C.rb_time_num_new(ctimev, coff)
	runtime.KeepAlive(coffAllocMap)
	runtime.KeepAlive(ctimevAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbTimeUtcOffset function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/time.h
func RbTimeUtcOffset(time VALUE) VALUE {
	ctime, ctimeAllocMap := (C.VALUE)(time), cgoAllocsUnknown
	__ret := C.rb_time_utc_offset(ctime)
	runtime.KeepAlive(ctimeAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbModName function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbModName(mod VALUE) VALUE {
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	__ret := C.rb_mod_name(cmod)
	runtime.KeepAlive(cmodAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbClassPath function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbClassPath(mod VALUE) VALUE {
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	__ret := C.rb_class_path(cmod)
	runtime.KeepAlive(cmodAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbClassPathCached function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbClassPathCached(mod VALUE) VALUE {
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	__ret := C.rb_class_path_cached(cmod)
	runtime.KeepAlive(cmodAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbSetClassPath function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbSetClassPath(klass VALUE, space VALUE, name string) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cspace, cspaceAllocMap := (C.VALUE)(space), cgoAllocsUnknown
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	C.rb_set_class_path(cklass, cspace, cname)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cspaceAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbSetClassPathString function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbSetClassPathString(klass VALUE, space VALUE, name VALUE) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cspace, cspaceAllocMap := (C.VALUE)(space), cgoAllocsUnknown
	cname, cnameAllocMap := (C.VALUE)(name), cgoAllocsUnknown
	C.rb_set_class_path_string(cklass, cspace, cname)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cspaceAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbPathToClass function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbPathToClass(path VALUE) VALUE {
	cpath, cpathAllocMap := (C.VALUE)(path), cgoAllocsUnknown
	__ret := C.rb_path_to_class(cpath)
	runtime.KeepAlive(cpathAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbPath2class function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbPath2class(path string) VALUE {
	path = safeString(path)
	cpath, cpathAllocMap := unpackPCharString(path)
	__ret := C.rb_path2class(cpath)
	runtime.KeepAlive(path)
	runtime.KeepAlive(cpathAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbClassName function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbClassName(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_class_name(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAutoloadLoad function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbAutoloadLoad(space VALUE, name ID) VALUE {
	cspace, cspaceAllocMap := (C.VALUE)(space), cgoAllocsUnknown
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	__ret := C.rb_autoload_load(cspace, cname)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cspaceAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbAutoloadP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbAutoloadP(space VALUE, name ID) VALUE {
	cspace, cspaceAllocMap := (C.VALUE)(space), cgoAllocsUnknown
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	__ret := C.rb_autoload_p(cspace, cname)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cspaceAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFTraceVar function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbFTraceVar(argc int32, argv []VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_f_trace_var(cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFUntraceVar function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbFUntraceVar(argc int32, argv []VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_f_untrace_var(cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbFGlobalVariables function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbFGlobalVariables() VALUE {
	__ret := C.rb_f_global_variables()
	__v := (VALUE)(__ret)
	return __v
}

// RbAliasVariable function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbAliasVariable(dst ID, src ID) {
	cdst, cdstAllocMap := (C.ID)(dst), cgoAllocsUnknown
	csrc, csrcAllocMap := (C.ID)(src), cgoAllocsUnknown
	C.rb_alias_variable(cdst, csrc)
	runtime.KeepAlive(csrcAllocMap)
	runtime.KeepAlive(cdstAllocMap)
}

// RbFreeGenericIvar function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbFreeGenericIvar(obj VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	C.rb_free_generic_ivar(cobj)
	runtime.KeepAlive(cobjAllocMap)
}

// RbIvarGet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbIvarGet(obj VALUE, name ID) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	__ret := C.rb_ivar_get(cobj, cname)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIvarSet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbIvarSet(obj VALUE, name ID, val VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	__ret := C.rb_ivar_set(cobj, cname, cval)
	runtime.KeepAlive(cvalAllocMap)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIvarDefined function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbIvarDefined(obj VALUE, name ID) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	__ret := C.rb_ivar_defined(cobj, cname)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIvarCount function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbIvarCount(obj VALUE) uint64 {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_ivar_count(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbAttrGet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbAttrGet(obj VALUE, name ID) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	__ret := C.rb_attr_get(cobj, cname)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjInstanceVariables function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbObjInstanceVariables(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_obj_instance_variables(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjRemoveInstanceVariable function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbObjRemoveInstanceVariable(obj VALUE, name VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cname, cnameAllocMap := (C.VALUE)(name), cgoAllocsUnknown
	__ret := C.rb_obj_remove_instance_variable(cobj, cname)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbModConstAt function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbModConstAt(arg0 VALUE, arg1 unsafe.Pointer) unsafe.Pointer {
	carg0, carg0AllocMap := (C.VALUE)(arg0), cgoAllocsUnknown
	carg1, carg1AllocMap := arg1, cgoAllocsUnknown
	__ret := C.rb_mod_const_at(carg0, carg1)
	runtime.KeepAlive(carg1AllocMap)
	runtime.KeepAlive(carg0AllocMap)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// RbModConstOf function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbModConstOf(arg0 VALUE, arg1 unsafe.Pointer) unsafe.Pointer {
	carg0, carg0AllocMap := (C.VALUE)(arg0), cgoAllocsUnknown
	carg1, carg1AllocMap := arg1, cgoAllocsUnknown
	__ret := C.rb_mod_const_of(carg0, carg1)
	runtime.KeepAlive(carg1AllocMap)
	runtime.KeepAlive(carg0AllocMap)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// RbConstList function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbConstList(arg0 unsafe.Pointer) VALUE {
	carg0, carg0AllocMap := arg0, cgoAllocsUnknown
	__ret := C.rb_const_list(carg0)
	runtime.KeepAlive(carg0AllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbModConstants function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbModConstants(argc int32, argv []VALUE, recv VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	__ret := C.rb_mod_constants(cargc, cargv, crecv)
	runtime.KeepAlive(crecvAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbModRemoveConst function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbModRemoveConst(space VALUE, name VALUE) VALUE {
	cspace, cspaceAllocMap := (C.VALUE)(space), cgoAllocsUnknown
	cname, cnameAllocMap := (C.VALUE)(name), cgoAllocsUnknown
	__ret := C.rb_mod_remove_const(cspace, cname)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cspaceAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbConstDefined function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbConstDefined(space VALUE, name ID) int32 {
	cspace, cspaceAllocMap := (C.VALUE)(space), cgoAllocsUnknown
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	__ret := C.rb_const_defined(cspace, cname)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cspaceAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbConstDefinedAt function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbConstDefinedAt(space VALUE, name ID) int32 {
	cspace, cspaceAllocMap := (C.VALUE)(space), cgoAllocsUnknown
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	__ret := C.rb_const_defined_at(cspace, cname)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cspaceAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbConstDefinedFrom function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbConstDefinedFrom(space VALUE, name ID) int32 {
	cspace, cspaceAllocMap := (C.VALUE)(space), cgoAllocsUnknown
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	__ret := C.rb_const_defined_from(cspace, cname)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cspaceAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbConstGet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbConstGet(space VALUE, name ID) VALUE {
	cspace, cspaceAllocMap := (C.VALUE)(space), cgoAllocsUnknown
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	__ret := C.rb_const_get(cspace, cname)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cspaceAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbConstGetAt function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbConstGetAt(space VALUE, name ID) VALUE {
	cspace, cspaceAllocMap := (C.VALUE)(space), cgoAllocsUnknown
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	__ret := C.rb_const_get_at(cspace, cname)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cspaceAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbConstGetFrom function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbConstGetFrom(space VALUE, name ID) VALUE {
	cspace, cspaceAllocMap := (C.VALUE)(space), cgoAllocsUnknown
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	__ret := C.rb_const_get_from(cspace, cname)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cspaceAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbConstSet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbConstSet(space VALUE, name ID, val VALUE) {
	cspace, cspaceAllocMap := (C.VALUE)(space), cgoAllocsUnknown
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	C.rb_const_set(cspace, cname, cval)
	runtime.KeepAlive(cvalAllocMap)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cspaceAllocMap)
}

// RbConstRemove function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbConstRemove(space VALUE, name ID) VALUE {
	cspace, cspaceAllocMap := (C.VALUE)(space), cgoAllocsUnknown
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	__ret := C.rb_const_remove(cspace, cname)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cspaceAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCvarDefined function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbCvarDefined(klass VALUE, name ID) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	__ret := C.rb_cvar_defined(cklass, cname)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCvarSet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbCvarSet(klass VALUE, name ID, val VALUE) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	C.rb_cvar_set(cklass, cname, cval)
	runtime.KeepAlive(cvalAllocMap)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbCvarGet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbCvarGet(klass VALUE, name ID) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	__ret := C.rb_cvar_get(cklass, cname)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCvarFind function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbCvarFind(klass VALUE, name ID, front []VALUE) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	cfront, cfrontAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&front)).Data)), cgoAllocsUnknown
	__ret := C.rb_cvar_find(cklass, cname, cfront)
	runtime.KeepAlive(cfrontAllocMap)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCvSet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbCvSet(klass VALUE, name string, val VALUE) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	C.rb_cv_set(cklass, cname, cval)
	runtime.KeepAlive(cvalAllocMap)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbCvGet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbCvGet(klass VALUE, name string) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	__ret := C.rb_cv_get(cklass, cname)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDefineClassVariable function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbDefineClassVariable(arg0 VALUE, arg1 []byte, arg2 VALUE) {
	carg0, carg0AllocMap := (C.VALUE)(arg0), cgoAllocsUnknown
	carg1, carg1AllocMap := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&arg1)).Data)), cgoAllocsUnknown
	carg2, carg2AllocMap := (C.VALUE)(arg2), cgoAllocsUnknown
	C.rb_define_class_variable(carg0, carg1, carg2)
	runtime.KeepAlive(carg2AllocMap)
	runtime.KeepAlive(carg1AllocMap)
	runtime.KeepAlive(carg0AllocMap)
}

// RbModClassVariables function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbModClassVariables(argc int32, argv []VALUE, recv VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	__ret := C.rb_mod_class_variables(cargc, cargv, crecv)
	runtime.KeepAlive(crecvAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbModRemoveCvar function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/variable.h
func RbModRemoveCvar(mod VALUE, name VALUE) VALUE {
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	cname, cnameAllocMap := (C.VALUE)(name), cgoAllocsUnknown
	__ret := C.rb_mod_remove_cvar(cmod, cname)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cmodAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbSourceline function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbSourceline() int32 {
	__ret := C.rb_sourceline()
	__v := (int32)(__ret)
	return __v
}

// RbSourcefile function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbSourcefile() *byte {
	__ret := C.rb_sourcefile()
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// RbFrameMethodIdAndClass function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbFrameMethodIdAndClass(idp []ID, klassp []VALUE) int32 {
	cidp, cidpAllocMap := (*C.ID)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&idp)).Data)), cgoAllocsUnknown
	cklassp, cklasspAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&klassp)).Data)), cgoAllocsUnknown
	__ret := C.rb_frame_method_id_and_class(cidp, cklassp)
	runtime.KeepAlive(cklasspAllocMap)
	runtime.KeepAlive(cidpAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbCheckFuncall function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbCheckFuncall(recv VALUE, mid ID, argc int32, argv []VALUE) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_check_funcall(crecv, cmid, cargc, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCheckFuncallKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbCheckFuncallKw(recv VALUE, mid ID, argc int32, argv []VALUE, kwSplat int32) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	__ret := C.rb_check_funcall_kw(crecv, cmid, cargc, cargv, ckwSplat)
	runtime.KeepAlive(ckwSplatAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbEvalCmdKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbEvalCmdKw(cmd VALUE, arg VALUE, kwSplat int32) VALUE {
	ccmd, ccmdAllocMap := (C.VALUE)(cmd), cgoAllocsUnknown
	carg, cargAllocMap := (C.VALUE)(arg), cgoAllocsUnknown
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	__ret := C.rb_eval_cmd_kw(ccmd, carg, ckwSplat)
	runtime.KeepAlive(ckwSplatAllocMap)
	runtime.KeepAlive(cargAllocMap)
	runtime.KeepAlive(ccmdAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbApply function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbApply(recv VALUE, mid ID, args VALUE) VALUE {
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	cargs, cargsAllocMap := (C.VALUE)(args), cgoAllocsUnknown
	__ret := C.rb_apply(crecv, cmid, cargs)
	runtime.KeepAlive(cargsAllocMap)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(crecvAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjInstanceEval function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbObjInstanceEval(argc int32, argv []VALUE, recv VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	__ret := C.rb_obj_instance_eval(cargc, cargv, crecv)
	runtime.KeepAlive(crecvAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjInstanceExec function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbObjInstanceExec(argc int32, argv []VALUE, recv VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	crecv, crecvAllocMap := (C.VALUE)(recv), cgoAllocsUnknown
	__ret := C.rb_obj_instance_exec(cargc, cargv, crecv)
	runtime.KeepAlive(crecvAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbModModuleEval function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbModModuleEval(argc int32, argv []VALUE, mod VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	__ret := C.rb_mod_module_eval(cargc, cargv, cmod)
	runtime.KeepAlive(cmodAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbModModuleExec function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbModModuleExec(argc int32, argv []VALUE, mod VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	__ret := C.rb_mod_module_exec(cargc, cargv, cmod)
	runtime.KeepAlive(cmodAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDefineAllocFunc function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbDefineAllocFunc(klass VALUE, _func RbAllocFuncT) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	c_func, c_funcAllocMap := _func.PassValue()
	C.rb_define_alloc_func(cklass, c_func)
	runtime.KeepAlive(c_funcAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbUndefAllocFunc function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbUndefAllocFunc(klass VALUE) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	C.rb_undef_alloc_func(cklass)
	runtime.KeepAlive(cklassAllocMap)
}

// RbGetAllocFunc function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbGetAllocFunc(klass VALUE) RbAllocFuncT {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	__ret := C.rb_get_alloc_func(cklass)
	runtime.KeepAlive(cklassAllocMap)
	__v := *NewRbAllocFuncTRef(unsafe.Pointer(&__ret))
	return __v
}

// RbClearConstantCacheForId function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbClearConstantCacheForId(id ID) {
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	C.rb_clear_constant_cache_for_id(cid)
	runtime.KeepAlive(cidAllocMap)
}

// RbAlias function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbAlias(klass VALUE, dst ID, src ID) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cdst, cdstAllocMap := (C.ID)(dst), cgoAllocsUnknown
	csrc, csrcAllocMap := (C.ID)(src), cgoAllocsUnknown
	C.rb_alias(cklass, cdst, csrc)
	runtime.KeepAlive(csrcAllocMap)
	runtime.KeepAlive(cdstAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbAttr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbAttr(klass VALUE, name ID, needReader int32, needWriter int32, honourVisibility int32) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cname, cnameAllocMap := (C.ID)(name), cgoAllocsUnknown
	cneedReader, cneedReaderAllocMap := (C.int)(needReader), cgoAllocsUnknown
	cneedWriter, cneedWriterAllocMap := (C.int)(needWriter), cgoAllocsUnknown
	chonourVisibility, chonourVisibilityAllocMap := (C.int)(honourVisibility), cgoAllocsUnknown
	C.rb_attr(cklass, cname, cneedReader, cneedWriter, chonourVisibility)
	runtime.KeepAlive(chonourVisibilityAllocMap)
	runtime.KeepAlive(cneedWriterAllocMap)
	runtime.KeepAlive(cneedReaderAllocMap)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbRemoveMethod function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbRemoveMethod(klass VALUE, name string) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	C.rb_remove_method(cklass, cname)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbRemoveMethodId function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbRemoveMethodId(klass VALUE, mid ID) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	C.rb_remove_method_id(cklass, cmid)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbMethodBoundp function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbMethodBoundp(klass VALUE, id ID, ex int32) int32 {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	cex, cexAllocMap := (C.int)(ex), cgoAllocsUnknown
	__ret := C.rb_method_boundp(cklass, cid, cex)
	runtime.KeepAlive(cexAllocMap)
	runtime.KeepAlive(cidAllocMap)
	runtime.KeepAlive(cklassAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbMethodBasicDefinitionP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbMethodBasicDefinitionP(klass VALUE, mid ID) int32 {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	__ret := C.rb_method_basic_definition_p(cklass, cmid)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(cklassAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbObjRespondTo function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbObjRespondTo(obj VALUE, mid ID, privateP int32) int32 {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	cprivateP, cprivatePAllocMap := (C.int)(privateP), cgoAllocsUnknown
	__ret := C.rb_obj_respond_to(cobj, cmid, cprivateP)
	runtime.KeepAlive(cprivatePAllocMap)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbRespondTo function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbRespondTo(obj VALUE, mid ID) int32 {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	__ret := C.rb_respond_to(cobj, cmid)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbFNotimplement function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbFNotimplement(argc int32, argv []VALUE, obj VALUE, marker VALUE) VALUE {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cmarker, cmarkerAllocMap := (C.VALUE)(marker), cgoAllocsUnknown
	__ret := C.rb_f_notimplement(cargc, cargv, cobj, cmarker)
	runtime.KeepAlive(cmarkerAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBacktrace function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbBacktrace() {
	C.rb_backtrace()
}

// RbMakeBacktrace function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/intern/vm.h
func RbMakeBacktrace() VALUE {
	__ret := C.rb_make_backtrace()
	__v := (VALUE)(__ret)
	return __v
}

// RbEach function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbEach(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_each(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbYield function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbYield(val VALUE) VALUE {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	__ret := C.rb_yield(cval)
	runtime.KeepAlive(cvalAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbYieldValues function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbYieldValues(n int32) VALUE {
	cn, cnAllocMap := (C.int)(n), cgoAllocsUnknown
	__ret := C.rb_yield_values(cn)
	runtime.KeepAlive(cnAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbYieldValues2 function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbYieldValues2(n int32, argv []VALUE) VALUE {
	cn, cnAllocMap := (C.int)(n), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	__ret := C.rb_yield_values2(cn, cargv)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cnAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbYieldValuesKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbYieldValuesKw(n int32, argv []VALUE, kwSplat int32) VALUE {
	cn, cnAllocMap := (C.int)(n), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	__ret := C.rb_yield_values_kw(cn, cargv, ckwSplat)
	runtime.KeepAlive(ckwSplatAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cnAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbYieldSplat function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbYieldSplat(ary VALUE) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	__ret := C.rb_yield_splat(cary)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbYieldSplatKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbYieldSplatKw(ary VALUE, kwSplat int32) VALUE {
	cary, caryAllocMap := (C.VALUE)(ary), cgoAllocsUnknown
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	__ret := C.rb_yield_splat_kw(cary, ckwSplat)
	runtime.KeepAlive(ckwSplatAllocMap)
	runtime.KeepAlive(caryAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbYieldBlock function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbYieldBlock(yieldedArg VALUE, callbackArg VALUE, argc int32, argv []VALUE, blockarg VALUE) VALUE {
	cyieldedArg, cyieldedArgAllocMap := (C.VALUE)(yieldedArg), cgoAllocsUnknown
	ccallbackArg, ccallbackArgAllocMap := (C.VALUE)(callbackArg), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cblockarg, cblockargAllocMap := (C.VALUE)(blockarg), cgoAllocsUnknown
	__ret := C.rb_yield_block(cyieldedArg, ccallbackArg, cargc, cargv, cblockarg)
	runtime.KeepAlive(cblockargAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(ccallbackArgAllocMap)
	runtime.KeepAlive(cyieldedArgAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbKeywordGivenP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbKeywordGivenP() int32 {
	__ret := C.rb_keyword_given_p()
	__v := (int32)(__ret)
	return __v
}

// RbBlockGivenP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbBlockGivenP() int32 {
	__ret := C.rb_block_given_p()
	__v := (int32)(__ret)
	return __v
}

// RbNeedBlock function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbNeedBlock() {
	C.rb_need_block()
}

// RbIterate function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbIterate(func1 VALUE, data1 VALUE, proc RbBlockCallFuncT, data2 VALUE) VALUE {
	cfunc1, cfunc1AllocMap := func1.PassRef()
	cdata1, cdata1AllocMap := (C.VALUE)(data1), cgoAllocsUnknown
	cproc, cprocAllocMap := proc.PassValue()
	cdata2, cdata2AllocMap := (C.VALUE)(data2), cgoAllocsUnknown
	__ret := C.rb_iterate(cfunc1, cdata1, cproc, cdata2)
	runtime.KeepAlive(cdata2AllocMap)
	runtime.KeepAlive(cprocAllocMap)
	runtime.KeepAlive(cdata1AllocMap)
	runtime.KeepAlive(cfunc1AllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBlockCall function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbBlockCall(obj VALUE, mid ID, argc int32, argv []VALUE, proc RbBlockCallFuncT, data2 VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cproc, cprocAllocMap := proc.PassValue()
	cdata2, cdata2AllocMap := (C.VALUE)(data2), cgoAllocsUnknown
	__ret := C.rb_block_call(cobj, cmid, cargc, cargv, cproc, cdata2)
	runtime.KeepAlive(cdata2AllocMap)
	runtime.KeepAlive(cprocAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbBlockCallKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbBlockCallKw(obj VALUE, mid ID, argc int32, argv []VALUE, proc RbBlockCallFuncT, data2 VALUE, kwSplat int32) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cmid, cmidAllocMap := (C.ID)(mid), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cproc, cprocAllocMap := proc.PassValue()
	cdata2, cdata2AllocMap := (C.VALUE)(data2), cgoAllocsUnknown
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	__ret := C.rb_block_call_kw(cobj, cmid, cargc, cargv, cproc, cdata2, ckwSplat)
	runtime.KeepAlive(ckwSplatAllocMap)
	runtime.KeepAlive(cdata2AllocMap)
	runtime.KeepAlive(cprocAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRescue function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbRescue(bProc VALUE, data1 VALUE, rProc VALUE, data2 VALUE) VALUE {
	cbProc, cbProcAllocMap := bProc.PassRef()
	cdata1, cdata1AllocMap := (C.VALUE)(data1), cgoAllocsUnknown
	crProc, crProcAllocMap := rProc.PassRef()
	cdata2, cdata2AllocMap := (C.VALUE)(data2), cgoAllocsUnknown
	__ret := C.rb_rescue(cbProc, cdata1, crProc, cdata2)
	runtime.KeepAlive(cdata2AllocMap)
	runtime.KeepAlive(crProcAllocMap)
	runtime.KeepAlive(cdata1AllocMap)
	runtime.KeepAlive(cbProcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRescue2 function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbRescue2(bProc VALUE, data1 VALUE, rProc VALUE, data2 VALUE) VALUE {
	cbProc, cbProcAllocMap := bProc.PassRef()
	cdata1, cdata1AllocMap := (C.VALUE)(data1), cgoAllocsUnknown
	crProc, crProcAllocMap := rProc.PassRef()
	cdata2, cdata2AllocMap := (C.VALUE)(data2), cgoAllocsUnknown
	__ret := C.rb_rescue2(cbProc, cdata1, crProc, cdata2)
	runtime.KeepAlive(cdata2AllocMap)
	runtime.KeepAlive(crProcAllocMap)
	runtime.KeepAlive(cdata1AllocMap)
	runtime.KeepAlive(cbProcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbVrescue2 function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbVrescue2(bProc VALUE, data1 VALUE, rProc VALUE, data2 VALUE, ap unsafe.Pointer) VALUE {
	cbProc, cbProcAllocMap := bProc.PassRef()
	cdata1, cdata1AllocMap := (C.VALUE)(data1), cgoAllocsUnknown
	crProc, crProcAllocMap := rProc.PassRef()
	cdata2, cdata2AllocMap := (C.VALUE)(data2), cgoAllocsUnknown
	cap, capAllocMap := ap, cgoAllocsUnknown
	__ret := C.rb_vrescue2(cbProc, cdata1, crProc, cdata2, cap)
	runtime.KeepAlive(capAllocMap)
	runtime.KeepAlive(cdata2AllocMap)
	runtime.KeepAlive(crProcAllocMap)
	runtime.KeepAlive(cdata1AllocMap)
	runtime.KeepAlive(cbProcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbEnsure function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbEnsure(bProc VALUE, data1 VALUE, eProc VALUE, data2 VALUE) VALUE {
	cbProc, cbProcAllocMap := bProc.PassRef()
	cdata1, cdata1AllocMap := (C.VALUE)(data1), cgoAllocsUnknown
	ceProc, ceProcAllocMap := eProc.PassRef()
	cdata2, cdata2AllocMap := (C.VALUE)(data2), cgoAllocsUnknown
	__ret := C.rb_ensure(cbProc, cdata1, ceProc, cdata2)
	runtime.KeepAlive(cdata2AllocMap)
	runtime.KeepAlive(ceProcAllocMap)
	runtime.KeepAlive(cdata1AllocMap)
	runtime.KeepAlive(cbProcAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCatch function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbCatch(tag string, _func RbBlockCallFuncT, data VALUE) VALUE {
	tag = safeString(tag)
	ctag, ctagAllocMap := unpackPCharString(tag)
	c_func, c_funcAllocMap := _func.PassValue()
	cdata, cdataAllocMap := (C.VALUE)(data), cgoAllocsUnknown
	__ret := C.rb_catch(ctag, c_func, cdata)
	runtime.KeepAlive(cdataAllocMap)
	runtime.KeepAlive(c_funcAllocMap)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(ctagAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCatchObj function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbCatchObj(tag VALUE, _func RbBlockCallFuncT, data VALUE) VALUE {
	ctag, ctagAllocMap := (C.VALUE)(tag), cgoAllocsUnknown
	c_func, c_funcAllocMap := _func.PassValue()
	cdata, cdataAllocMap := (C.VALUE)(data), cgoAllocsUnknown
	__ret := C.rb_catch_obj(ctag, c_func, cdata)
	runtime.KeepAlive(cdataAllocMap)
	runtime.KeepAlive(c_funcAllocMap)
	runtime.KeepAlive(ctagAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbThrow function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbThrow(tag string, val VALUE) {
	tag = safeString(tag)
	ctag, ctagAllocMap := unpackPCharString(tag)
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	C.rb_throw(ctag, cval)
	runtime.KeepAlive(cvalAllocMap)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(ctagAllocMap)
}

// RbThrowObj function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/iterator.h
func RbThrowObj(tag VALUE, val VALUE) {
	ctag, ctagAllocMap := (C.VALUE)(tag), cgoAllocsUnknown
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	C.rb_throw_obj(ctag, cval)
	runtime.KeepAlive(cvalAllocMap)
	runtime.KeepAlive(ctagAllocMap)
}

// RbAllocTmpBuffer function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/memory.h
func RbAllocTmpBuffer(store []VALUE, len int64) unsafe.Pointer {
	cstore, cstoreAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&store)).Data)), cgoAllocsUnknown
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_alloc_tmp_buffer(cstore, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(cstoreAllocMap)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// RbAllocTmpBufferWithCount function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/memory.h
func RbAllocTmpBufferWithCount(store []VALUE, len uint64, count uint64) unsafe.Pointer {
	cstore, cstoreAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&store)).Data)), cgoAllocsUnknown
	clen, clenAllocMap := (C.size_t)(len), cgoAllocsUnknown
	ccount, ccountAllocMap := (C.size_t)(count), cgoAllocsUnknown
	__ret := C.rb_alloc_tmp_buffer_with_count(cstore, clen, ccount)
	runtime.KeepAlive(ccountAllocMap)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(cstoreAllocMap)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// RbFreeTmpBuffer function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/memory.h
func RbFreeTmpBuffer(store []VALUE) {
	cstore, cstoreAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&store)).Data)), cgoAllocsUnknown
	C.rb_free_tmp_buffer(cstore)
	runtime.KeepAlive(cstoreAllocMap)
}

// RbMulSizeOverflow function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/memory.h
func RbMulSizeOverflow(a uint64, b uint64, max uint64, c []uint64) int32 {
	ca, caAllocMap := (C.size_t)(a), cgoAllocsUnknown
	cb, cbAllocMap := (C.size_t)(b), cgoAllocsUnknown
	cmax, cmaxAllocMap := (C.size_t)(max), cgoAllocsUnknown
	cc, ccAllocMap := (*C.size_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&c)).Data)), cgoAllocsUnknown
	__ret := C.rb_mul_size_overflow(ca, cb, cmax, cc)
	runtime.KeepAlive(ccAllocMap)
	runtime.KeepAlive(cmaxAllocMap)
	runtime.KeepAlive(cbAllocMap)
	runtime.KeepAlive(caAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbAllocTmpBuffer2 function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/memory.h
func RbAllocTmpBuffer2(store []VALUE, count int64, elsize uint64) unsafe.Pointer {
	cstore, cstoreAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&store)).Data)), cgoAllocsUnknown
	ccount, ccountAllocMap := (C.long)(count), cgoAllocsUnknown
	celsize, celsizeAllocMap := (C.size_t)(elsize), cgoAllocsUnknown
	__ret := C.rb_alloc_tmp_buffer2(cstore, ccount, celsize)
	runtime.KeepAlive(celsizeAllocMap)
	runtime.KeepAlive(ccountAllocMap)
	runtime.KeepAlive(cstoreAllocMap)
	__v := *(*unsafe.Pointer)(unsafe.Pointer(&__ret))
	return __v
}

// RbDefineMethod function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/method.h
func RbDefineMethod(klass VALUE, mid string, _func VALUE, arity int32) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	mid = safeString(mid)
	cmid, cmidAllocMap := unpackPCharString(mid)
	c_func, c_funcAllocMap := _func.PassRef()
	carity, carityAllocMap := (C.int)(arity), cgoAllocsUnknown
	C.rb_define_method(cklass, cmid, c_func, carity)
	runtime.KeepAlive(carityAllocMap)
	runtime.KeepAlive(c_funcAllocMap)
	runtime.KeepAlive(mid)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbDefineModuleFunction function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/method.h
func RbDefineModuleFunction(klass VALUE, mid string, _func VALUE, arity int32) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	mid = safeString(mid)
	cmid, cmidAllocMap := unpackPCharString(mid)
	c_func, c_funcAllocMap := _func.PassRef()
	carity, carityAllocMap := (C.int)(arity), cgoAllocsUnknown
	C.rb_define_module_function(cklass, cmid, c_func, carity)
	runtime.KeepAlive(carityAllocMap)
	runtime.KeepAlive(c_funcAllocMap)
	runtime.KeepAlive(mid)
	runtime.KeepAlive(cmidAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbDefineGlobalFunction function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/method.h
func RbDefineGlobalFunction(mid string, _func VALUE, arity int32) {
	mid = safeString(mid)
	cmid, cmidAllocMap := unpackPCharString(mid)
	c_func, c_funcAllocMap := _func.PassRef()
	carity, carityAllocMap := (C.int)(arity), cgoAllocsUnknown
	C.rb_define_global_function(cmid, c_func, carity)
	runtime.KeepAlive(carityAllocMap)
	runtime.KeepAlive(c_funcAllocMap)
	runtime.KeepAlive(mid)
	runtime.KeepAlive(cmidAllocMap)
}

// RbUndefMethod function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/method.h
func RbUndefMethod(klass VALUE, name string) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	C.rb_undef_method(cklass, cname)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbDefineAlias function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/method.h
func RbDefineAlias(klass VALUE, dst string, src string) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	dst = safeString(dst)
	cdst, cdstAllocMap := unpackPCharString(dst)
	src = safeString(src)
	csrc, csrcAllocMap := unpackPCharString(src)
	C.rb_define_alias(cklass, cdst, csrc)
	runtime.KeepAlive(src)
	runtime.KeepAlive(csrcAllocMap)
	runtime.KeepAlive(dst)
	runtime.KeepAlive(cdstAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbDefineAttr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/method.h
func RbDefineAttr(klass VALUE, name string, read int32, write int32) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	cread, creadAllocMap := (C.int)(read), cgoAllocsUnknown
	cwrite, cwriteAllocMap := (C.int)(write), cgoAllocsUnknown
	C.rb_define_attr(cklass, cname, cread, cwrite)
	runtime.KeepAlive(cwriteAllocMap)
	runtime.KeepAlive(creadAllocMap)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbDefineClass function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/module.h
func RbDefineClass(name string, super VALUE) VALUE {
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	csuper, csuperAllocMap := (C.VALUE)(super), cgoAllocsUnknown
	__ret := C.rb_define_class(cname, csuper)
	runtime.KeepAlive(csuperAllocMap)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDefineModule function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/module.h
func RbDefineModule(name string) VALUE {
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	__ret := C.rb_define_module(cname)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDefineClassUnder function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/module.h
func RbDefineClassUnder(outer VALUE, name string, super VALUE) VALUE {
	couter, couterAllocMap := (C.VALUE)(outer), cgoAllocsUnknown
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	csuper, csuperAllocMap := (C.VALUE)(super), cgoAllocsUnknown
	__ret := C.rb_define_class_under(couter, cname, csuper)
	runtime.KeepAlive(csuperAllocMap)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(couterAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbDefineModuleUnder function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/module.h
func RbDefineModuleUnder(outer VALUE, name string) VALUE {
	couter, couterAllocMap := (C.VALUE)(outer), cgoAllocsUnknown
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	__ret := C.rb_define_module_under(couter, cname)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(couterAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIncludeModule function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/module.h
func RbIncludeModule(klass VALUE, module VALUE) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cmodule, cmoduleAllocMap := (C.VALUE)(module), cgoAllocsUnknown
	C.rb_include_module(cklass, cmodule)
	runtime.KeepAlive(cmoduleAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbExtendObject function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/module.h
func RbExtendObject(obj VALUE, mod VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	C.rb_extend_object(cobj, cmod)
	runtime.KeepAlive(cmodAllocMap)
	runtime.KeepAlive(cobjAllocMap)
}

// RbPrependModule function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/module.h
func RbPrependModule(klass VALUE, module VALUE) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cmodule, cmoduleAllocMap := (C.VALUE)(module), cgoAllocsUnknown
	C.rb_prepend_module(cklass, cmodule)
	runtime.KeepAlive(cmoduleAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbNewobj function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/newobj.h
func RbNewobj() VALUE {
	__ret := C.rb_newobj()
	__v := (VALUE)(__ret)
	return __v
}

// RbNewobjOf function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/newobj.h
func RbNewobjOf(klass VALUE, flags VALUE) VALUE {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cflags, cflagsAllocMap := (C.VALUE)(flags), cgoAllocsUnknown
	__ret := C.rb_newobj_of(cklass, cflags)
	runtime.KeepAlive(cflagsAllocMap)
	runtime.KeepAlive(cklassAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjSetup function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/newobj.h
func RbObjSetup(obj VALUE, klass VALUE, kind VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	ckind, ckindAllocMap := (C.VALUE)(kind), cgoAllocsUnknown
	__ret := C.rb_obj_setup(cobj, cklass, ckind)
	runtime.KeepAlive(ckindAllocMap)
	runtime.KeepAlive(cklassAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbObjClass function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/newobj.h
func RbObjClass(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_obj_class(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbSingletonClassClone function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/newobj.h
func RbSingletonClassClone(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_singleton_class_clone(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbSingletonClassAttached function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/newobj.h
func RbSingletonClassAttached(klass VALUE, obj VALUE) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	C.rb_singleton_class_attached(cklass, cobj)
	runtime.KeepAlive(cobjAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbCopyGenericIvar function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/newobj.h
func RbCopyGenericIvar(clone VALUE, obj VALUE) {
	cclone, ccloneAllocMap := (C.VALUE)(clone), cgoAllocsUnknown
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	C.rb_copy_generic_ivar(cclone, cobj)
	runtime.KeepAlive(cobjAllocMap)
	runtime.KeepAlive(ccloneAllocMap)
}

// RbCloneSetup function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/newobj.h
func RbCloneSetup(clone VALUE, obj VALUE) {
	cclone, ccloneAllocMap := (C.VALUE)(clone), cgoAllocsUnknown
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	C.rb_clone_setup(cclone, cobj)
	runtime.KeepAlive(cobjAllocMap)
	runtime.KeepAlive(ccloneAllocMap)
}

// RbDupSetup function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/newobj.h
func RbDupSetup(dup VALUE, obj VALUE) {
	cdup, cdupAllocMap := (C.VALUE)(dup), cgoAllocsUnknown
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	C.rb_dup_setup(cdup, cobj)
	runtime.KeepAlive(cobjAllocMap)
	runtime.KeepAlive(cdupAllocMap)
}

// RbScanArgs function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/scan_args.h
func RbScanArgs(argc int32, argv []VALUE, fmt string) int32 {
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	__ret := C.rb_scan_args(cargc, cargv, cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbScanArgsKw function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/scan_args.h
func RbScanArgsKw(kwSplat int32, argc int32, argv []VALUE, fmt string) int32 {
	ckwSplat, ckwSplatAllocMap := (C.int)(kwSplat), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	__ret := C.rb_scan_args_kw(ckwSplat, cargc, cargv, cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(ckwSplatAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbScanArgsBadFormat function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/scan_args.h
func RbScanArgsBadFormat(arg0 []byte) {
	carg0, carg0AllocMap := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&arg0)).Data)), cgoAllocsUnknown
	C.rb_scan_args_bad_format(carg0)
	runtime.KeepAlive(carg0AllocMap)
}

// RbScanArgsLengthMismatch function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/scan_args.h
func RbScanArgsLengthMismatch(arg0 []byte, arg1 int32) {
	carg0, carg0AllocMap := (*C.char)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&arg0)).Data)), cgoAllocsUnknown
	carg1, carg1AllocMap := (C.int)(arg1), cgoAllocsUnknown
	C.rb_scan_args_length_mismatch(carg0, carg1)
	runtime.KeepAlive(carg1AllocMap)
	runtime.KeepAlive(carg0AllocMap)
}

// RbScanArgsKeywordP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/scan_args.h
func RbScanArgsKeywordP(kwFlag int32, last VALUE) bool {
	ckwFlag, ckwFlagAllocMap := (C.int)(kwFlag), cgoAllocsUnknown
	clast, clastAllocMap := (C.VALUE)(last), cgoAllocsUnknown
	__ret := C.rb_scan_args_keyword_p(ckwFlag, clast)
	runtime.KeepAlive(clastAllocMap)
	runtime.KeepAlive(ckwFlagAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RbScanArgsLeadP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/scan_args.h
func RbScanArgsLeadP(fmt string) bool {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	__ret := C.rb_scan_args_lead_p(cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RbScanArgsNLead function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/scan_args.h
func RbScanArgsNLead(fmt string) int32 {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	__ret := C.rb_scan_args_n_lead(cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbScanArgsOptP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/scan_args.h
func RbScanArgsOptP(fmt string) bool {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	__ret := C.rb_scan_args_opt_p(cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RbScanArgsNOpt function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/scan_args.h
func RbScanArgsNOpt(fmt string) int32 {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	__ret := C.rb_scan_args_n_opt(cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbScanArgsVarIdx function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/scan_args.h
func RbScanArgsVarIdx(fmt string) int32 {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	__ret := C.rb_scan_args_var_idx(cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbScanArgsFVar function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/scan_args.h
func RbScanArgsFVar(fmt string) bool {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	__ret := C.rb_scan_args_f_var(cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RbScanArgsTrailIdx function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/scan_args.h
func RbScanArgsTrailIdx(fmt string) int32 {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	__ret := C.rb_scan_args_trail_idx(cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbScanArgsNTrail function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/scan_args.h
func RbScanArgsNTrail(fmt string) int32 {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	__ret := C.rb_scan_args_n_trail(cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbScanArgsHashIdx function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/scan_args.h
func RbScanArgsHashIdx(fmt string) int32 {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	__ret := C.rb_scan_args_hash_idx(cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbScanArgsFHash function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/scan_args.h
func RbScanArgsFHash(fmt string) bool {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	__ret := C.rb_scan_args_f_hash(cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RbScanArgsBlockIdx function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/scan_args.h
func RbScanArgsBlockIdx(fmt string) int32 {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	__ret := C.rb_scan_args_block_idx(cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbScanArgsFBlock function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/scan_args.h
func RbScanArgsFBlock(fmt string) bool {
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	__ret := C.rb_scan_args_f_block(cfmt)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RbScanArgsSet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/scan_args.h
func RbScanArgsSet(kwFlag int32, argc int32, argv []VALUE, nLead int32, nOpt int32, nTrail int32, fVar bool, fHash bool, fBlock bool, vars [][]VALUE, fmt string, varc int32) int32 {
	ckwFlag, ckwFlagAllocMap := (C.int)(kwFlag), cgoAllocsUnknown
	cargc, cargcAllocMap := (C.int)(argc), cgoAllocsUnknown
	cargv, cargvAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&argv)).Data)), cgoAllocsUnknown
	cnLead, cnLeadAllocMap := (C.int)(nLead), cgoAllocsUnknown
	cnOpt, cnOptAllocMap := (C.int)(nOpt), cgoAllocsUnknown
	cnTrail, cnTrailAllocMap := (C.int)(nTrail), cgoAllocsUnknown
	cfVar, cfVarAllocMap := (C._Bool)(fVar), cgoAllocsUnknown
	cfHash, cfHashAllocMap := (C._Bool)(fHash), cgoAllocsUnknown
	cfBlock, cfBlockAllocMap := (C._Bool)(fBlock), cgoAllocsUnknown
	cvars, cvarsAllocMap := unpackArgSSUVALUE(vars)
	fmt = safeString(fmt)
	cfmt, cfmtAllocMap := unpackPCharString(fmt)
	cvarc, cvarcAllocMap := (C.int)(varc), cgoAllocsUnknown
	__ret := C.rb_scan_args_set(ckwFlag, cargc, cargv, cnLead, cnOpt, cnTrail, cfVar, cfHash, cfBlock, cvars, cfmt, cvarc)
	runtime.KeepAlive(cvarcAllocMap)
	runtime.KeepAlive(fmt)
	runtime.KeepAlive(cfmtAllocMap)
	packSSUVALUE(vars, cvars)
	runtime.KeepAlive(cvarsAllocMap)
	runtime.KeepAlive(cfBlockAllocMap)
	runtime.KeepAlive(cfHashAllocMap)
	runtime.KeepAlive(cfVarAllocMap)
	runtime.KeepAlive(cnTrailAllocMap)
	runtime.KeepAlive(cnOptAllocMap)
	runtime.KeepAlive(cnLeadAllocMap)
	runtime.KeepAlive(cargvAllocMap)
	runtime.KeepAlive(cargcAllocMap)
	runtime.KeepAlive(ckwFlagAllocMap)
	__v := (int32)(__ret)
	return __v
}

// RB_TEST function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/special_consts.h
func RB_TEST(obj VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_TEST(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_NIL_P function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/special_consts.h
func RB_NIL_P(obj VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_NIL_P(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_UNDEF_P function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/special_consts.h
func RB_UNDEF_P(obj VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_UNDEF_P(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_NIL_OR_UNDEF_P function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/special_consts.h
func RB_NIL_OR_UNDEF_P(obj VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_NIL_OR_UNDEF_P(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_FIXNUM_P function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/special_consts.h
func RB_FIXNUM_P(obj VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_FIXNUM_P(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_STATIC_SYM_P function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/special_consts.h
func RB_STATIC_SYM_P(obj VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_STATIC_SYM_P(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_FLONUM_P function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/special_consts.h
func RB_FLONUM_P(obj VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_FLONUM_P(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_IMMEDIATE_P function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/special_consts.h
func RB_IMMEDIATE_P(obj VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_IMMEDIATE_P(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_SPECIAL_CONST_P function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/special_consts.h
func RB_SPECIAL_CONST_P(obj VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_SPECIAL_CONST_P(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RbSpecialConstP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/special_consts.h
func RbSpecialConstP(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_special_const_p(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbSym2id function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/symbol.h
func RbSym2id(obj VALUE) ID {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_sym2id(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (ID)(__ret)
	return __v
}

// RbId2sym function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/symbol.h
func RbId2sym(id ID) VALUE {
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	__ret := C.rb_id2sym(cid)
	runtime.KeepAlive(cidAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIntern function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/symbol.h
func RbIntern(name string) ID {
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	__ret := C.rb_intern(cname)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	__v := (ID)(__ret)
	return __v
}

// RbIntern2 function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/symbol.h
func RbIntern2(name string, len int64) ID {
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	clen, clenAllocMap := (C.long)(len), cgoAllocsUnknown
	__ret := C.rb_intern2(cname, clen)
	runtime.KeepAlive(clenAllocMap)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	__v := (ID)(__ret)
	return __v
}

// RbInternStr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/symbol.h
func RbInternStr(str VALUE) ID {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_intern_str(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := (ID)(__ret)
	return __v
}

// RbId2name function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/symbol.h
func RbId2name(id ID) *byte {
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	__ret := C.rb_id2name(cid)
	runtime.KeepAlive(cidAllocMap)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// RbCheckId function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/symbol.h
func RbCheckId(namep []VALUE) ID {
	cnamep, cnamepAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&namep)).Data)), cgoAllocsUnknown
	__ret := C.rb_check_id(cnamep)
	runtime.KeepAlive(cnamepAllocMap)
	__v := (ID)(__ret)
	return __v
}

// RbToId function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/symbol.h
func RbToId(str VALUE) ID {
	cstr, cstrAllocMap := (C.VALUE)(str), cgoAllocsUnknown
	__ret := C.rb_to_id(cstr)
	runtime.KeepAlive(cstrAllocMap)
	__v := (ID)(__ret)
	return __v
}

// RbId2str function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/symbol.h
func RbId2str(id ID) VALUE {
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	__ret := C.rb_id2str(cid)
	runtime.KeepAlive(cidAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbSym2str function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/symbol.h
func RbSym2str(id VALUE) VALUE {
	cid, cidAllocMap := (C.VALUE)(id), cgoAllocsUnknown
	__ret := C.rb_sym2str(cid)
	runtime.KeepAlive(cidAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbToSymbol function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/symbol.h
func RbToSymbol(name VALUE) VALUE {
	cname, cnameAllocMap := (C.VALUE)(name), cgoAllocsUnknown
	__ret := C.rb_to_symbol(cname)
	runtime.KeepAlive(cnameAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbCheckSymbol function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/symbol.h
func RbCheckSymbol(namep []VALUE) VALUE {
	cnamep, cnamepAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&namep)).Data)), cgoAllocsUnknown
	__ret := C.rb_check_symbol(cnamep)
	runtime.KeepAlive(cnamepAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbInternConst function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/symbol.h
func RbInternConst(str string) ID {
	str = safeString(str)
	cstr, cstrAllocMap := unpackPCharString(str)
	__ret := C.rb_intern_const(cstr)
	runtime.KeepAlive(str)
	runtime.KeepAlive(cstrAllocMap)
	__v := (ID)(__ret)
	return __v
}

// RbCheckType function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/value_type.h
func RbCheckType(obj VALUE, t int32) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	ct, ctAllocMap := (C.int)(t), cgoAllocsUnknown
	C.rb_check_type(cobj, ct)
	runtime.KeepAlive(ctAllocMap)
	runtime.KeepAlive(cobjAllocMap)
}

// RbIntegerTypeP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/value_type.h
func RbIntegerTypeP(obj VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_integer_type_p(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_FLOAT_TYPE_P function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/value_type.h
func RB_FLOAT_TYPE_P(obj VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_FLOAT_TYPE_P(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_DYNAMIC_SYM_P function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/value_type.h
func RB_DYNAMIC_SYM_P(obj VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_DYNAMIC_SYM_P(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RB_SYMBOL_P function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/value_type.h
func RB_SYMBOL_P(obj VALUE) bool {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.RB_SYMBOL_P(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (bool)(__ret)
	return __v
}

// RbGvarUndefGetter function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbGvarUndefGetter(id ID, data []VALUE) uint64 {
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	cdata, cdataAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	__ret := C.rb_gvar_undef_getter(cid, cdata)
	runtime.KeepAlive(cdataAllocMap)
	runtime.KeepAlive(cidAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbGvarUndefSetter function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbGvarUndefSetter(val VALUE, id ID, data []VALUE) {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	cdata, cdataAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	C.rb_gvar_undef_setter(cval, cid, cdata)
	runtime.KeepAlive(cdataAllocMap)
	runtime.KeepAlive(cidAllocMap)
	runtime.KeepAlive(cvalAllocMap)
}

// RbGvarUndefMarker function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbGvarUndefMarker(_var []VALUE) {
	c_var, c_varAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&_var)).Data)), cgoAllocsUnknown
	C.rb_gvar_undef_marker(c_var)
	runtime.KeepAlive(c_varAllocMap)
}

// RbGvarValGetter function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbGvarValGetter(id ID, data []VALUE) uint64 {
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	cdata, cdataAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	__ret := C.rb_gvar_val_getter(cid, cdata)
	runtime.KeepAlive(cdataAllocMap)
	runtime.KeepAlive(cidAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbGvarValSetter function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbGvarValSetter(val VALUE, id ID, data []VALUE) {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	cdata, cdataAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	C.rb_gvar_val_setter(cval, cid, cdata)
	runtime.KeepAlive(cdataAllocMap)
	runtime.KeepAlive(cidAllocMap)
	runtime.KeepAlive(cvalAllocMap)
}

// RbGvarValMarker function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbGvarValMarker(_var []VALUE) {
	c_var, c_varAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&_var)).Data)), cgoAllocsUnknown
	C.rb_gvar_val_marker(c_var)
	runtime.KeepAlive(c_varAllocMap)
}

// RbGvarVarGetter function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbGvarVarGetter(id ID, data []VALUE) uint64 {
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	cdata, cdataAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	__ret := C.rb_gvar_var_getter(cid, cdata)
	runtime.KeepAlive(cdataAllocMap)
	runtime.KeepAlive(cidAllocMap)
	__v := (uint64)(__ret)
	return __v
}

// RbGvarVarSetter function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbGvarVarSetter(val VALUE, id ID, data []VALUE) {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	cdata, cdataAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	C.rb_gvar_var_setter(cval, cid, cdata)
	runtime.KeepAlive(cdataAllocMap)
	runtime.KeepAlive(cidAllocMap)
	runtime.KeepAlive(cvalAllocMap)
}

// RbGvarVarMarker function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbGvarVarMarker(_var []VALUE) {
	c_var, c_varAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&_var)).Data)), cgoAllocsUnknown
	C.rb_gvar_var_marker(c_var)
	runtime.KeepAlive(c_varAllocMap)
}

// RbGvarReadonlySetter function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbGvarReadonlySetter(val VALUE, id ID, data []VALUE) {
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	cid, cidAllocMap := (C.ID)(id), cgoAllocsUnknown
	cdata, cdataAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&data)).Data)), cgoAllocsUnknown
	C.rb_gvar_readonly_setter(cval, cid, cdata)
	runtime.KeepAlive(cdataAllocMap)
	runtime.KeepAlive(cidAllocMap)
	runtime.KeepAlive(cvalAllocMap)
}

// RbDefineVariable function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbDefineVariable(name string, _var []VALUE) {
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	c_var, c_varAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&_var)).Data)), cgoAllocsUnknown
	C.rb_define_variable(cname, c_var)
	runtime.KeepAlive(c_varAllocMap)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
}

// RbDefineVirtualVariable function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbDefineVirtualVariable(name string, getter RbGvarGetterT, setter RbGvarSetterT) {
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	cgetter, cgetterAllocMap := getter.PassRef()
	csetter, csetterAllocMap := setter.PassRef()
	C.rb_define_virtual_variable(cname, cgetter, csetter)
	runtime.KeepAlive(csetterAllocMap)
	runtime.KeepAlive(cgetterAllocMap)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
}

// RbDefineHookedVariable function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbDefineHookedVariable(name string, _var []VALUE, getter RbGvarGetterT, setter RbGvarSetterT) {
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	c_var, c_varAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&_var)).Data)), cgoAllocsUnknown
	cgetter, cgetterAllocMap := getter.PassRef()
	csetter, csetterAllocMap := setter.PassRef()
	C.rb_define_hooked_variable(cname, c_var, cgetter, csetter)
	runtime.KeepAlive(csetterAllocMap)
	runtime.KeepAlive(cgetterAllocMap)
	runtime.KeepAlive(c_varAllocMap)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
}

// RbDefineReadonlyVariable function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbDefineReadonlyVariable(name string, _var []VALUE) {
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	c_var, c_varAllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&_var)).Data)), cgoAllocsUnknown
	C.rb_define_readonly_variable(cname, c_var)
	runtime.KeepAlive(c_varAllocMap)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
}

// RbDefineConst function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbDefineConst(klass VALUE, name string, val VALUE) {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	C.rb_define_const(cklass, cname, cval)
	runtime.KeepAlive(cvalAllocMap)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cklassAllocMap)
}

// RbDefineGlobalConst function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbDefineGlobalConst(name string, val VALUE) {
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	C.rb_define_global_const(cname, cval)
	runtime.KeepAlive(cvalAllocMap)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
}

// RbDeprecateConstant function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbDeprecateConstant(mod VALUE, name string) {
	cmod, cmodAllocMap := (C.VALUE)(mod), cgoAllocsUnknown
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	C.rb_deprecate_constant(cmod, cname)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cmodAllocMap)
}

// RbGvSet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbGvSet(name string, val VALUE) VALUE {
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	__ret := C.rb_gv_set(cname, cval)
	runtime.KeepAlive(cvalAllocMap)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbGvGet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbGvGet(name string) VALUE {
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	__ret := C.rb_gv_get(cname)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIvGet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbIvGet(obj VALUE, name string) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	__ret := C.rb_iv_get(cobj, cname)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbIvSet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/variable.h
func RbIvSet(obj VALUE, name string, val VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	name = safeString(name)
	cname, cnameAllocMap := unpackPCharString(name)
	cval, cvalAllocMap := (C.VALUE)(val), cgoAllocsUnknown
	__ret := C.rb_iv_set(cobj, cname, cval)
	runtime.KeepAlive(cvalAllocMap)
	runtime.KeepAlive(name)
	runtime.KeepAlive(cnameAllocMap)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbGetPath function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/ruby/ruby.h
func RbGetPath(obj VALUE) VALUE {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_get_path(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbGetPathNoChecksafe function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/ruby/ruby.h
func RbGetPathNoChecksafe(arg0 VALUE) VALUE {
	carg0, carg0AllocMap := (C.VALUE)(arg0), cgoAllocsUnknown
	__ret := C.rb_get_path_no_checksafe(carg0)
	runtime.KeepAlive(carg0AllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbVarargsBadLength function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/ruby/ruby.h
func RbVarargsBadLength(arg0 int32, arg1 int32) int32 {
	carg0, carg0AllocMap := (C.int)(arg0), cgoAllocsUnknown
	carg1, carg1AllocMap := (C.int)(arg1), cgoAllocsUnknown
	__ret := C.rb_varargs_bad_length(carg0, carg1)
	runtime.KeepAlive(carg1AllocMap)
	runtime.KeepAlive(carg0AllocMap)
	__v := (int32)(__ret)
	return __v
}

// RbClass2name function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/ruby/ruby.h
func RbClass2name(klass VALUE) *byte {
	cklass, cklassAllocMap := (C.VALUE)(klass), cgoAllocsUnknown
	__ret := C.rb_class2name(cklass)
	runtime.KeepAlive(cklassAllocMap)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// RbObjClassname function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/ruby/ruby.h
func RbObjClassname(obj VALUE) *byte {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	__ret := C.rb_obj_classname(cobj)
	runtime.KeepAlive(cobjAllocMap)
	__v := *(**byte)(unsafe.Pointer(&__ret))
	return __v
}

// RbP function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/ruby/ruby.h
func RbP(obj VALUE) {
	cobj, cobjAllocMap := (C.VALUE)(obj), cgoAllocsUnknown
	C.rb_p(cobj)
	runtime.KeepAlive(cobjAllocMap)
}

// RbEqual function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/ruby/ruby.h
func RbEqual(lhs VALUE, rhs VALUE) VALUE {
	clhs, clhsAllocMap := (C.VALUE)(lhs), cgoAllocsUnknown
	crhs, crhsAllocMap := (C.VALUE)(rhs), cgoAllocsUnknown
	__ret := C.rb_equal(clhs, crhs)
	runtime.KeepAlive(crhsAllocMap)
	runtime.KeepAlive(clhsAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbRequire function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/ruby/ruby.h
func RbRequire(feature string) VALUE {
	feature = safeString(feature)
	cfeature, cfeatureAllocMap := unpackPCharString(feature)
	__ret := C.rb_require(cfeature)
	runtime.KeepAlive(feature)
	runtime.KeepAlive(cfeatureAllocMap)
	__v := (VALUE)(__ret)
	return __v
}

// RbErrno function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/ruby/ruby.h
func RbErrno() int32 {
	__ret := C.rb_errno()
	__v := (int32)(__ret)
	return __v
}

// RbErrnoSet function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/ruby/ruby.h
func RbErrnoSet(err int32) {
	cerr, cerrAllocMap := (C.int)(err), cgoAllocsUnknown
	C.rb_errno_set(cerr)
	runtime.KeepAlive(cerrAllocMap)
}

// RbErrnoPtr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/ruby/ruby.h
func RbErrnoPtr() *int32 {
	__ret := C.rb_errno_ptr()
	__v := *(**int32)(unsafe.Pointer(&__ret))
	return __v
}

// RbOrigErrnoPtr function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/ruby/ruby.h
func RbOrigErrnoPtr() *int32 {
	__ret := C.rb_orig_errno_ptr()
	__v := *(**int32)(unsafe.Pointer(&__ret))
	return __v
}

// RbHashBulkInsertIntoStTable function as declared in https://github.com/ruby/ruby/blob/master/include/ruby/internal/ruby/st.h
func RbHashBulkInsertIntoStTable(arg0 int64, arg1 []VALUE, arg2 VALUE) {
	carg0, carg0AllocMap := (C.long)(arg0), cgoAllocsUnknown
	carg1, carg1AllocMap := (*C.VALUE)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&arg1)).Data)), cgoAllocsUnknown
	carg2, carg2AllocMap := (C.VALUE)(arg2), cgoAllocsUnknown
	C.rb_hash_bulk_insert_into_st_table(carg0, carg1, carg2)
	runtime.KeepAlive(carg2AllocMap)
	runtime.KeepAlive(carg1AllocMap)
	runtime.KeepAlive(carg0AllocMap)
}
