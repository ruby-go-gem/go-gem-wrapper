// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated
// Code generated by ruby_h_to_go. DO NOT EDIT.

package ruby

/*
#include "ruby.h"
*/
import "C"

// RbEconvResultT is a type for passing `C.rb_econv_result_t` in and out of package
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
type RbEconvResultT C.rb_econv_result_t

// RbEconvT is a type for passing `C.rb_econv_t` in and out of package
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
type RbEconvT C.rb_econv_t

// RbEconvAppend calls `rb_econv_append` in C
//
// Original definition is following
//
//	VALUE rb_econv_append(rb_econv_t *ec, const char *bytesrc, long bytesize, VALUE dst, int flags)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvAppend(ec *RbEconvT, bytesrc string, bytesize Long, dst VALUE, flags int) VALUE {
	char, clean := string2Char(bytesrc)
	defer clean()

	var cEc C.rb_econv_t
	ret := VALUE(C.rb_econv_append(&cEc, char, C.long(bytesize), C.VALUE(dst), C.int(flags)))
	*ec = RbEconvT(cEc)
	return ret
}

// RbEconvAsciicompatEncoding calls `rb_econv_asciicompat_encoding` in C
//
// Original definition is following
//
//	const char *rb_econv_asciicompat_encoding(const char *encname)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvAsciicompatEncoding(encname string) string {
	char, clean := string2Char(encname)
	defer clean()

	ret := string(C.rb_econv_asciicompat_encoding(char))
	return ret
}

// RbEconvBinmode calls `rb_econv_binmode` in C
//
// Original definition is following
//
//	void rb_econv_binmode(rb_econv_t *ec)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvBinmode(ec *RbEconvT) {
	var cEc C.rb_econv_t
	C.rb_econv_binmode(&cEc)
	*ec = RbEconvT(cEc)
}

// RbEconvCheckError calls `rb_econv_check_error` in C
//
// Original definition is following
//
//	void rb_econv_check_error(rb_econv_t *ec)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvCheckError(ec *RbEconvT) {
	var cEc C.rb_econv_t
	C.rb_econv_check_error(&cEc)
	*ec = RbEconvT(cEc)
}

// RbEconvClose calls `rb_econv_close` in C
//
// Original definition is following
//
//	void rb_econv_close(rb_econv_t *ec)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvClose(ec *RbEconvT) {
	var cEc C.rb_econv_t
	C.rb_econv_close(&cEc)
	*ec = RbEconvT(cEc)
}

// RbEconvConvert calls `rb_econv_convert` in C
//
// Original definition is following
//
//	rb_econv_result_t rb_econv_convert(rb_econv_t *ec,
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvConvert(ec *RbEconvT, source_buffer_ptr *Uchar, source_buffer_end *Uchar, destination_buffer_ptr *Uchar, destination_buffer_end *Uchar, flags int) RbEconvResultT {
	var cEc C.rb_econv_t
	var cSourceBufferPtr C.uchar
	var cSourceBufferEnd C.uchar
	var cDestinationBufferPtr C.uchar
	var cDestinationBufferEnd C.uchar
	ret := RbEconvResultT(C.rb_econv_convert(&cEc, &cSourceBufferPtr, &cSourceBufferEnd, &cDestinationBufferPtr, &cDestinationBufferEnd, C.int(flags)))
	*ec = RbEconvT(cEc)
	*source_buffer_ptr = Uchar(cSourceBufferPtr)
	*source_buffer_end = Uchar(cSourceBufferEnd)
	*destination_buffer_ptr = Uchar(cDestinationBufferPtr)
	*destination_buffer_end = Uchar(cDestinationBufferEnd)
	return ret
}

// RbEconvDecorateAtFirst calls `rb_econv_decorate_at_first` in C
//
// Original definition is following
//
//	int rb_econv_decorate_at_first(rb_econv_t *ec, const char *decorator_name)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvDecorateAtFirst(ec *RbEconvT, decorator_name string) int {
	char, clean := string2Char(decorator_name)
	defer clean()

	var cEc C.rb_econv_t
	ret := int(C.rb_econv_decorate_at_first(&cEc, char))
	*ec = RbEconvT(cEc)
	return ret
}

// RbEconvDecorateAtLast calls `rb_econv_decorate_at_last` in C
//
// Original definition is following
//
//	int rb_econv_decorate_at_last(rb_econv_t *ec, const char *decorator_name)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvDecorateAtLast(ec *RbEconvT, decorator_name string) int {
	char, clean := string2Char(decorator_name)
	defer clean()

	var cEc C.rb_econv_t
	ret := int(C.rb_econv_decorate_at_last(&cEc, char))
	*ec = RbEconvT(cEc)
	return ret
}

// RbEconvEncodingToInsertOutput calls `rb_econv_encoding_to_insert_output` in C
//
// Original definition is following
//
//	const char *rb_econv_encoding_to_insert_output(rb_econv_t *ec)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvEncodingToInsertOutput(ec *RbEconvT) string {
	var cEc C.rb_econv_t
	ret := string(C.rb_econv_encoding_to_insert_output(&cEc))
	*ec = RbEconvT(cEc)
	return ret
}

// RbEconvHasConvpathP calls `rb_econv_has_convpath_p` in C
//
// Original definition is following
//
//	int rb_econv_has_convpath_p(const char* from_encoding, const char* to_encoding)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvHasConvpathP(from_encoding string, to_encoding string) int {
	charFromEncoding, cleanCharfrom_encoding := string2Char(from_encoding)
	defer cleanCharfrom_encoding()

	charToEncoding, cleanCharto_encoding := string2Char(to_encoding)
	defer cleanCharto_encoding()

	ret := int(C.rb_econv_has_convpath_p(charFromEncoding, charToEncoding))
	return ret
}

// RbEconvInsertOutput calls `rb_econv_insert_output` in C
//
// Original definition is following
//
//	int rb_econv_insert_output(rb_econv_t *ec,
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvInsertOutput(ec *RbEconvT, str *Uchar, len SizeT, str_encoding string) int {
	char, clean := string2Char(str_encoding)
	defer clean()

	var cEc C.rb_econv_t
	var cStr C.uchar
	ret := int(C.rb_econv_insert_output(&cEc, &cStr, C.size_t(len), char))
	*ec = RbEconvT(cEc)
	*str = Uchar(cStr)
	return ret
}

// RbEconvMakeException calls `rb_econv_make_exception` in C
//
// Original definition is following
//
//	VALUE rb_econv_make_exception(rb_econv_t *ec)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvMakeException(ec *RbEconvT) VALUE {
	var cEc C.rb_econv_t
	ret := VALUE(C.rb_econv_make_exception(&cEc))
	*ec = RbEconvT(cEc)
	return ret
}

// RbEconvOpen calls `rb_econv_open` in C
//
// Original definition is following
//
//	rb_econv_t *rb_econv_open(const char *source_encoding, const char *destination_encoding, int ecflags)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvOpen(source_encoding string, destination_encoding string, ecflags int) *RbEconvT {
	charSourceEncoding, cleanCharsource_encoding := string2Char(source_encoding)
	defer cleanCharsource_encoding()

	charDestinationEncoding, cleanChardestination_encoding := string2Char(destination_encoding)
	defer cleanChardestination_encoding()

	ret := *RbEconvT(C.rb_econv_open(charSourceEncoding, charDestinationEncoding, C.int(ecflags)))
	return ret
}

// RbEconvOpenExc calls `rb_econv_open_exc` in C
//
// Original definition is following
//
//	VALUE rb_econv_open_exc(const char *senc, const char *denc, int ecflags)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvOpenExc(senc string, denc string, ecflags int) VALUE {
	charSenc, cleanCharsenc := string2Char(senc)
	defer cleanCharsenc()

	charDenc, cleanChardenc := string2Char(denc)
	defer cleanChardenc()

	ret := VALUE(C.rb_econv_open_exc(charSenc, charDenc, C.int(ecflags)))
	return ret
}

// RbEconvOpenOpts calls `rb_econv_open_opts` in C
//
// Original definition is following
//
//	rb_econv_t *rb_econv_open_opts(const char *source_encoding, const char *destination_encoding, int ecflags, VALUE ecopts)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvOpenOpts(source_encoding string, destination_encoding string, ecflags int, ecopts VALUE) *RbEconvT {
	charSourceEncoding, cleanCharsource_encoding := string2Char(source_encoding)
	defer cleanCharsource_encoding()

	charDestinationEncoding, cleanChardestination_encoding := string2Char(destination_encoding)
	defer cleanChardestination_encoding()

	ret := *RbEconvT(C.rb_econv_open_opts(charSourceEncoding, charDestinationEncoding, C.int(ecflags), C.VALUE(ecopts)))
	return ret
}

// RbEconvPrepareOptions calls `rb_econv_prepare_options` in C
//
// Original definition is following
//
//	int rb_econv_prepare_options(VALUE opthash, VALUE *ecopts, int ecflags)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvPrepareOptions(opthash VALUE, ecopts *VALUE, ecflags int) int {
	var cEcopts C.VALUE
	ret := int(C.rb_econv_prepare_options(C.VALUE(opthash), &cEcopts, C.int(ecflags)))
	*ecopts = VALUE(cEcopts)
	return ret
}

// RbEconvPrepareOpts calls `rb_econv_prepare_opts` in C
//
// Original definition is following
//
//	int rb_econv_prepare_opts(VALUE opthash, VALUE *ecopts)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvPrepareOpts(opthash VALUE, ecopts *VALUE) int {
	var cEcopts C.VALUE
	ret := int(C.rb_econv_prepare_opts(C.VALUE(opthash), &cEcopts))
	*ecopts = VALUE(cEcopts)
	return ret
}

// RbEconvPutback calls `rb_econv_putback` in C
//
// Original definition is following
//
//	void rb_econv_putback(rb_econv_t *ec, unsigned char *p, int n)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvPutback(ec *RbEconvT, p *Uchar, n int) {
	var cEc C.rb_econv_t
	var cP C.uchar
	C.rb_econv_putback(&cEc, &cP, C.int(n))
	*ec = RbEconvT(cEc)
	*p = Uchar(cP)
}

// RbEconvPutbackable calls `rb_econv_putbackable` in C
//
// Original definition is following
//
//	int rb_econv_putbackable(rb_econv_t *ec)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvPutbackable(ec *RbEconvT) int {
	var cEc C.rb_econv_t
	ret := int(C.rb_econv_putbackable(&cEc))
	*ec = RbEconvT(cEc)
	return ret
}

// RbEconvSetReplacement calls `rb_econv_set_replacement` in C
//
// Original definition is following
//
//	int rb_econv_set_replacement(rb_econv_t *ec, const unsigned char *str, size_t len, const char *encname)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvSetReplacement(ec *RbEconvT, str *Uchar, len SizeT, encname string) int {
	char, clean := string2Char(encname)
	defer clean()

	var cEc C.rb_econv_t
	var cStr C.uchar
	ret := int(C.rb_econv_set_replacement(&cEc, &cStr, C.size_t(len), char))
	*ec = RbEconvT(cEc)
	*str = Uchar(cStr)
	return ret
}

// RbEconvStrAppend calls `rb_econv_str_append` in C
//
// Original definition is following
//
//	VALUE rb_econv_str_append(rb_econv_t *ec, VALUE src, VALUE dst, int flags)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvStrAppend(ec *RbEconvT, src VALUE, dst VALUE, flags int) VALUE {
	var cEc C.rb_econv_t
	ret := VALUE(C.rb_econv_str_append(&cEc, C.VALUE(src), C.VALUE(dst), C.int(flags)))
	*ec = RbEconvT(cEc)
	return ret
}

// RbEconvStrConvert calls `rb_econv_str_convert` in C
//
// Original definition is following
//
//	VALUE rb_econv_str_convert(rb_econv_t *ec, VALUE src, int flags)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvStrConvert(ec *RbEconvT, src VALUE, flags int) VALUE {
	var cEc C.rb_econv_t
	ret := VALUE(C.rb_econv_str_convert(&cEc, C.VALUE(src), C.int(flags)))
	*ec = RbEconvT(cEc)
	return ret
}

// RbEconvSubstrAppend calls `rb_econv_substr_append` in C
//
// Original definition is following
//
//	VALUE rb_econv_substr_append(rb_econv_t *ec, VALUE src, long byteoff, long bytesize, VALUE dst, int flags)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvSubstrAppend(ec *RbEconvT, src VALUE, byteoff Long, bytesize Long, dst VALUE, flags int) VALUE {
	var cEc C.rb_econv_t
	ret := VALUE(C.rb_econv_substr_append(&cEc, C.VALUE(src), C.long(byteoff), C.long(bytesize), C.VALUE(dst), C.int(flags)))
	*ec = RbEconvT(cEc)
	return ret
}

// RbEconvSubstrConvert calls `rb_econv_substr_convert` in C
//
// Original definition is following
//
//	VALUE rb_econv_substr_convert(rb_econv_t *ec, VALUE src, long byteoff, long bytesize, int flags)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbEconvSubstrConvert(ec *RbEconvT, src VALUE, byteoff Long, bytesize Long, flags int) VALUE {
	var cEc C.rb_econv_t
	ret := VALUE(C.rb_econv_substr_convert(&cEc, C.VALUE(src), C.long(byteoff), C.long(bytesize), C.int(flags)))
	*ec = RbEconvT(cEc)
	return ret
}

// RbStrEncode calls `rb_str_encode` in C
//
// Original definition is following
//
//	VALUE rb_str_encode(VALUE str, VALUE to, int ecflags, VALUE ecopts)
//
// ref. https://github.com/ruby/ruby/blob/master/include/ruby/internal/encoding/transcode.h
func RbStrEncode(str VALUE, to VALUE, ecflags int, ecopts VALUE) VALUE {
	ret := VALUE(C.rb_str_encode(C.VALUE(str), C.VALUE(to), C.int(ecflags), C.VALUE(ecopts)))
	return ret
}
